diff --git a/subsys/bluetooth/host/adv.c b/subsys/bluetooth/host/adv.c
index db71858f8f2..35a1d8b11e4 100644
--- a/subsys/bluetooth/host/adv.c
+++ b/subsys/bluetooth/host/adv.c
@@ -58,8 +58,7 @@ struct ad_stream {
 	size_t remaining_size;
 };
 
-static int ad_stream_new(struct ad_stream *stream,
-			 const struct bt_ad *ad, size_t ad_len)
+static int ad_stream_new(struct ad_stream *stream, const struct bt_ad *ad, size_t ad_len)
 {
 	(void)memset(stream, 0, sizeof(*stream));
 	stream->ad = ad;
@@ -155,12 +154,12 @@ static uint8_t ad_stream_read(struct ad_stream *stream, uint8_t *buf, uint8_t bu
 			read_len++;
 		} else {
 			const size_t remaining_data_len =
-					current_ltv->data_len - stream->current_ltv_offset + 2;
+				current_ltv->data_len - stream->current_ltv_offset + 2;
 			const size_t size_to_copy = MIN(buf_len - read_len, remaining_data_len);
 
 			(void)memcpy(&buf[read_len],
-				&current_ltv->data[stream->current_ltv_offset - 2],
-				size_to_copy);
+				     &current_ltv->data[stream->current_ltv_offset - 2],
+				     size_to_copy);
 			stream->current_ltv_offset += size_to_copy;
 			read_len += size_to_copy;
 		}
@@ -207,14 +206,12 @@ enum adv_name_type get_adv_name_type_param(const struct bt_le_adv_param *param)
 static struct bt_le_ext_adv adv_pool[CONFIG_BT_EXT_ADV_MAX_ADV_SET];
 #endif /* defined(CONFIG_BT_EXT_ADV) */
 
-
 #if defined(CONFIG_BT_EXT_ADV)
 uint8_t bt_le_ext_adv_get_index(struct bt_le_ext_adv *adv)
 {
 	ptrdiff_t index = adv - adv_pool;
 
-	__ASSERT(index >= 0 && index < ARRAY_SIZE(adv_pool),
-		 "Invalid bt_adv pointer");
+	__ASSERT(index >= 0 && index < ARRAY_SIZE(adv_pool), "Invalid bt_adv pointer");
 	return (uint8_t)index;
 }
 
@@ -259,8 +256,7 @@ struct bt_le_ext_adv *bt_hci_adv_lookup_handle(uint8_t handle)
 #endif /* CONFIG_BT_BROADCASTER */
 #endif /* defined(CONFIG_BT_EXT_ADV) */
 
-void bt_le_ext_adv_foreach(void (*func)(struct bt_le_ext_adv *adv, void *data),
-			   void *data)
+void bt_le_ext_adv_foreach(void (*func)(struct bt_le_ext_adv *adv, void *data), void *data)
 {
 #if defined(CONFIG_BT_EXT_ADV)
 	for (size_t i = 0; i < ARRAY_SIZE(adv_pool); i++) {
@@ -343,9 +339,8 @@ int bt_le_adv_set_enable_legacy(struct bt_le_ext_adv *adv, bool enable)
 	return 0;
 }
 
-int bt_le_adv_set_enable_ext(struct bt_le_ext_adv *adv,
-			 bool enable,
-			 const struct bt_le_ext_adv_start_param *param)
+int bt_le_adv_set_enable_ext(struct bt_le_ext_adv *adv, bool enable,
+			     const struct bt_le_ext_adv_start_param *param)
 {
 	struct net_buf *buf;
 	struct bt_hci_cmd_state_set state;
@@ -380,8 +375,7 @@ int bt_le_adv_set_enable_ext(struct bt_le_ext_adv *adv,
 
 int bt_le_adv_set_enable(struct bt_le_ext_adv *adv, bool enable)
 {
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		return bt_le_adv_set_enable_ext(adv, enable, NULL);
 	}
 
@@ -390,10 +384,8 @@ int bt_le_adv_set_enable(struct bt_le_ext_adv *adv, bool enable)
 
 static bool valid_adv_ext_param(const struct bt_le_adv_param *param)
 {
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
-		if (param->peer &&
-		    !(param->options & BT_LE_ADV_OPT_EXT_ADV) &&
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+		if (param->peer && !(param->options & BT_LE_ADV_OPT_EXT_ADV) &&
 		    !(param->options & _BT_LE_ADV_OPT_CONNECTABLE)) {
 			/* Cannot do directed non-connectable advertising
 			 * without extended advertising.
@@ -401,8 +393,7 @@ static bool valid_adv_ext_param(const struct bt_le_adv_param *param)
 			return false;
 		}
 
-		if (param->peer &&
-		    (param->options & BT_LE_ADV_OPT_EXT_ADV) &&
+		if (param->peer && (param->options & BT_LE_ADV_OPT_EXT_ADV) &&
 		    !(param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY)) {
 			/* High duty cycle directed connectable advertising
 			 * shall not be used with Extended Advertising.
@@ -411,11 +402,9 @@ static bool valid_adv_ext_param(const struct bt_le_adv_param *param)
 		}
 
 		if (!(param->options & BT_LE_ADV_OPT_EXT_ADV) &&
-		    param->options & (BT_LE_ADV_OPT_EXT_ADV |
-				      BT_LE_ADV_OPT_NO_2M |
-				      BT_LE_ADV_OPT_CODED |
-				      BT_LE_ADV_OPT_ANONYMOUS |
-				      BT_LE_ADV_OPT_USE_TX_POWER)) {
+		    param->options &
+			    (BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_NO_2M | BT_LE_ADV_OPT_CODED |
+			     BT_LE_ADV_OPT_ANONYMOUS | BT_LE_ADV_OPT_USE_TX_POWER)) {
 			/* Extended options require extended advertising. */
 			return false;
 		}
@@ -430,8 +419,7 @@ static bool valid_adv_ext_param(const struct bt_le_adv_param *param)
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    param->peer &&
+	if (IS_ENABLED(CONFIG_BT_PRIVACY) && param->peer &&
 	    (param->options & BT_LE_ADV_OPT_USE_IDENTITY) &&
 	    (param->options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
 		/* own addr type used for both RPAs in directed advertising. */
@@ -450,22 +438,18 @@ static bool valid_adv_ext_param(const struct bt_le_adv_param *param)
 		 * shall not be set to less than 0x00A0 (100 ms) if the
 		 * Advertising_Type is set to ADV_SCAN_IND or ADV_NONCONN_IND.
 		 */
-		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
-		    param->interval_min < 0x00a0) {
+		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 && param->interval_min < 0x00a0) {
 			return false;
 		}
 	}
 
-	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
-			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
+	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY | BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
 	    !param->peer) {
 		return false;
 	}
 
-	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
-	    !param->peer) {
-		if (param->interval_min > param->interval_max ||
-		    param->interval_min < 0x0020 ||
+	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) || !param->peer) {
+		if (param->interval_min > param->interval_max || param->interval_min < 0x0020 ||
 		    param->interval_max > 0x4000) {
 			return false;
 		}
@@ -494,7 +478,7 @@ static bool valid_adv_param(const struct bt_le_adv_param *param)
 }
 
 static int set_data_add_complete(uint8_t *set_data, uint8_t set_data_len_max,
-			const struct bt_ad *ad, size_t ad_len, uint8_t *data_len)
+				 const struct bt_ad *ad, size_t ad_len, uint8_t *data_len)
 {
 	uint8_t set_data_len = 0;
 
@@ -507,11 +491,9 @@ static int set_data_add_complete(uint8_t *set_data, uint8_t set_data_len_max,
 
 			/* Check if ad fit in the remaining buffer */
 			if ((set_data_len + len + 2) > set_data_len_max) {
-				ssize_t shortened_len = set_data_len_max -
-							(set_data_len + 2);
+				ssize_t shortened_len = set_data_len_max - (set_data_len + 2);
 
-				if (!(type == BT_DATA_NAME_COMPLETE &&
-				      shortened_len > 0)) {
+				if (!(type == BT_DATA_NAME_COMPLETE && shortened_len > 0)) {
 					LOG_ERR("Too big advertising data");
 					return -EINVAL;
 				}
@@ -546,8 +528,8 @@ static int hci_set_ad(uint16_t hci_op, const struct bt_ad *ad, size_t ad_len)
 	set_data = net_buf_add(buf, sizeof(*set_data));
 	(void)memset(set_data, 0, sizeof(*set_data));
 
-	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
-				    ad, ad_len, &set_data->len);
+	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN, ad, ad_len,
+				    &set_data->len);
 	if (err) {
 		net_buf_unref(buf);
 		return err;
@@ -580,8 +562,7 @@ static int hci_set_adv_ext_complete(struct bt_le_ext_adv *adv, uint16_t hci_op,
 	set_data = net_buf_add(buf, cmd_size);
 	(void)memset(set_data, 0, cmd_size);
 
-	err = set_data_add_complete(set_data->data, total_data_len,
-				    ad, ad_len, &set_data->len);
+	err = set_data_add_complete(set_data->data, total_data_len, ad, ad_len, &set_data->len);
 	if (err) {
 		net_buf_unref(buf);
 		return err;
@@ -644,8 +625,8 @@ static int hci_set_adv_ext_fragmented(struct bt_le_ext_adv *adv, uint16_t hci_op
 	return 0;
 }
 
-static int hci_set_ad_ext(struct bt_le_ext_adv *adv, uint16_t hci_op,
-			  const struct bt_ad *ad, size_t ad_len)
+static int hci_set_ad_ext(struct bt_le_ext_adv *adv, uint16_t hci_op, const struct bt_ad *ad,
+			  size_t ad_len)
 {
 	size_t total_len_bytes = 0;
 
@@ -681,37 +662,31 @@ static int hci_set_ad_ext(struct bt_le_ext_adv *adv, uint16_t hci_op,
 	return 0;
 }
 
-static int set_ad(struct bt_le_ext_adv *adv, const struct bt_ad *ad,
-		  size_t ad_len)
+static int set_ad(struct bt_le_ext_adv *adv, const struct bt_ad *ad, size_t ad_len)
 {
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
-		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_ADV_DATA,
-				      ad, ad_len);
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_ADV_DATA, ad, ad_len);
 	}
 
 	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
 }
 
-static int set_sd(struct bt_le_ext_adv *adv, const struct bt_ad *sd,
-		  size_t sd_len)
+static int set_sd(struct bt_le_ext_adv *adv, const struct bt_ad *sd, size_t sd_len)
 {
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
-		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_SCAN_RSP_DATA,
-				      sd, sd_len);
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_SCAN_RSP_DATA, sd, sd_len);
 	}
 
 	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
 }
 
 #if defined(CONFIG_BT_PER_ADV)
-static int hci_set_per_adv_data(const struct bt_le_ext_adv *adv,
-				const struct bt_data *ad, size_t ad_len)
+static int hci_set_per_adv_data(const struct bt_le_ext_adv *adv, const struct bt_data *ad,
+				size_t ad_len)
 {
 	int err;
 	struct ad_stream stream;
-	struct bt_ad d = { .data = ad, .len = ad_len };
+	struct bt_ad d = {.data = ad, .len = ad_len};
 	bool is_first_iteration = true;
 
 	err = ad_stream_new(&stream, &d, 1);
@@ -763,8 +738,7 @@ static inline bool ad_has_name(const struct bt_data *ad, size_t ad_len)
 	size_t i;
 
 	for (i = 0; i < ad_len; i++) {
-		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
-		    ad[i].type == BT_DATA_NAME_SHORTENED) {
+		if (ad[i].type == BT_DATA_NAME_COMPLETE || ad[i].type == BT_DATA_NAME_SHORTENED) {
 			return true;
 		}
 	}
@@ -777,8 +751,7 @@ static bool ad_is_limited(const struct bt_data *ad, size_t ad_len)
 	size_t i;
 
 	for (i = 0; i < ad_len; i++) {
-		if (ad[i].type == BT_DATA_FLAGS &&
-		    ad[i].data_len == sizeof(uint8_t) &&
+		if (ad[i].type == BT_DATA_FLAGS && ad[i].data_len == sizeof(uint8_t) &&
 		    ad[i].data != NULL) {
 			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
 				return true;
@@ -789,10 +762,8 @@ static bool ad_is_limited(const struct bt_data *ad, size_t ad_len)
 	return false;
 }
 
-static int le_adv_update(struct bt_le_ext_adv *adv,
-			 const struct bt_data *ad, size_t ad_len,
-			 const struct bt_data *sd, size_t sd_len,
-			 bool ext_adv, bool scannable,
+static int le_adv_update(struct bt_le_ext_adv *adv, const struct bt_data *ad, size_t ad_len,
+			 const struct bt_data *sd, size_t sd_len, bool ext_adv, bool scannable,
 			 enum adv_name_type name_type)
 {
 	struct bt_ad d[2] = {};
@@ -803,15 +774,12 @@ static int le_adv_update(struct bt_le_ext_adv *adv,
 	if (name_type != ADV_NAME_TYPE_NONE) {
 		const char *name = bt_get_name();
 
-		if ((ad && ad_has_name(ad, ad_len)) ||
-		    (sd && ad_has_name(sd, sd_len))) {
+		if ((ad && ad_has_name(ad, ad_len)) || (sd && ad_has_name(sd, sd_len))) {
 			/* Cannot use name if name is already set */
 			return -EINVAL;
 		}
 
-		data = (struct bt_data)BT_DATA(
-			BT_DATA_NAME_COMPLETE,
-			name, strlen(name));
+		data = (struct bt_data)BT_DATA(BT_DATA_NAME_COMPLETE, name, strlen(name));
 	}
 
 	if (!(ext_adv && scannable)) {
@@ -852,8 +820,8 @@ static int le_adv_update(struct bt_le_ext_adv *adv,
 	return 0;
 }
 
-int bt_le_adv_update_data(const struct bt_data *ad, size_t ad_len,
-			  const struct bt_data *sd, size_t sd_len)
+int bt_le_adv_update_data(const struct bt_data *ad, size_t ad_len, const struct bt_data *sd,
+			  size_t sd_len)
 {
 	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 	bool scannable;
@@ -868,8 +836,7 @@ int bt_le_adv_update_data(const struct bt_data *ad, size_t ad_len,
 
 	scannable = atomic_test_bit(adv->flags, BT_ADV_SCANNABLE);
 
-	return le_adv_update(adv, ad, ad_len, sd, sd_len, false, scannable,
-			     get_adv_name_type(adv));
+	return le_adv_update(adv, ad, ad_len, sd, sd_len, false, scannable, get_adv_name_type(adv));
 }
 
 static uint8_t get_filter_policy(uint32_t options)
@@ -915,8 +882,7 @@ static inline bool adv_is_directed(const struct bt_le_ext_adv *adv)
 	return !bt_addr_le_eq(&adv->target_addr, BT_ADDR_LE_ANY);
 }
 
-static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
-				 struct bt_conn **out_conn)
+static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv, struct bt_conn **out_conn)
 {
 	struct bt_conn *conn;
 
@@ -953,8 +919,7 @@ static void le_adv_stop_free_conn(const struct bt_le_ext_adv *adv, uint8_t statu
 	struct bt_conn *conn;
 
 	if (!adv_is_directed(adv)) {
-		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
-					       BT_CONN_ADV_CONNECTABLE);
+		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE, BT_CONN_ADV_CONNECTABLE);
 	} else {
 		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
 					       BT_CONN_ADV_DIR_CONNECTABLE);
@@ -967,10 +932,9 @@ static void le_adv_stop_free_conn(const struct bt_le_ext_adv *adv, uint8_t statu
 	}
 }
 
-int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
-			   const struct bt_le_adv_param *param,
-			   const struct bt_data *ad, size_t ad_len,
-			   const struct bt_data *sd, size_t sd_len)
+int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv, const struct bt_le_adv_param *param,
+			   const struct bt_data *ad, size_t ad_len, const struct bt_data *sd,
+			   size_t sd_len)
 {
 	struct bt_hci_cp_le_set_adv_param set_param;
 	struct bt_conn *conn = NULL;
@@ -1000,7 +964,7 @@ int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
 
 	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
 	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
-	set_param.channel_map  = get_adv_channel_map(param->options);
+	set_param.channel_map = get_adv_channel_map(param->options);
 	set_param.filter_policy = get_filter_policy(param->options);
 
 	atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
@@ -1008,8 +972,7 @@ int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
 	adv->id = param->id;
 	bt_dev.adv_conn_id = adv->id;
 
-	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
-				     &set_param.own_addr_type);
+	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv, &set_param.own_addr_type);
 	if (err) {
 		return err;
 	}
@@ -1056,15 +1019,13 @@ int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
 	}
 
 	if (!dir_adv) {
-		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
-				    scannable, name_type);
+		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false, scannable, name_type);
 		if (err) {
 			return err;
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    (param->options & _BT_LE_ADV_OPT_CONNECTABLE)) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && (param->options & _BT_LE_ADV_OPT_CONNECTABLE)) {
 		err = le_adv_start_add_conn(adv, &conn);
 		if (err) {
 			if (err == -ENOMEM && !dir_adv &&
@@ -1097,14 +1058,12 @@ int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
 	}
 
 set_adv_state:
-	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
-			  !(param->options & _BT_LE_ADV_OPT_ONE_TIME));
+	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST,
+			  !dir_adv && !(param->options & _BT_LE_ADV_OPT_ONE_TIME));
 
-	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
-			  name_type == ADV_NAME_TYPE_AD);
+	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD, name_type == ADV_NAME_TYPE_AD);
 
-	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
-			  name_type == ADV_NAME_TYPE_SD);
+	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD, name_type == ADV_NAME_TYPE_SD);
 
 	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
 			  param->options & _BT_LE_ADV_OPT_CONNECTABLE);
@@ -1117,9 +1076,8 @@ set_adv_state:
 	return 0;
 }
 
-static int le_ext_adv_param_set(struct bt_le_ext_adv *adv,
-				const struct bt_le_adv_param *param,
-				bool  has_scan_data)
+static int le_ext_adv_param_set(struct bt_le_ext_adv *adv, const struct bt_le_adv_param *param,
+				bool has_scan_data)
 {
 	struct bt_hci_cp_le_set_ext_adv_param *cp;
 	bool dir_adv = param->peer != NULL, scannable;
@@ -1138,8 +1096,7 @@ static int le_ext_adv_param_set(struct bt_le_ext_adv *adv,
 
 	adv->options = param->options;
 
-	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
-				     &cp->own_addr_type);
+	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv, &cp->own_addr_type);
 	if (err) {
 		net_buf_unref(buf);
 		return err;
@@ -1161,8 +1118,7 @@ static int le_ext_adv_param_set(struct bt_le_ext_adv *adv,
 	cp->tx_power = BT_HCI_LE_ADV_TX_POWER_NO_PREF;
 
 	cp->prim_adv_phy = BT_HCI_LE_PHY_1M;
-	if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
-	    !(param->options & BT_LE_ADV_OPT_NO_2M)) {
+	if ((param->options & BT_LE_ADV_OPT_EXT_ADV) && !(param->options & BT_LE_ADV_OPT_NO_2M)) {
 		cp->sec_adv_phy = BT_HCI_LE_PHY_2M;
 	} else {
 		cp->sec_adv_phy = BT_HCI_LE_PHY_1M;
@@ -1247,11 +1203,9 @@ static int le_ext_adv_param_set(struct bt_le_ext_adv *adv,
 	/* Flag only used by bt_le_adv_start API. */
 	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, false);
 
-	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
-			  name_type == ADV_NAME_TYPE_AD);
+	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD, name_type == ADV_NAME_TYPE_AD);
 
-	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
-			  name_type == ADV_NAME_TYPE_SD);
+	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD, name_type == ADV_NAME_TYPE_SD);
 
 	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
 			  param->options & _BT_LE_ADV_OPT_CONNECTABLE);
@@ -1261,16 +1215,14 @@ static int le_ext_adv_param_set(struct bt_le_ext_adv *adv,
 	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
 			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);
 
-	atomic_set_bit_to(adv->flags, BT_ADV_EXT_ADV,
-			  param->options & BT_LE_ADV_OPT_EXT_ADV);
+	atomic_set_bit_to(adv->flags, BT_ADV_EXT_ADV, param->options & BT_LE_ADV_OPT_EXT_ADV);
 
 	return 0;
 }
 
-int bt_le_adv_start_ext(struct bt_le_ext_adv *adv,
-			const struct bt_le_adv_param *param,
-			const struct bt_data *ad, size_t ad_len,
-			const struct bt_data *sd, size_t sd_len)
+int bt_le_adv_start_ext(struct bt_le_ext_adv *adv, const struct bt_le_adv_param *param,
+			const struct bt_data *ad, size_t ad_len, const struct bt_data *sd,
+			size_t sd_len)
 {
 	struct bt_le_ext_adv_start_param start_param = {
 		.timeout = 0,
@@ -1307,14 +1259,12 @@ int bt_le_adv_start_ext(struct bt_le_ext_adv *adv,
 		}
 	} else {
 		if (!(param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY)) {
-			start_param.timeout =
-				BT_GAP_ADV_HIGH_DUTY_CYCLE_MAX_TIMEOUT;
+			start_param.timeout = BT_GAP_ADV_HIGH_DUTY_CYCLE_MAX_TIMEOUT;
 			atomic_set_bit(adv->flags, BT_ADV_LIMITED);
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    (param->options & _BT_LE_ADV_OPT_CONNECTABLE)) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && (param->options & _BT_LE_ADV_OPT_CONNECTABLE)) {
 		err = le_adv_start_add_conn(adv, &conn);
 		if (err) {
 			if (err == -ENOMEM && !dir_adv &&
@@ -1348,8 +1298,8 @@ int bt_le_adv_start_ext(struct bt_le_ext_adv *adv,
 
 set_adv_state:
 	/* Flag always set to false by le_ext_adv_param_set */
-	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
-			  !(param->options & _BT_LE_ADV_OPT_ONE_TIME));
+	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST,
+			  !dir_adv && !(param->options & _BT_LE_ADV_OPT_ONE_TIME));
 
 	return 0;
 }
@@ -1361,8 +1311,7 @@ int bt_le_lim_adv_cancel_timeout(struct bt_le_ext_adv *adv)
 	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
 }
 
-int bt_le_adv_start(const struct bt_le_adv_param *param,
-		    const struct bt_data *ad, size_t ad_len,
+int bt_le_adv_start(const struct bt_le_adv_param *param, const struct bt_data *ad, size_t ad_len,
 		    const struct bt_data *sd, size_t sd_len)
 {
 	struct bt_le_ext_adv *adv;
@@ -1375,8 +1324,7 @@ int bt_le_adv_start(const struct bt_le_adv_param *param,
 
 	adv = bt_le_adv_lookup_legacy();
 
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
 	} else {
 		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
@@ -1388,8 +1336,7 @@ int bt_le_adv_start(const struct bt_le_adv_param *param,
 
 	if (ad_is_limited(ad, ad_len)) {
 		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
-		k_work_reschedule(&adv->lim_adv_timeout_work,
-				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
+		k_work_reschedule(&adv->lim_adv_timeout_work, K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
 	}
 
 	return err;
@@ -1421,13 +1368,11 @@ int bt_le_adv_stop(void)
 		return 0;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
 		le_adv_stop_free_conn(adv, 0);
 	}
 
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		err = bt_le_adv_set_enable_ext(adv, false, NULL);
 		if (err) {
 			return err;
@@ -1442,10 +1387,8 @@ int bt_le_adv_stop(void)
 	bt_le_adv_delete_legacy();
 
 #if defined(CONFIG_BT_OBSERVER)
-	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	      BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) &&
-	    !IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    !IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY)) {
+	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) &&
+	    !IS_ENABLED(CONFIG_BT_PRIVACY) && !IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY)) {
 		/* If scan is ongoing set back NRPA */
 		if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
 			bt_le_scan_set_enable(BT_HCI_LE_SCAN_DISABLE);
@@ -1507,8 +1450,7 @@ void bt_le_adv_resume(void)
 
 	LOG_DBG("Resuming connectable advertising");
 
-	if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
+	if (IS_ENABLED(CONFIG_BT_PRIVACY) && !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
 		bt_id_set_adv_private_addr(adv);
 	} else {
 		uint8_t own_addr_type;
@@ -1531,8 +1473,7 @@ void bt_le_adv_resume(void)
 		/* Temporarily clear persist flag to avoid recursion in
 		 * bt_conn_unref if the flag is still set.
 		 */
-		persist_paused = atomic_test_and_clear_bit(adv->flags,
-							   BT_ADV_PERSIST);
+		persist_paused = atomic_test_and_clear_bit(adv->flags, BT_ADV_PERSIST);
 	}
 
 	/* Since we don't give the application a reference to manage in
@@ -1546,8 +1487,7 @@ void bt_le_adv_resume(void)
 #endif /* defined(CONFIG_BT_PERIPHERAL) */
 
 #if defined(CONFIG_BT_EXT_ADV)
-int bt_le_ext_adv_get_info(const struct bt_le_ext_adv *adv,
-			   struct bt_le_ext_adv_info *info)
+int bt_le_ext_adv_get_info(const struct bt_le_ext_adv *adv, struct bt_le_ext_adv_info *info)
 {
 	info->id = adv->id;
 	info->tx_power = adv->tx_power;
@@ -1556,8 +1496,7 @@ int bt_le_ext_adv_get_info(const struct bt_le_ext_adv *adv,
 	return 0;
 }
 
-int bt_le_ext_adv_create(const struct bt_le_adv_param *param,
-			 const struct bt_le_ext_adv_cb *cb,
+int bt_le_ext_adv_create(const struct bt_le_adv_param *param, const struct bt_le_ext_adv_cb *cb,
 			 struct bt_le_ext_adv **out_adv)
 {
 	struct bt_le_ext_adv *adv;
@@ -1595,8 +1534,7 @@ int bt_le_ext_adv_create(const struct bt_le_adv_param *param,
 	return 0;
 }
 
-int bt_le_ext_adv_update_param(struct bt_le_ext_adv *adv,
-			       const struct bt_le_adv_param *param)
+int bt_le_ext_adv_update_param(struct bt_le_ext_adv *adv, const struct bt_le_adv_param *param)
 {
 	CHECKIF(adv == NULL) {
 		LOG_DBG("adv is NULL");
@@ -1608,8 +1546,7 @@ int bt_le_ext_adv_update_param(struct bt_le_ext_adv *adv,
 		return -EINVAL;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PER_ADV) &&
-	    atomic_test_bit(adv->flags, BT_PER_ADV_PARAMS_SET)) {
+	if (IS_ENABLED(CONFIG_BT_PER_ADV) && atomic_test_bit(adv->flags, BT_PER_ADV_PARAMS_SET)) {
 		/* If params for per adv has been set, do not allow setting
 		 * connectable, scanable or use legacy adv
 		 */
@@ -1632,8 +1569,7 @@ int bt_le_ext_adv_update_param(struct bt_le_ext_adv *adv,
 	return le_ext_adv_param_set(adv, param, false);
 }
 
-int bt_le_ext_adv_start(struct bt_le_ext_adv *adv,
-			const struct bt_le_ext_adv_start_param *param)
+int bt_le_ext_adv_start(struct bt_le_ext_adv *adv, const struct bt_le_ext_adv_start_param *param)
 {
 	struct bt_conn *conn = NULL;
 	int err;
@@ -1648,16 +1584,15 @@ int bt_le_ext_adv_start(struct bt_le_ext_adv *adv,
 		return -EALREADY;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
 		err = le_adv_start_add_conn(adv, &conn);
 		if (err) {
 			return err;
 		}
 	}
 
-	atomic_set_bit_to(adv->flags, BT_ADV_LIMITED, param &&
-			  (param->timeout > 0 || param->num_events > 0));
+	atomic_set_bit_to(adv->flags, BT_ADV_LIMITED,
+			  param && (param->timeout > 0 || param->num_events > 0));
 
 	if (atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
 		if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
@@ -1723,16 +1658,14 @@ int bt_le_ext_adv_stop(struct bt_le_ext_adv *adv)
 #endif
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
 		le_adv_stop_free_conn(adv, 0);
 	}
 
 	return bt_le_adv_set_enable_ext(adv, false, NULL);
 }
 
-int bt_le_ext_adv_set_data(struct bt_le_ext_adv *adv,
-			   const struct bt_data *ad, size_t ad_len,
+int bt_le_ext_adv_set_data(struct bt_le_ext_adv *adv, const struct bt_data *ad, size_t ad_len,
 			   const struct bt_data *sd, size_t sd_len)
 {
 	bool ext_adv, scannable;
@@ -1747,8 +1680,7 @@ int bt_le_ext_adv_set_data(struct bt_le_ext_adv *adv,
 	scannable = atomic_test_bit(adv->flags, BT_ADV_SCANNABLE);
 
 	if (ext_adv) {
-		if ((scannable && ad_len) ||
-		    (!scannable && sd_len)) {
+		if ((scannable && ad_len) || (!scannable && sd_len)) {
 			return -ENOTSUP;
 		}
 	}
@@ -1798,7 +1730,6 @@ int bt_le_ext_adv_delete(struct bt_le_ext_adv *adv)
 }
 #endif /* defined(CONFIG_BT_EXT_ADV) */
 
-
 static void adv_timeout(struct k_work *work)
 {
 	int err = 0;
@@ -1823,8 +1754,7 @@ static void adv_timeout(struct k_work *work)
 }
 
 #if defined(CONFIG_BT_PER_ADV)
-int bt_le_per_adv_set_param(struct bt_le_ext_adv *adv,
-			    const struct bt_le_per_adv_param *param)
+int bt_le_per_adv_set_param(struct bt_le_ext_adv *adv, const struct bt_le_per_adv_param *param)
 {
 #if defined(CONFIG_BT_PER_ADV_RSP)
 	/* The v2 struct can be used even if we end up sending a v1 command
@@ -1921,8 +1851,7 @@ int bt_le_per_adv_set_param(struct bt_le_ext_adv *adv,
 	return 0;
 }
 
-int bt_le_per_adv_set_data(const struct bt_le_ext_adv *adv,
-			   const struct bt_data *ad, size_t ad_len)
+int bt_le_per_adv_set_data(const struct bt_le_ext_adv *adv, const struct bt_data *ad, size_t ad_len)
 {
 	size_t total_len_bytes = 0;
 
@@ -2053,8 +1982,7 @@ static int bt_le_per_adv_enable(struct bt_le_ext_adv *adv, bool enable)
 		cp->enable = 0U;
 	}
 
-	bt_hci_cmd_state_set_init(buf, &state, adv->flags,
-				  BT_PER_ADV_ENABLED, enable);
+	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_PER_ADV_ENABLED, enable);
 
 	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PER_ADV_ENABLE, buf, NULL);
 	if (err) {
@@ -2173,22 +2101,19 @@ void bt_hci_le_per_adv_response_report(struct net_buf *buf)
 #endif /* CONFIG_BT_PER_ADV_RSP */
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER)
-int bt_le_per_adv_set_info_transfer(const struct bt_le_ext_adv *adv,
-				    const struct bt_conn *conn,
+int bt_le_per_adv_set_info_transfer(const struct bt_le_ext_adv *adv, const struct bt_conn *conn,
 				    uint16_t service_data)
 {
 	struct bt_hci_cp_le_per_adv_set_info_transfer *cp;
 	struct net_buf *buf;
 
-
 	if (!BT_FEAT_LE_EXT_PER_ADV(bt_dev.le.features)) {
 		return -ENOTSUP;
 	} else if (!BT_FEAT_LE_PAST_SEND(bt_dev.le.features)) {
 		return -ENOTSUP;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_PER_ADV_SET_INFO_TRANSFER,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_PER_ADV_SET_INFO_TRANSFER, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -2200,8 +2125,7 @@ int bt_le_per_adv_set_info_transfer(const struct bt_le_ext_adv *adv,
 	cp->adv_handle = adv->handle;
 	cp->service_data = sys_cpu_to_le16(service_data);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_SET_INFO_TRANSFER, buf,
-				    NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_SET_INFO_TRANSFER, buf, NULL);
 }
 #endif /* CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER */
 #endif /* CONFIG_BT_PER_ADV */
@@ -2221,9 +2145,9 @@ void bt_hci_le_adv_set_terminated(struct net_buf *buf)
 	adv = bt_hci_adv_lookup_handle(evt->adv_handle);
 	conn_handle = sys_le16_to_cpu(evt->conn_handle);
 
-	LOG_DBG("status 0x%02x %s adv_handle %u conn_handle 0x%02x num %u",
-		evt->status, bt_hci_err_to_str(evt->status),
-		evt->adv_handle, conn_handle, evt->num_completed_ext_adv_evts);
+	LOG_DBG("status 0x%02x %s adv_handle %u conn_handle 0x%02x num %u", evt->status,
+		bt_hci_err_to_str(evt->status), evt->adv_handle, conn_handle,
+		evt->num_completed_ext_adv_evts);
 
 	if (!adv) {
 		LOG_ERR("No valid adv");
@@ -2275,15 +2199,12 @@ void bt_hci_le_adv_set_terminated(struct net_buf *buf)
 				/* Set Responder address unless already set */
 				conn->le.resp_addr.type = BT_ADDR_LE_RANDOM;
 				if (bt_addr_eq(&conn->le.resp_addr.a, BT_ADDR_ANY)) {
-					bt_addr_copy(&conn->le.resp_addr.a,
-						     &adv->random_addr.a);
+					bt_addr_copy(&conn->le.resp_addr.a, &adv->random_addr.a);
 				}
 			} else if (adv->options & BT_LE_ADV_OPT_USE_NRPA) {
-				bt_addr_le_copy(&conn->le.resp_addr,
-						&adv->random_addr);
+				bt_addr_le_copy(&conn->le.resp_addr, &adv->random_addr);
 			} else {
-				bt_addr_le_copy(&conn->le.resp_addr,
-					&bt_dev.id_addr[conn->id]);
+				bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr[conn->id]);
 			}
 
 			if (adv->cb && adv->cb->connected) {
@@ -2347,8 +2268,7 @@ void bt_hci_le_scan_req_received(struct net_buf *buf)
 		if (bt_addr_le_is_resolved(&evt->addr)) {
 			bt_addr_le_copy_resolved(&id_addr, &evt->addr);
 		} else {
-			bt_addr_le_copy(&id_addr,
-					bt_lookup_id_addr(adv->id, &evt->addr));
+			bt_addr_le_copy(&id_addr, bt_lookup_id_addr(adv->id, &evt->addr));
 		}
 
 		info.addr = &id_addr;
diff --git a/subsys/bluetooth/host/adv.h b/subsys/bluetooth/host/adv.h
index 3a03bfe8f4c..313ce94ef35 100644
--- a/subsys/bluetooth/host/adv.h
+++ b/subsys/bluetooth/host/adv.h
@@ -12,12 +12,10 @@ struct bt_le_ext_adv *bt_le_adv_lookup_legacy(void);
 void bt_le_adv_delete_legacy(void);
 int bt_le_adv_set_enable(struct bt_le_ext_adv *adv, bool enable);
 
-void bt_le_ext_adv_foreach(void (*func)(struct bt_le_ext_adv *adv, void *data),
-			   void *data);
+void bt_le_ext_adv_foreach(void (*func)(struct bt_le_ext_adv *adv, void *data), void *data);
 
-int bt_le_adv_set_enable_ext(struct bt_le_ext_adv *adv,
-			 bool enable,
-			 const struct bt_le_ext_adv_start_param *param);
+int bt_le_adv_set_enable_ext(struct bt_le_ext_adv *adv, bool enable,
+			     const struct bt_le_ext_adv_start_param *param);
 int bt_le_adv_set_enable_legacy(struct bt_le_ext_adv *adv, bool enable);
 int bt_le_lim_adv_cancel_timeout(struct bt_le_ext_adv *adv);
 void bt_adv_reset_adv_pool(void);
diff --git a/subsys/bluetooth/host/aes_ccm.c b/subsys/bluetooth/host/aes_ccm.c
index 2e0022cf4eb..410b2021f88 100644
--- a/subsys/bluetooth/host/aes_ccm.c
+++ b/subsys/bluetooth/host/aes_ccm.c
@@ -39,8 +39,7 @@ static inline void xor16(uint8_t *dst, const uint8_t *a, const uint8_t *b)
 
 /* b field is assumed to have the nonce already present in bytes 1-13 */
 static int ccm_calculate_X0(const uint8_t key[16], const uint8_t *aad, uint8_t aad_len,
-			    size_t mic_size, uint16_t msg_len, uint8_t b[16],
-			    uint8_t X0[16])
+			    size_t mic_size, uint16_t msg_len, uint8_t b[16], uint8_t X0[16])
 {
 	int i, j, err;
 
@@ -96,9 +95,9 @@ static int ccm_calculate_X0(const uint8_t key[16], const uint8_t *aad, uint8_t a
 	return 0;
 }
 
-static int ccm_auth(const uint8_t key[16], uint8_t nonce[13],
-		    const uint8_t *cleartext_msg, uint16_t msg_len, const uint8_t *aad,
-		    size_t aad_len, uint8_t *mic, size_t mic_size)
+static int ccm_auth(const uint8_t key[16], uint8_t nonce[13], const uint8_t *cleartext_msg,
+		    uint16_t msg_len, const uint8_t *aad, size_t aad_len, uint8_t *mic,
+		    size_t mic_size)
 {
 	uint8_t b[16], Xn[16], s0[16];
 	uint16_t blk_cnt, last_blk;
@@ -149,8 +148,8 @@ static int ccm_auth(const uint8_t key[16], uint8_t nonce[13],
 	return 0;
 }
 
-static int ccm_crypt(const uint8_t key[16], const uint8_t nonce[13],
-		     const uint8_t *in_msg, uint8_t *out_msg, uint16_t msg_len)
+static int ccm_crypt(const uint8_t key[16], const uint8_t nonce[13], const uint8_t *in_msg,
+		     uint8_t *out_msg, uint16_t msg_len)
 {
 	uint8_t a_i[16], s_i[16];
 	uint16_t last_blk, blk_cnt;
@@ -180,17 +179,15 @@ static int ccm_crypt(const uint8_t key[16], const uint8_t nonce[13],
 			xor16(&out_msg[j * 16], s_i, &in_msg[j * 16]);
 		} else {
 			for (i = 0; i < last_blk; i++) {
-				out_msg[(j * 16) + i] =
-					in_msg[(j * 16) + i] ^ s_i[i];
+				out_msg[(j * 16) + i] = in_msg[(j * 16) + i] ^ s_i[i];
 			}
 		}
 	}
 	return 0;
 }
 
-int bt_ccm_decrypt(const uint8_t key[16], uint8_t nonce[13],
-		   const uint8_t *enc_data, size_t len, const uint8_t *aad,
-		   size_t aad_len, uint8_t *plaintext, size_t mic_size)
+int bt_ccm_decrypt(const uint8_t key[16], uint8_t nonce[13], const uint8_t *enc_data, size_t len,
+		   const uint8_t *aad, size_t aad_len, uint8_t *plaintext, size_t mic_size)
 {
 	uint8_t mic[16];
 
@@ -209,9 +206,8 @@ int bt_ccm_decrypt(const uint8_t key[16], uint8_t nonce[13],
 	return 0;
 }
 
-int bt_ccm_encrypt(const uint8_t key[16], uint8_t nonce[13],
-		   const uint8_t *plaintext, size_t len, const uint8_t *aad,
-		   size_t aad_len, uint8_t *enc_data, size_t mic_size)
+int bt_ccm_encrypt(const uint8_t key[16], uint8_t nonce[13], const uint8_t *plaintext, size_t len,
+		   const uint8_t *aad, size_t aad_len, uint8_t *enc_data, size_t mic_size)
 {
 	uint8_t *mic = enc_data + len;
 
diff --git a/subsys/bluetooth/host/att.c b/subsys/bluetooth/host/att.c
index 1fe44971397..7d2a55987d1 100644
--- a/subsys/bluetooth/host/att.c
+++ b/subsys/bluetooth/host/att.c
@@ -33,25 +33,25 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(bt_att);
 
-#define ATT_CHAN(_ch) CONTAINER_OF(_ch, struct bt_att_chan, chan.chan)
+#define ATT_CHAN(_ch)  CONTAINER_OF(_ch, struct bt_att_chan, chan.chan)
 #define ATT_REQ(_node) CONTAINER_OF(_node, struct bt_att_req, node)
 
-#define ATT_CMD_MASK				0x40
+#define ATT_CMD_MASK 0x40
 
 #if defined(CONFIG_BT_EATT)
-#define ATT_CHAN_MAX				(CONFIG_BT_EATT_MAX + 1)
+#define ATT_CHAN_MAX (CONFIG_BT_EATT_MAX + 1)
 #else
-#define ATT_CHAN_MAX				1
+#define ATT_CHAN_MAX 1
 #endif /* CONFIG_BT_EATT */
 
 typedef enum __packed {
-		ATT_COMMAND,
-		ATT_REQUEST,
-		ATT_RESPONSE,
-		ATT_NOTIFICATION,
-		ATT_CONFIRMATION,
-		ATT_INDICATION,
-		ATT_UNKNOWN,
+	ATT_COMMAND,
+	ATT_REQUEST,
+	ATT_RESPONSE,
+	ATT_NOTIFICATION,
+	ATT_CONFIRMATION,
+	ATT_INDICATION,
+	ATT_UNKNOWN,
 } att_type_t;
 
 static att_type_t att_op_get_type(uint8_t op);
@@ -67,8 +67,8 @@ NET_BUF_POOL_DEFINE(prep_pool, CONFIG_BT_ATT_PREPARE_COUNT, BT_ATT_BUF_SIZE,
 		    sizeof(struct bt_attr_data), NULL);
 #endif /* CONFIG_BT_ATT_PREPARE_COUNT */
 
-K_MEM_SLAB_DEFINE(req_slab, sizeof(struct bt_att_req),
-		  CONFIG_BT_ATT_TX_COUNT, __alignof__(struct bt_att_req));
+K_MEM_SLAB_DEFINE(req_slab, sizeof(struct bt_att_req), CONFIG_BT_ATT_TX_COUNT,
+		  __alignof__(struct bt_att_req));
 
 enum {
 	ATT_CONNECTED,
@@ -81,8 +81,7 @@ enum {
 };
 
 struct bt_att_tx_meta_data;
-typedef void (*bt_att_tx_cb_t)(struct bt_conn *conn,
-			       struct bt_att_tx_meta_data *user_data);
+typedef void (*bt_att_tx_cb_t)(struct bt_conn *conn, struct bt_att_tx_meta_data *user_data);
 
 struct bt_att_tx_meta_data {
 	int err;
@@ -101,13 +100,13 @@ struct bt_att_tx_meta {
 /* ATT channel specific data */
 struct bt_att_chan {
 	/* Connection this channel is associated with */
-	struct bt_att		*att;
-	struct bt_l2cap_le_chan	chan;
+	struct bt_att *att;
+	struct bt_l2cap_le_chan chan;
 	ATOMIC_DEFINE(flags, ATT_NUM_FLAGS);
-	struct bt_att_req	*req;
-	struct k_fifo		tx_queue;
-	struct k_work_delayable	timeout_work;
-	sys_snode_t		node;
+	struct bt_att_req *req;
+	struct k_fifo tx_queue;
+	struct k_work_delayable timeout_work;
+	sys_snode_t node;
 };
 
 static bool bt_att_is_enhanced(struct bt_att_chan *chan)
@@ -137,15 +136,15 @@ const static struct bt_gatt_authorization_cb *authorization_cb;
 
 /* ATT connection specific data */
 struct bt_att {
-	struct bt_conn		*conn;
+	struct bt_conn *conn;
 	/* Shared request queue */
-	sys_slist_t		reqs;
-	struct k_fifo		tx_queue;
+	sys_slist_t reqs;
+	struct k_fifo tx_queue;
 #if CONFIG_BT_ATT_PREPARE_COUNT > 0
-	sys_slist_t		prep_queue;
+	sys_slist_t prep_queue;
 #endif
 	/* Contains bt_att_chan instance(s) */
-	sys_slist_t		chans;
+	sys_slist_t chans;
 #if defined(CONFIG_BT_EATT)
 	struct {
 		struct k_work_delayable connection_work;
@@ -158,10 +157,8 @@ struct bt_att {
 #endif /* CONFIG_BT_EATT */
 };
 
-K_MEM_SLAB_DEFINE(att_slab, sizeof(struct bt_att),
-		  CONFIG_BT_MAX_CONN, __alignof__(struct bt_att));
-K_MEM_SLAB_DEFINE(chan_slab, sizeof(struct bt_att_chan),
-		  CONFIG_BT_MAX_CONN * ATT_CHAN_MAX,
+K_MEM_SLAB_DEFINE(att_slab, sizeof(struct bt_att), CONFIG_BT_MAX_CONN, __alignof__(struct bt_att));
+K_MEM_SLAB_DEFINE(chan_slab, sizeof(struct bt_att_chan), CONFIG_BT_MAX_CONN *ATT_CHAN_MAX,
 		  __alignof__(struct bt_att_chan));
 static struct bt_att_req cancel;
 
@@ -187,11 +184,11 @@ static void att_on_sent_cb(struct bt_att_tx_meta_data *meta);
 #if defined(CONFIG_BT_ATT_ERR_TO_STR)
 const char *bt_att_err_to_str(uint8_t att_err)
 {
-	/* To mapping tables are used to avoid a big gap with NULL-entries. */
-	#define ATT_ERR(err) [err] = #err
-	#define ATT_ERR_SECOND(err) [err - BT_ATT_ERR_WRITE_REQ_REJECTED] = #err
+/* To mapping tables are used to avoid a big gap with NULL-entries. */
+#define ATT_ERR(err)        [err] = #err
+#define ATT_ERR_SECOND(err) [err - BT_ATT_ERR_WRITE_REQ_REJECTED] = #err
 
-	const char * const first_mapping_table[] = {
+	const char *const first_mapping_table[] = {
 		ATT_ERR(BT_ATT_ERR_SUCCESS),
 		ATT_ERR(BT_ATT_ERR_INVALID_HANDLE),
 		ATT_ERR(BT_ATT_ERR_READ_NOT_PERMITTED),
@@ -214,14 +211,13 @@ const char *bt_att_err_to_str(uint8_t att_err)
 		ATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED),
 	};
 
-	const char * const second_mapping_table[] = {
+	const char *const second_mapping_table[] = {
 		ATT_ERR_SECOND(BT_ATT_ERR_WRITE_REQ_REJECTED),
 		ATT_ERR_SECOND(BT_ATT_ERR_CCC_IMPROPER_CONF),
 		ATT_ERR_SECOND(BT_ATT_ERR_PROCEDURE_IN_PROGRESS),
 		ATT_ERR_SECOND(BT_ATT_ERR_OUT_OF_RANGE),
 	};
 
-
 	if (att_err < ARRAY_SIZE(first_mapping_table) && first_mapping_table[att_err]) {
 		return first_mapping_table[att_err];
 	} else if (att_err >= BT_ATT_ERR_WRITE_REQ_REJECTED) {
@@ -235,8 +231,8 @@ const char *bt_att_err_to_str(uint8_t att_err)
 
 	return "(unknown)";
 
-	#undef ATT_ERR
-	#undef ATT_ERR_SECOND
+#undef ATT_ERR
+#undef ATT_ERR_SECOND
 }
 #endif /* CONFIG_BT_ATT_ERR_TO_STR */
 
@@ -272,8 +268,7 @@ static void att_tx_destroy(struct net_buf *buf)
 	}
 }
 
-NET_BUF_POOL_DEFINE(att_pool, CONFIG_BT_ATT_TX_COUNT,
-		    BT_L2CAP_SDU_BUF_SIZE(BT_ATT_BUF_SIZE),
+NET_BUF_POOL_DEFINE(att_pool, CONFIG_BT_ATT_TX_COUNT, BT_L2CAP_SDU_BUF_SIZE(BT_ATT_BUF_SIZE),
 		    CONFIG_BT_CONN_TX_USER_DATA_SIZE, att_tx_destroy);
 
 struct bt_att_tx_meta_data *bt_att_get_tx_meta_data(const struct net_buf *buf)
@@ -365,8 +360,7 @@ static int chan_send(struct bt_att_chan *chan, struct net_buf *buf)
 
 		/* Check if the channel is ready to send in case of a request */
 		if (att_op_get_type(hdr->code) == ATT_REQUEST &&
-		    !atomic_test_bit(chan->chan.chan.status,
-				     BT_L2CAP_STATUS_OUT)) {
+		    !atomic_test_bit(chan->chan.chan.status, BT_L2CAP_STATUS_OUT)) {
 			return -EAGAIN;
 		}
 
@@ -449,8 +443,7 @@ static struct net_buf *get_first_buf_matching_chan(struct k_fifo *fifo, struct b
 
 		while ((buf = k_fifo_get(fifo, K_NO_WAIT))) {
 			meta = bt_att_get_tx_meta_data(buf);
-			if (!ret &&
-			    att_chan_matches_chan_opt(chan, meta->chan_opt)) {
+			if (!ret && att_chan_matches_chan_opt(chan, meta->chan_opt)) {
 				ret = buf;
 			} else {
 				k_fifo_put(&skipped, buf);
@@ -649,9 +642,7 @@ static void att_on_sent_cb(struct bt_att_tx_meta_data *meta)
 
 	LOG_DBG("opcode 0x%x", meta->opcode);
 
-	if (!meta->att_chan ||
-	    !meta->att_chan->att ||
-	    !meta->att_chan->att->conn) {
+	if (!meta->att_chan || !meta->att_chan->att || !meta->att_chan->att->conn) {
 		LOG_DBG("Bearer not connected, dropping ATT cb");
 		return;
 	}
@@ -694,8 +685,7 @@ static struct net_buf *bt_att_chan_create_pdu(struct bt_att_chan *chan, uint8_t
 	k_timeout_t timeout;
 
 	if (len + sizeof(op) > bt_att_mtu(chan)) {
-		LOG_WRN("ATT MTU exceeded, max %u, wanted %zu", bt_att_mtu(chan),
-			len + sizeof(op));
+		LOG_WRN("ATT MTU exceeded, max %u, wanted %zu", bt_att_mtu(chan), len + sizeof(op));
 		return NULL;
 	}
 
@@ -782,8 +772,7 @@ static void bt_att_chan_send_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 	}
 }
 
-static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
-			 uint8_t err)
+static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle, uint8_t err)
 {
 	struct bt_att_error_rsp *rsp;
 	struct net_buf *buf;
@@ -868,8 +857,7 @@ static uint8_t att_mtu_req(struct bt_att_chan *chan, struct net_buf *buf)
 	return 0;
 }
 
-static int bt_att_chan_req_send(struct bt_att_chan *chan,
-				struct bt_att_req *req)
+static int bt_att_chan_req_send(struct bt_att_chan *chan, struct bt_att_req *req)
 {
 	__ASSERT_NO_MSG(chan);
 	__ASSERT_NO_MSG(req);
@@ -917,8 +905,7 @@ static void att_req_send_process(struct bt_att *att)
 	}
 }
 
-static uint8_t att_handle_rsp(struct bt_att_chan *chan, void *pdu, uint16_t len,
-			      int err)
+static uint8_t att_handle_rsp(struct bt_att_chan *chan, void *pdu, uint16_t len, int err)
 {
 	bt_att_func_t func = NULL;
 	void *params;
@@ -1024,8 +1011,7 @@ struct find_info_data {
 	};
 };
 
-static uint8_t find_info_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			    void *user_data)
+static uint8_t find_info_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct find_info_data *data = user_data;
 	struct bt_att_chan *chan = data->chan;
@@ -1035,8 +1021,8 @@ static uint8_t find_info_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	/* Initialize rsp at first entry */
 	if (!data->rsp) {
 		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
-		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
-				    BT_ATT_INFO_16 : BT_ATT_INFO_128;
+		data->rsp->format =
+			(attr->uuid->type == BT_UUID_TYPE_16) ? BT_ATT_INFO_16 : BT_ATT_INFO_128;
 	}
 
 	switch (data->rsp->format) {
@@ -1050,8 +1036,7 @@ static uint8_t find_info_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 		data->info16->handle = sys_cpu_to_le16(handle);
 		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
 
-		if (bt_att_mtu(chan) - data->buf->len >
-		    sizeof(*data->info16)) {
+		if (bt_att_mtu(chan) - data->buf->len > sizeof(*data->info16)) {
 			return BT_GATT_ITER_CONTINUE;
 		}
 
@@ -1067,8 +1052,7 @@ static uint8_t find_info_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
 		       sizeof(data->info128->uuid));
 
-		if (bt_att_mtu(chan) - data->buf->len >
-		    sizeof(*data->info128)) {
+		if (bt_att_mtu(chan) - data->buf->len > sizeof(*data->info128)) {
 			return BT_GATT_ITER_CONTINUE;
 		}
 	}
@@ -1077,7 +1061,7 @@ static uint8_t find_info_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 }
 
 static uint8_t att_find_info_rsp(struct bt_att_chan *chan, uint16_t start_handle,
-			      uint16_t end_handle)
+				 uint16_t end_handle)
 {
 	struct find_info_data data;
 
@@ -1117,8 +1101,7 @@ static uint8_t att_find_info_req(struct bt_att_chan *chan, struct net_buf *buf)
 	LOG_DBG("start_handle 0x%04x end_handle 0x%04x", start_handle, end_handle);
 
 	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
-		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, err_handle,
-			     BT_ATT_ERR_INVALID_HANDLE);
+		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, err_handle, BT_ATT_ERR_INVALID_HANDLE);
 		return 0;
 	}
 
@@ -1134,8 +1117,7 @@ struct find_type_data {
 	uint8_t err;
 };
 
-static uint8_t find_type_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			    void *user_data)
+static uint8_t find_type_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct find_type_data *data = user_data;
 	struct bt_att_chan *chan = data->chan;
@@ -1152,8 +1134,7 @@ static uint8_t find_type_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 
 	/* Update group end_handle if not a primary service */
 	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
-		if (data->group &&
-		    handle > sys_le16_to_cpu(data->group->end_handle)) {
+		if (data->group && handle > sys_le16_to_cpu(data->group->end_handle)) {
 			data->group->end_handle = sys_cpu_to_le16(handle);
 		}
 		return BT_GATT_ITER_CONTINUE;
@@ -1162,18 +1143,15 @@ static uint8_t find_type_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	LOG_DBG("handle 0x%04x", handle);
 
 	/* stop if there is no space left */
-	if (bt_att_mtu(chan) - net_buf_frags_len(data->buf) <
-	    sizeof(*data->group)) {
+	if (bt_att_mtu(chan) - net_buf_frags_len(data->buf) < sizeof(*data->group)) {
 		return BT_GATT_ITER_STOP;
 	}
 
 	frag = net_buf_frag_last(data->buf);
 
-	len = MIN(bt_att_mtu(chan) - net_buf_frags_len(data->buf),
-		  net_buf_tailroom(frag));
+	len = MIN(bt_att_mtu(chan) - net_buf_frags_len(data->buf), net_buf_tailroom(frag));
 	if (!len) {
-		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
-				     K_NO_WAIT);
+		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id), K_NO_WAIT);
 		/* If not buffer can be allocated immediately stop */
 		if (!frag) {
 			return BT_GATT_ITER_STOP;
@@ -1230,8 +1208,7 @@ skip:
 }
 
 static uint8_t att_find_type_rsp(struct bt_att_chan *chan, uint16_t start_handle,
-			      uint16_t end_handle, const void *value,
-			      uint8_t value_len)
+				 uint16_t end_handle, const void *value, uint8_t value_len)
 {
 	struct find_type_data data;
 
@@ -1256,8 +1233,7 @@ static uint8_t att_find_type_rsp(struct bt_att_chan *chan, uint16_t start_handle
 	if (data.err) {
 		net_buf_unref(data.buf);
 		/* Respond since handle is set */
-		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle,
-			     data.err);
+		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle, data.err);
 		return 0;
 	}
 
@@ -1282,8 +1258,7 @@ static uint8_t att_find_type_req(struct bt_att_chan *chan, struct net_buf *buf)
 	LOG_DBG("start_handle 0x%04x end_handle 0x%04x type %u", start_handle, end_handle, type);
 
 	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
-		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, err_handle,
-			     BT_ATT_ERR_INVALID_HANDLE);
+		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, err_handle, BT_ATT_ERR_INVALID_HANDLE);
 		return 0;
 	}
 
@@ -1298,8 +1273,7 @@ static uint8_t att_find_type_req(struct bt_att_chan *chan, struct net_buf *buf)
 		return 0;
 	}
 
-	return att_find_type_rsp(chan, start_handle, end_handle, value,
-				 buf->len);
+	return att_find_type_rsp(chan, start_handle, end_handle, value, buf->len);
 }
 
 static uint8_t err_to_att(int err)
@@ -1322,11 +1296,9 @@ struct read_type_data {
 	uint8_t err;
 };
 
-typedef bool (*attr_read_cb)(struct net_buf *buf, ssize_t read,
-			     void *user_data);
+typedef bool (*attr_read_cb)(struct net_buf *buf, ssize_t read, void *user_data);
 
-static bool attr_read_authorize(struct bt_conn *conn,
-				const struct bt_gatt_attr *attr)
+static bool attr_read_authorize(struct bt_conn *conn, const struct bt_gatt_attr *attr)
 {
 	if (!IS_ENABLED(CONFIG_BT_GATT_AUTHORIZATION_CUSTOM)) {
 		return true;
@@ -1339,8 +1311,7 @@ static bool attr_read_authorize(struct bt_conn *conn,
 	return authorization_cb->read_authorize(conn, attr);
 }
 
-static bool attr_read_type_cb(struct net_buf *frag, ssize_t read,
-			      void *user_data)
+static bool attr_read_type_cb(struct net_buf *frag, ssize_t read, void *user_data)
 {
 	struct read_type_data *data = user_data;
 
@@ -1357,10 +1328,8 @@ static bool attr_read_type_cb(struct net_buf *frag, ssize_t read,
 	return true;
 }
 
-static ssize_t att_chan_read(struct bt_att_chan *chan,
-			     const struct bt_gatt_attr *attr,
-			     struct net_buf *buf, uint16_t offset,
-			     attr_read_cb cb, void *user_data)
+static ssize_t att_chan_read(struct bt_att_chan *chan, const struct bt_gatt_attr *attr,
+			     struct net_buf *buf, uint16_t offset, attr_read_cb cb, void *user_data)
 {
 	struct bt_conn *conn = chan->chan.chan.conn;
 	ssize_t read;
@@ -1377,11 +1346,9 @@ static ssize_t att_chan_read(struct bt_att_chan *chan,
 	 * hold.
 	 */
 	do {
-		len = MIN(bt_att_mtu(chan) - net_buf_frags_len(buf),
-			  net_buf_tailroom(frag));
+		len = MIN(bt_att_mtu(chan) - net_buf_frags_len(buf), net_buf_tailroom(frag));
 		if (!len) {
-			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
-					     K_NO_WAIT);
+			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id), K_NO_WAIT);
 			/* If not buffer can be allocated immediately return */
 			if (!frag) {
 				return total;
@@ -1393,8 +1360,7 @@ static ssize_t att_chan_read(struct bt_att_chan *chan,
 				  net_buf_tailroom(frag));
 		}
 
-		read = attr->read(conn, attr, frag->data + frag->len, len,
-				  offset);
+		read = attr->read(conn, attr, frag->data + frag->len, len, offset);
 		if (read < 0) {
 			if (total) {
 				return total;
@@ -1415,8 +1381,7 @@ static ssize_t att_chan_read(struct bt_att_chan *chan,
 	return total;
 }
 
-static uint8_t read_type_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			    void *user_data)
+static uint8_t read_type_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct read_type_data *data = user_data;
 	struct bt_att_chan *chan = data->chan;
@@ -1461,8 +1426,7 @@ static uint8_t read_type_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	data->err = 0x00;
 
 	/* Fast forward to next item position */
-	data->item = net_buf_add(net_buf_frag_last(data->buf),
-				 sizeof(*data->item));
+	data->item = net_buf_add(net_buf_frag_last(data->buf), sizeof(*data->item));
 	data->item->handle = sys_cpu_to_le16(handle);
 
 	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
@@ -1476,12 +1440,13 @@ static uint8_t read_type_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	}
 
 	/* continue only if there are still space for more items */
-	return bt_att_mtu(chan) - net_buf_frags_len(data->buf) >
-	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
+	return bt_att_mtu(chan) - net_buf_frags_len(data->buf) > data->rsp->len
+		       ? BT_GATT_ITER_CONTINUE
+		       : BT_GATT_ITER_STOP;
 }
 
 static uint8_t att_read_type_rsp(struct bt_att_chan *chan, struct bt_uuid *uuid,
-			      uint16_t start_handle, uint16_t end_handle)
+				 uint16_t start_handle, uint16_t end_handle)
 {
 	struct read_type_data data;
 
@@ -1505,8 +1470,7 @@ static uint8_t att_read_type_rsp(struct bt_att_chan *chan, struct bt_uuid *uuid,
 	if (data.err) {
 		net_buf_unref(data.buf);
 		/* Response here since handle is set */
-		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, start_handle,
-			     data.err);
+		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, start_handle, data.err);
 		return 0;
 	}
 
@@ -1543,8 +1507,7 @@ static uint8_t att_read_type_req(struct bt_att_chan *chan, struct net_buf *buf)
 		bt_uuid_str(&u.uuid));
 
 	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
-		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, err_handle,
-			     BT_ATT_ERR_INVALID_HANDLE);
+		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, err_handle, BT_ATT_ERR_INVALID_HANDLE);
 		return 0;
 	}
 
@@ -1582,8 +1545,7 @@ struct read_data {
 	uint8_t err;
 };
 
-static uint8_t read_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-		       void *user_data)
+static uint8_t read_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct read_data *data = user_data;
 	struct bt_att_chan *chan = data->chan;
@@ -1620,8 +1582,8 @@ static uint8_t read_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	return BT_GATT_ITER_CONTINUE;
 }
 
-static uint8_t att_read_rsp(struct bt_att_chan *chan, uint8_t op, uint8_t rsp,
-			 uint16_t handle, uint16_t offset)
+static uint8_t att_read_rsp(struct bt_att_chan *chan, uint8_t op, uint8_t rsp, uint16_t handle,
+			    uint16_t offset)
 {
 	struct read_data data;
 
@@ -1676,8 +1638,7 @@ static uint8_t att_read_req(struct bt_att_chan *chan, struct net_buf *buf)
 
 	LOG_DBG("handle 0x%04x", handle);
 
-	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
-			    handle, 0);
+	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP, handle, 0);
 }
 
 static uint8_t att_read_blob_req(struct bt_att_chan *chan, struct net_buf *buf)
@@ -1692,8 +1653,7 @@ static uint8_t att_read_blob_req(struct bt_att_chan *chan, struct net_buf *buf)
 
 	LOG_DBG("handle 0x%04x offset %u", handle, offset);
 
-	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
-			    BT_ATT_OP_READ_BLOB_RSP, handle, offset);
+	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ, BT_ATT_OP_READ_BLOB_RSP, handle, offset);
 }
 
 #if defined(CONFIG_BT_GATT_READ_MULTIPLE)
@@ -1739,8 +1699,7 @@ static uint8_t att_read_mult_req(struct bt_att_chan *chan, struct net_buf *buf)
 		if (data.err) {
 			net_buf_unref(data.buf);
 			/* Respond here since handle is set */
-			send_err_rsp(chan, BT_ATT_OP_READ_MULT_REQ, handle,
-				     data.err);
+			send_err_rsp(chan, BT_ATT_OP_READ_MULT_REQ, handle, data.err);
 			return 0;
 		}
 	}
@@ -1752,8 +1711,7 @@ static uint8_t att_read_mult_req(struct bt_att_chan *chan, struct net_buf *buf)
 #endif /* CONFIG_BT_GATT_READ_MULTIPLE */
 
 #if defined(CONFIG_BT_GATT_READ_MULT_VAR_LEN)
-static uint8_t read_vl_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t read_vl_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct read_data *data = user_data;
 	struct bt_att_chan *chan = data->chan;
@@ -1839,8 +1797,7 @@ static uint8_t att_read_mult_vl_req(struct bt_att_chan *chan, struct net_buf *bu
 		if (data.err) {
 			net_buf_unref(data.buf);
 			/* Respond here since handle is set */
-			send_err_rsp(chan, BT_ATT_OP_READ_MULT_VL_REQ, handle,
-				     data.err);
+			send_err_rsp(chan, BT_ATT_OP_READ_MULT_VL_REQ, handle, data.err);
 			return 0;
 		}
 	}
@@ -1859,8 +1816,7 @@ struct read_group_data {
 	struct bt_att_group_data *group;
 };
 
-static bool attr_read_group_cb(struct net_buf *frag, ssize_t read,
-			       void *user_data)
+static bool attr_read_group_cb(struct net_buf *frag, ssize_t read, void *user_data)
 {
 	struct read_group_data *data = user_data;
 
@@ -1877,8 +1833,7 @@ static bool attr_read_group_cb(struct net_buf *frag, ssize_t read,
 	return true;
 }
 
-static uint8_t read_group_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			     void *user_data)
+static uint8_t read_group_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct read_group_data *data = user_data;
 	struct bt_att_chan *chan = data->chan;
@@ -1887,8 +1842,7 @@ static uint8_t read_group_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	/* Update group end_handle if attribute is not a service */
 	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
 	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
-		if (data->group &&
-		    handle > sys_le16_to_cpu(data->group->end_handle)) {
+		if (data->group && handle > sys_le16_to_cpu(data->group->end_handle)) {
 			data->group->end_handle = sys_cpu_to_le16(handle);
 		}
 		return BT_GATT_ITER_CONTINUE;
@@ -1903,8 +1857,7 @@ static uint8_t read_group_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	LOG_DBG("handle 0x%04x", handle);
 
 	/* Stop if there is no space left */
-	if (data->rsp->len &&
-	    bt_att_mtu(chan) - data->buf->len < data->rsp->len) {
+	if (data->rsp->len && bt_att_mtu(chan) - data->buf->len < data->rsp->len) {
 		return BT_GATT_ITER_STOP;
 	}
 
@@ -1916,8 +1869,7 @@ static uint8_t read_group_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	data->group->end_handle = sys_cpu_to_le16(handle);
 
 	/* Read attribute value and store in the buffer */
-	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
-			     data);
+	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb, data);
 	if (read < 0) {
 		/* TODO: Handle read errors */
 		return BT_GATT_ITER_STOP;
@@ -1932,7 +1884,7 @@ static uint8_t read_group_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 }
 
 static uint8_t att_read_group_rsp(struct bt_att_chan *chan, struct bt_uuid *uuid,
-			       uint16_t start_handle, uint16_t end_handle)
+				  uint16_t start_handle, uint16_t end_handle)
 {
 	struct read_group_data data;
 
@@ -1993,8 +1945,7 @@ static uint8_t att_read_group_req(struct bt_att_chan *chan, struct net_buf *buf)
 		bt_uuid_str(&u.uuid));
 
 	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
-		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, err_handle,
-			     BT_ATT_ERR_INVALID_HANDLE);
+		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, err_handle, BT_ATT_ERR_INVALID_HANDLE);
 		return 0;
 	}
 
@@ -2025,8 +1976,7 @@ struct write_data {
 	uint8_t err;
 };
 
-static bool attr_write_authorize(struct bt_conn *conn,
-				 const struct bt_gatt_attr *attr)
+static bool attr_write_authorize(struct bt_conn *conn, const struct bt_gatt_attr *attr)
 {
 	if (!IS_ENABLED(CONFIG_BT_GATT_AUTHORIZATION_CUSTOM)) {
 		return true;
@@ -2039,8 +1989,7 @@ static bool attr_write_authorize(struct bt_conn *conn,
 	return authorization_cb->write_authorize(conn, attr);
 }
 
-static uint8_t write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			void *user_data)
+static uint8_t write_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct write_data *data = user_data;
 	int write;
@@ -2049,8 +1998,7 @@ static uint8_t write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	LOG_DBG("handle 0x%04x offset %u", handle, data->offset);
 
 	/* Check attribute permissions */
-	data->err = bt_gatt_check_perm(data->conn, attr,
-				       BT_GATT_PERM_WRITE_MASK);
+	data->err = bt_gatt_check_perm(data->conn, attr, BT_GATT_PERM_WRITE_MASK);
 	if (data->err) {
 		return BT_GATT_ITER_STOP;
 	}
@@ -2069,8 +2017,7 @@ static uint8_t write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	}
 
 	/* Write attribute value */
-	write = attr->write(data->conn, attr, data->value, data->len,
-			    data->offset, flags);
+	write = attr->write(data->conn, attr, data->value, data->len, data->offset, flags);
 	if (write < 0 || write != data->len) {
 		data->err = err_to_att(write);
 		return BT_GATT_ITER_STOP;
@@ -2081,9 +2028,8 @@ static uint8_t write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	return BT_GATT_ITER_CONTINUE;
 }
 
-static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
-			  uint16_t handle, uint16_t offset, const void *value,
-			  uint16_t len)
+static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp, uint16_t handle,
+			     uint16_t offset, const void *value, uint16_t len)
 {
 	struct write_data data;
 
@@ -2143,8 +2089,8 @@ static uint8_t att_write_req(struct bt_att_chan *chan, struct net_buf *buf)
 
 	LOG_DBG("handle 0x%04x", handle);
 
-	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
-			     handle, 0, buf->data, buf->len);
+	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP, handle, 0, buf->data,
+			     buf->len);
 }
 
 #if CONFIG_BT_ATT_PREPARE_COUNT > 0
@@ -2157,8 +2103,7 @@ struct prep_data {
 	uint8_t err;
 };
 
-static uint8_t prep_write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			     void *user_data)
+static uint8_t prep_write_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct prep_data *data = user_data;
 	struct bt_attr_data *attr_data;
@@ -2167,8 +2112,7 @@ static uint8_t prep_write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	LOG_DBG("handle 0x%04x offset %u", handle, data->offset);
 
 	/* Check attribute permissions */
-	data->err = bt_gatt_check_perm(data->conn, attr,
-				       BT_GATT_PERM_WRITE_MASK);
+	data->err = bt_gatt_check_perm(data->conn, attr, BT_GATT_PERM_WRITE_MASK);
 	if (data->err) {
 		return BT_GATT_ITER_STOP;
 	}
@@ -2185,8 +2129,8 @@ static uint8_t prep_write_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	}
 
 	/* Write attribute value to check if device is authorized */
-	write = attr->write(data->conn, attr, data->value, data->len,
-			    data->offset, BT_GATT_WRITE_FLAG_PREPARE);
+	write = attr->write(data->conn, attr, data->value, data->len, data->offset,
+			    BT_GATT_WRITE_FLAG_PREPARE);
 	if (write != 0) {
 		data->err = err_to_att(write);
 		return BT_GATT_ITER_STOP;
@@ -2211,8 +2155,8 @@ append:
 	return BT_GATT_ITER_CONTINUE;
 }
 
-static uint8_t att_prep_write_rsp(struct bt_att_chan *chan, uint16_t handle,
-			       uint16_t offset, const void *value, uint8_t len)
+static uint8_t att_prep_write_rsp(struct bt_att_chan *chan, uint16_t handle, uint16_t offset,
+				  const void *value, uint8_t len)
 {
 	struct prep_data data;
 	struct bt_att_prepare_write_rsp *rsp;
@@ -2241,8 +2185,7 @@ static uint8_t att_prep_write_rsp(struct bt_att_chan *chan, uint16_t handle,
 
 	if (data.err) {
 		/* Respond here since handle is set */
-		send_err_rsp(chan, BT_ATT_OP_PREPARE_WRITE_REQ, handle,
-			     data.err);
+		send_err_rsp(chan, BT_ATT_OP_PREPARE_WRITE_REQ, handle, data.err);
 		return 0;
 	}
 
@@ -2289,8 +2232,7 @@ static uint8_t att_prepare_write_req(struct bt_att_chan *chan, struct net_buf *b
 }
 
 #if CONFIG_BT_ATT_PREPARE_COUNT > 0
-static uint8_t exec_write_reassemble(uint16_t handle, uint16_t offset,
-				     sys_slist_t *list,
+static uint8_t exec_write_reassemble(uint16_t handle, uint16_t offset, sys_slist_t *list,
 				     struct net_buf_simple *buf)
 {
 	struct net_buf *entry, *next;
@@ -2369,25 +2311,20 @@ static uint8_t att_exec_write_rsp(struct bt_att_chan *chan, uint8_t flags)
 		net_buf_simple_reset(&reassembled_data);
 		net_buf_simple_add_mem(&reassembled_data, buf->data, buf->len);
 
-		err = exec_write_reassemble(handle, data->offset,
-					    &chan->att->prep_queue,
+		err = exec_write_reassemble(handle, data->offset, &chan->att->prep_queue,
 					    &reassembled_data);
 		if (err != BT_ATT_ERR_SUCCESS) {
-			send_err_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ,
-				     handle, err);
+			send_err_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ, handle, err);
 			return 0;
 		}
 
 		/* Just discard the data if an error was set */
 		if (!err && flags == BT_ATT_FLAG_EXEC) {
-			err = att_write_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ, 0,
-					    handle, data->offset,
-					    reassembled_data.data,
-					    reassembled_data.len);
+			err = att_write_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ, 0, handle, data->offset,
+					    reassembled_data.data, reassembled_data.len);
 			if (err) {
 				/* Respond here since handle is set */
-				send_err_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ,
-					     data->handle, err);
+				send_err_rsp(chan, BT_ATT_OP_EXEC_WRITE_REQ, data->handle, err);
 			}
 		}
 
@@ -2410,7 +2347,6 @@ static uint8_t att_exec_write_rsp(struct bt_att_chan *chan, uint8_t flags)
 }
 #endif /* CONFIG_BT_ATT_PREPARE_COUNT */
 
-
 static uint8_t att_exec_write_req(struct bt_att_chan *chan, struct net_buf *buf)
 {
 #if CONFIG_BT_ATT_PREPARE_COUNT == 0
@@ -2589,40 +2525,35 @@ done:
 	return att_handle_rsp(chan, NULL, 0, err);
 }
 
-static uint8_t att_handle_find_info_rsp(struct bt_att_chan *chan,
-				     struct net_buf *buf)
+static uint8_t att_handle_find_info_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_find_type_rsp(struct bt_att_chan *chan,
-				     struct net_buf *buf)
+static uint8_t att_handle_find_type_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_read_type_rsp(struct bt_att_chan *chan,
-				     struct net_buf *buf)
+static uint8_t att_handle_read_type_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_read_rsp(struct bt_att_chan *chan,
-				struct net_buf *buf)
+static uint8_t att_handle_read_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_read_blob_rsp(struct bt_att_chan *chan,
-				     struct net_buf *buf)
+static uint8_t att_handle_read_blob_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
@@ -2630,8 +2561,7 @@ static uint8_t att_handle_read_blob_rsp(struct bt_att_chan *chan,
 }
 
 #if defined(CONFIG_BT_GATT_READ_MULTIPLE)
-static uint8_t att_handle_read_mult_rsp(struct bt_att_chan *chan,
-				     struct net_buf *buf)
+static uint8_t att_handle_read_mult_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
@@ -2641,8 +2571,7 @@ static uint8_t att_handle_read_mult_rsp(struct bt_att_chan *chan,
 #endif /* CONFIG_BT_GATT_READ_MULTIPLE */
 
 #if defined(CONFIG_BT_GATT_READ_MULT_VAR_LEN)
-static uint8_t att_handle_read_mult_vl_rsp(struct bt_att_chan *chan,
-					struct net_buf *buf)
+static uint8_t att_handle_read_mult_vl_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
@@ -2650,32 +2579,28 @@ static uint8_t att_handle_read_mult_vl_rsp(struct bt_att_chan *chan,
 }
 #endif /* CONFIG_BT_GATT_READ_MULT_VAR_LEN */
 
-static uint8_t att_handle_read_group_rsp(struct bt_att_chan *chan,
-				      struct net_buf *buf)
+static uint8_t att_handle_read_group_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_write_rsp(struct bt_att_chan *chan,
-				 struct net_buf *buf)
+static uint8_t att_handle_write_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_prepare_write_rsp(struct bt_att_chan *chan,
-					 struct net_buf *buf)
+static uint8_t att_handle_prepare_write_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
 	return att_handle_rsp(chan, buf->data, buf->len, 0);
 }
 
-static uint8_t att_handle_exec_write_rsp(struct bt_att_chan *chan,
-				      struct net_buf *buf)
+static uint8_t att_handle_exec_write_rsp(struct bt_att_chan *chan, struct net_buf *buf)
 {
 	LOG_DBG("");
 
@@ -2733,147 +2658,70 @@ static uint8_t att_confirm(struct bt_att_chan *chan, struct net_buf *buf)
 }
 
 static const struct att_handler {
-	uint8_t       op;
-	uint8_t       expect_len;
+	uint8_t op;
+	uint8_t expect_len;
 	att_type_t type;
-	uint8_t       (*func)(struct bt_att_chan *chan, struct net_buf *buf);
+	uint8_t (*func)(struct bt_att_chan *chan, struct net_buf *buf);
 } handlers[] = {
-	{ BT_ATT_OP_MTU_REQ,
-		sizeof(struct bt_att_exchange_mtu_req),
-		ATT_REQUEST,
-		att_mtu_req },
-	{ BT_ATT_OP_FIND_INFO_REQ,
-		sizeof(struct bt_att_find_info_req),
-		ATT_REQUEST,
-		att_find_info_req },
-	{ BT_ATT_OP_FIND_TYPE_REQ,
-		sizeof(struct bt_att_find_type_req),
-		ATT_REQUEST,
-		att_find_type_req },
-	{ BT_ATT_OP_READ_TYPE_REQ,
-		sizeof(struct bt_att_read_type_req),
-		ATT_REQUEST,
-		att_read_type_req },
-	{ BT_ATT_OP_READ_REQ,
-		sizeof(struct bt_att_read_req),
-		ATT_REQUEST,
-		att_read_req },
-	{ BT_ATT_OP_READ_BLOB_REQ,
-		sizeof(struct bt_att_read_blob_req),
-		ATT_REQUEST,
-		att_read_blob_req },
+	{BT_ATT_OP_MTU_REQ, sizeof(struct bt_att_exchange_mtu_req), ATT_REQUEST, att_mtu_req},
+	{BT_ATT_OP_FIND_INFO_REQ, sizeof(struct bt_att_find_info_req), ATT_REQUEST,
+	 att_find_info_req},
+	{BT_ATT_OP_FIND_TYPE_REQ, sizeof(struct bt_att_find_type_req), ATT_REQUEST,
+	 att_find_type_req},
+	{BT_ATT_OP_READ_TYPE_REQ, sizeof(struct bt_att_read_type_req), ATT_REQUEST,
+	 att_read_type_req},
+	{BT_ATT_OP_READ_REQ, sizeof(struct bt_att_read_req), ATT_REQUEST, att_read_req},
+	{BT_ATT_OP_READ_BLOB_REQ, sizeof(struct bt_att_read_blob_req), ATT_REQUEST,
+	 att_read_blob_req},
 #if defined(CONFIG_BT_GATT_READ_MULTIPLE)
-	{ BT_ATT_OP_READ_MULT_REQ,
-		BT_ATT_READ_MULT_MIN_LEN_REQ,
-		ATT_REQUEST,
-		att_read_mult_req },
+	{BT_ATT_OP_READ_MULT_REQ, BT_ATT_READ_MULT_MIN_LEN_REQ, ATT_REQUEST, att_read_mult_req},
 #endif /* CONFIG_BT_GATT_READ_MULTIPLE */
 #if defined(CONFIG_BT_GATT_READ_MULT_VAR_LEN)
-	{ BT_ATT_OP_READ_MULT_VL_REQ,
-		BT_ATT_READ_MULT_MIN_LEN_REQ,
-		ATT_REQUEST,
-		att_read_mult_vl_req },
+	{BT_ATT_OP_READ_MULT_VL_REQ, BT_ATT_READ_MULT_MIN_LEN_REQ, ATT_REQUEST,
+	 att_read_mult_vl_req},
 #endif /* CONFIG_BT_GATT_READ_MULT_VAR_LEN */
-	{ BT_ATT_OP_READ_GROUP_REQ,
-		sizeof(struct bt_att_read_group_req),
-		ATT_REQUEST,
-		att_read_group_req },
-	{ BT_ATT_OP_WRITE_REQ,
-		sizeof(struct bt_att_write_req),
-		ATT_REQUEST,
-		att_write_req },
-	{ BT_ATT_OP_PREPARE_WRITE_REQ,
-		sizeof(struct bt_att_prepare_write_req),
-		ATT_REQUEST,
-		att_prepare_write_req },
-	{ BT_ATT_OP_EXEC_WRITE_REQ,
-		sizeof(struct bt_att_exec_write_req),
-		ATT_REQUEST,
-		att_exec_write_req },
-	{ BT_ATT_OP_CONFIRM,
-		0,
-		ATT_CONFIRMATION,
-		att_confirm },
-	{ BT_ATT_OP_WRITE_CMD,
-		sizeof(struct bt_att_write_cmd),
-		ATT_COMMAND,
-		att_write_cmd },
+	{BT_ATT_OP_READ_GROUP_REQ, sizeof(struct bt_att_read_group_req), ATT_REQUEST,
+	 att_read_group_req},
+	{BT_ATT_OP_WRITE_REQ, sizeof(struct bt_att_write_req), ATT_REQUEST, att_write_req},
+	{BT_ATT_OP_PREPARE_WRITE_REQ, sizeof(struct bt_att_prepare_write_req), ATT_REQUEST,
+	 att_prepare_write_req},
+	{BT_ATT_OP_EXEC_WRITE_REQ, sizeof(struct bt_att_exec_write_req), ATT_REQUEST,
+	 att_exec_write_req},
+	{BT_ATT_OP_CONFIRM, 0, ATT_CONFIRMATION, att_confirm},
+	{BT_ATT_OP_WRITE_CMD, sizeof(struct bt_att_write_cmd), ATT_COMMAND, att_write_cmd},
 #if defined(CONFIG_BT_SIGNING)
-	{ BT_ATT_OP_SIGNED_WRITE_CMD,
-		(sizeof(struct bt_att_write_cmd) +
-		 sizeof(struct bt_att_signature)),
-		ATT_COMMAND,
-		att_signed_write_cmd },
+	{BT_ATT_OP_SIGNED_WRITE_CMD,
+	 (sizeof(struct bt_att_write_cmd) + sizeof(struct bt_att_signature)), ATT_COMMAND,
+	 att_signed_write_cmd},
 #endif /* CONFIG_BT_SIGNING */
 #if defined(CONFIG_BT_GATT_CLIENT)
-	{ BT_ATT_OP_ERROR_RSP,
-		sizeof(struct bt_att_error_rsp),
-		ATT_RESPONSE,
-		att_error_rsp },
-	{ BT_ATT_OP_MTU_RSP,
-		sizeof(struct bt_att_exchange_mtu_rsp),
-		ATT_RESPONSE,
-		att_mtu_rsp },
-	{ BT_ATT_OP_FIND_INFO_RSP,
-		sizeof(struct bt_att_find_info_rsp),
-		ATT_RESPONSE,
-		att_handle_find_info_rsp },
-	{ BT_ATT_OP_FIND_TYPE_RSP,
-		sizeof(struct bt_att_handle_group),
-		ATT_RESPONSE,
-		att_handle_find_type_rsp },
-	{ BT_ATT_OP_READ_TYPE_RSP,
-		sizeof(struct bt_att_read_type_rsp),
-		ATT_RESPONSE,
-		att_handle_read_type_rsp },
-	{ BT_ATT_OP_READ_RSP,
-		0,
-		ATT_RESPONSE,
-		att_handle_read_rsp },
-	{ BT_ATT_OP_READ_BLOB_RSP,
-		0,
-		ATT_RESPONSE,
-		att_handle_read_blob_rsp },
+	{BT_ATT_OP_ERROR_RSP, sizeof(struct bt_att_error_rsp), ATT_RESPONSE, att_error_rsp},
+	{BT_ATT_OP_MTU_RSP, sizeof(struct bt_att_exchange_mtu_rsp), ATT_RESPONSE, att_mtu_rsp},
+	{BT_ATT_OP_FIND_INFO_RSP, sizeof(struct bt_att_find_info_rsp), ATT_RESPONSE,
+	 att_handle_find_info_rsp},
+	{BT_ATT_OP_FIND_TYPE_RSP, sizeof(struct bt_att_handle_group), ATT_RESPONSE,
+	 att_handle_find_type_rsp},
+	{BT_ATT_OP_READ_TYPE_RSP, sizeof(struct bt_att_read_type_rsp), ATT_RESPONSE,
+	 att_handle_read_type_rsp},
+	{BT_ATT_OP_READ_RSP, 0, ATT_RESPONSE, att_handle_read_rsp},
+	{BT_ATT_OP_READ_BLOB_RSP, 0, ATT_RESPONSE, att_handle_read_blob_rsp},
 #if defined(CONFIG_BT_GATT_READ_MULTIPLE)
-	{ BT_ATT_OP_READ_MULT_RSP,
-		0,
-		ATT_RESPONSE,
-		att_handle_read_mult_rsp },
+	{BT_ATT_OP_READ_MULT_RSP, 0, ATT_RESPONSE, att_handle_read_mult_rsp},
 #endif /* CONFIG_BT_GATT_READ_MULTIPLE */
 #if defined(CONFIG_BT_GATT_READ_MULT_VAR_LEN)
-	{ BT_ATT_OP_READ_MULT_VL_RSP,
-		sizeof(struct bt_att_read_mult_vl_rsp),
-		ATT_RESPONSE,
-		att_handle_read_mult_vl_rsp },
+	{BT_ATT_OP_READ_MULT_VL_RSP, sizeof(struct bt_att_read_mult_vl_rsp), ATT_RESPONSE,
+	 att_handle_read_mult_vl_rsp},
 #endif /* CONFIG_BT_GATT_READ_MULT_VAR_LEN */
-	{ BT_ATT_OP_READ_GROUP_RSP,
-		sizeof(struct bt_att_read_group_rsp),
-		ATT_RESPONSE,
-		att_handle_read_group_rsp },
-	{ BT_ATT_OP_WRITE_RSP,
-		0,
-		ATT_RESPONSE,
-		att_handle_write_rsp },
-	{ BT_ATT_OP_PREPARE_WRITE_RSP,
-		sizeof(struct bt_att_prepare_write_rsp),
-		ATT_RESPONSE,
-		att_handle_prepare_write_rsp },
-	{ BT_ATT_OP_EXEC_WRITE_RSP,
-		0,
-		ATT_RESPONSE,
-		att_handle_exec_write_rsp },
-	{ BT_ATT_OP_NOTIFY,
-		sizeof(struct bt_att_notify),
-		ATT_NOTIFICATION,
-		att_notify },
-	{ BT_ATT_OP_INDICATE,
-		sizeof(struct bt_att_indicate),
-		ATT_INDICATION,
-		att_indicate },
-	{ BT_ATT_OP_NOTIFY_MULT,
-		sizeof(struct bt_att_notify_mult),
-		ATT_NOTIFICATION,
-		att_notify_mult },
+	{BT_ATT_OP_READ_GROUP_RSP, sizeof(struct bt_att_read_group_rsp), ATT_RESPONSE,
+	 att_handle_read_group_rsp},
+	{BT_ATT_OP_WRITE_RSP, 0, ATT_RESPONSE, att_handle_write_rsp},
+	{BT_ATT_OP_PREPARE_WRITE_RSP, sizeof(struct bt_att_prepare_write_rsp), ATT_RESPONSE,
+	 att_handle_prepare_write_rsp},
+	{BT_ATT_OP_EXEC_WRITE_RSP, 0, ATT_RESPONSE, att_handle_exec_write_rsp},
+	{BT_ATT_OP_NOTIFY, sizeof(struct bt_att_notify), ATT_NOTIFICATION, att_notify},
+	{BT_ATT_OP_INDICATE, sizeof(struct bt_att_indicate), ATT_INDICATION, att_indicate},
+	{BT_ATT_OP_NOTIFY_MULT, sizeof(struct bt_att_notify_mult), ATT_NOTIFICATION,
+	 att_notify_mult},
 #endif /* CONFIG_BT_GATT_CLIENT */
 };
 
@@ -2970,8 +2818,7 @@ static int bt_att_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 		LOG_WRN("Unhandled ATT code 0x%02x", hdr->code);
 		if (att_op_get_type(hdr->code) != ATT_COMMAND &&
 		    att_op_get_type(hdr->code) != ATT_INDICATION) {
-			send_err_rsp(att_chan, hdr->code, 0,
-				     BT_ATT_ERR_NOT_SUPPORTED);
+			send_err_rsp(att_chan, hdr->code, 0, BT_ATT_ERR_NOT_SUPPORTED);
 		}
 		return 0;
 	}
@@ -3099,8 +2946,7 @@ static void att_reset(struct bt_att *att)
 		node = sys_slist_get_not_empty(&att->reqs);
 		req = CONTAINER_OF(node, struct bt_att_req, node);
 		if (req->func) {
-			req->func(att->conn, -ECONNRESET, NULL, 0,
-				  req->user_data);
+			req->func(att->conn, -ECONNRESET, NULL, 0, req->user_data);
 		}
 
 		bt_att_req_free(req);
@@ -3139,8 +2985,7 @@ static void att_timeout(struct k_work *work)
 {
 	char addr[BT_ADDR_LE_STR_LEN];
 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
-	struct bt_att_chan *chan = CONTAINER_OF(dwork, struct bt_att_chan,
-						timeout_work);
+	struct bt_att_chan *chan = CONTAINER_OF(dwork, struct bt_att_chan, timeout_work);
 	int err;
 
 	bt_addr_le_to_str(bt_conn_get_dst(chan->att->conn), addr, sizeof(addr));
@@ -3245,7 +3090,6 @@ static uint8_t att_req_retry(struct bt_att_chan *att_chan)
 		return BT_ATT_ERR_AUTHENTICATION;
 	}
 
-
 	buf = bt_att_chan_create_pdu(att_chan, req->att_op, req->len);
 	if (!buf) {
 		return BT_ATT_ERR_UNLIKELY;
@@ -3264,8 +3108,7 @@ static uint8_t att_req_retry(struct bt_att_chan *att_chan)
 	return BT_ATT_ERR_SUCCESS;
 }
 
-static void bt_att_encrypt_change(struct bt_l2cap_chan *chan,
-				  uint8_t hci_status)
+static void bt_att_encrypt_change(struct bt_l2cap_chan *chan, uint8_t hci_status)
 {
 	struct bt_att_chan *att_chan = ATT_CHAN(chan);
 	struct bt_l2cap_le_chan *le_chan = BT_L2CAP_LE_CHAN(chan);
@@ -3286,8 +3129,7 @@ static void bt_att_encrypt_change(struct bt_l2cap_chan *chan,
 	 */
 	if (hci_status) {
 		if (att_chan->req && att_chan->req->retrying) {
-			att_handle_rsp(att_chan, NULL, 0,
-				       BT_ATT_ERR_AUTHENTICATION);
+			att_handle_rsp(att_chan, NULL, 0, BT_ATT_ERR_AUTHENTICATION);
 		}
 
 		return;
@@ -3377,13 +3219,13 @@ static struct bt_att_chan *att_chan_new(struct bt_att *att, atomic_val_t flags)
 		.recv = bt_att_recv,
 		.sent = bt_att_sent,
 		.status = bt_att_status,
-	#if defined(CONFIG_BT_SMP)
+#if defined(CONFIG_BT_SMP)
 		.encrypt_change = bt_att_encrypt_change,
-	#endif /* CONFIG_BT_SMP */
+#endif /* CONFIG_BT_SMP */
 		.released = bt_att_released,
-	#if defined(CONFIG_BT_EATT)
+#if defined(CONFIG_BT_EATT)
 		.reconfigured = bt_att_reconfigured,
-	#endif /* CONFIG_BT_EATT */
+#endif /* CONFIG_BT_EATT */
 	};
 	struct bt_att_chan *chan;
 
@@ -3444,8 +3286,7 @@ size_t bt_eatt_count(struct bt_conn *conn)
 	}
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
-		if (bt_att_is_enhanced(chan) &&
-		    atomic_test_bit(chan->flags, ATT_CONNECTED)) {
+		if (bt_att_is_enhanced(chan) && atomic_test_bit(chan->flags, ATT_CONNECTED)) {
 			eatt_count++;
 		}
 	}
@@ -3461,13 +3302,12 @@ static void att_enhanced_connection_work_handler(struct k_work *work)
 
 	if (err == -ENOMEM) {
 		LOG_DBG("Failed to connect %d EATT channels, central has probably "
-		       "already established some.",
-		       att->eatt.chans_to_connect);
+			"already established some.",
+			att->eatt.chans_to_connect);
 	} else if (err < 0) {
 		LOG_WRN("Failed to connect %d EATT channels (err: %d)", att->eatt.chans_to_connect,
 			err);
 	}
-
 }
 #endif /* CONFIG_BT_EATT */
 
@@ -3491,8 +3331,7 @@ static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
 	sys_slist_init(&att->chans);
 
 #if defined(CONFIG_BT_EATT)
-	k_work_init_delayable(&att->eatt.connection_work,
-			      att_enhanced_connection_work_handler);
+	k_work_init_delayable(&att->eatt.connection_work, att_enhanced_connection_work_handler);
 #endif /* CONFIG_BT_EATT */
 
 	chan = att_chan_new(att, 0);
@@ -3561,8 +3400,7 @@ static int att_schedule_eatt_connect(struct bt_conn *conn, uint8_t chans_to_conn
 
 	att->eatt.chans_to_connect = chans_to_connect;
 
-	return k_work_reschedule(&att->eatt.connection_work,
-				 credit_based_connection_delay(conn));
+	return k_work_reschedule(&att->eatt.connection_work, credit_based_connection_delay(conn));
 }
 
 static void handle_potential_collision(struct bt_att *att)
@@ -3626,8 +3464,7 @@ static void ecred_connect_rsp_cb(struct bt_conn *conn, uint16_t result,
 	}
 
 	att->eatt.prev_conn_req_result = result;
-	att->eatt.prev_conn_req_missing_chans =
-		attempted_to_connect - succeeded_to_connect;
+	att->eatt.prev_conn_req_missing_chans = attempted_to_connect - succeeded_to_connect;
 
 	handle_potential_collision(att);
 }
@@ -3690,8 +3527,7 @@ int bt_eatt_connect(struct bt_conn *conn, size_t num_channels)
 }
 
 #if defined(CONFIG_BT_EATT_AUTO_CONNECT)
-static void eatt_auto_connect(struct bt_conn *conn, bt_security_t level,
-			      enum bt_security_err err)
+static void eatt_auto_connect(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
 {
 	int eatt_err;
 
@@ -3904,8 +3740,7 @@ static void att_chan_mtu_updated(struct bt_att_chan *updated_chan)
 	}
 
 	/* If either maximum MTU has changed */
-	if ((updated_chan->chan.tx.mtu > max_tx) ||
-	    (updated_chan->chan.rx.mtu > max_rx)) {
+	if ((updated_chan->chan.tx.mtu > max_tx) || (updated_chan->chan.rx.mtu > max_rx)) {
 		max_tx = MAX(max_tx, updated_chan->chan.tx.mtu);
 		max_rx = MAX(max_rx, updated_chan->chan.rx.mtu);
 		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
@@ -3993,8 +3828,7 @@ int bt_att_req_send(struct bt_conn *conn, struct bt_att_req *req)
 	return 0;
 }
 
-static bool bt_att_chan_req_cancel(struct bt_att_chan *chan,
-				   struct bt_att_req *req)
+static bool bt_att_chan_req_cancel(struct bt_att_chan *chan, struct bt_att_req *req)
 {
 	if (chan->req != req) {
 		return false;
@@ -4122,8 +3956,7 @@ bool bt_att_tx_meta_data_match(const struct net_buf *buf, bt_gatt_complete_func_
 {
 	const struct bt_att_tx_meta_data *meta = bt_att_get_tx_meta_data(buf);
 
-	return ((meta->func == func) &&
-		(meta->user_data == user_data) &&
+	return ((meta->func == func) && (meta->user_data == user_data) &&
 		(meta->chan_opt == chan_opt));
 }
 
diff --git a/subsys/bluetooth/host/att_internal.h b/subsys/bluetooth/host/att_internal.h
index 6eec4c5496e..2f72d729373 100644
--- a/subsys/bluetooth/host/att_internal.h
+++ b/subsys/bluetooth/host/att_internal.h
@@ -8,10 +8,10 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-#define BT_EATT_PSM		0x27
-#define BT_ATT_DEFAULT_LE_MTU	23
-#define BT_ATT_TIMEOUT_SEC	30
-#define BT_ATT_TIMEOUT		K_SECONDS(BT_ATT_TIMEOUT_SEC)
+#define BT_EATT_PSM           0x27
+#define BT_ATT_DEFAULT_LE_MTU 23
+#define BT_ATT_TIMEOUT_SEC    30
+#define BT_ATT_TIMEOUT        K_SECONDS(BT_ATT_TIMEOUT_SEC)
 
 /* Local ATT Rx MTU
  *
@@ -30,36 +30,36 @@
 #define BT_ATT_BUF_SIZE MAX(BT_LOCAL_ATT_MTU_UATT, BT_LOCAL_ATT_MTU_EATT)
 
 struct bt_att_hdr {
-	uint8_t  code;
+	uint8_t code;
 } __packed;
 
-#define BT_ATT_OP_ERROR_RSP			0x01
+#define BT_ATT_OP_ERROR_RSP 0x01
 struct bt_att_error_rsp {
-	uint8_t  request;
+	uint8_t request;
 	uint16_t handle;
-	uint8_t  error;
+	uint8_t error;
 } __packed;
 
-#define BT_ATT_OP_MTU_REQ			0x02
+#define BT_ATT_OP_MTU_REQ 0x02
 struct bt_att_exchange_mtu_req {
 	uint16_t mtu;
 } __packed;
 
-#define BT_ATT_OP_MTU_RSP			0x03
+#define BT_ATT_OP_MTU_RSP 0x03
 struct bt_att_exchange_mtu_rsp {
 	uint16_t mtu;
 } __packed;
 
 /* Find Information Request */
-#define BT_ATT_OP_FIND_INFO_REQ			0x04
+#define BT_ATT_OP_FIND_INFO_REQ 0x04
 struct bt_att_find_info_req {
 	uint16_t start_handle;
 	uint16_t end_handle;
 } __packed;
 
 /* Format field values for BT_ATT_OP_FIND_INFO_RSP */
-#define BT_ATT_INFO_16				0x01
-#define BT_ATT_INFO_128				0x02
+#define BT_ATT_INFO_16  0x01
+#define BT_ATT_INFO_128 0x02
 
 struct bt_att_info_16 {
 	uint16_t handle;
@@ -68,23 +68,23 @@ struct bt_att_info_16 {
 
 struct bt_att_info_128 {
 	uint16_t handle;
-	uint8_t  uuid[16];
+	uint8_t uuid[16];
 } __packed;
 
 /* Find Information Response */
-#define BT_ATT_OP_FIND_INFO_RSP			0x05
+#define BT_ATT_OP_FIND_INFO_RSP 0x05
 struct bt_att_find_info_rsp {
-	uint8_t  format;
-	uint8_t  info[0];
+	uint8_t format;
+	uint8_t info[0];
 } __packed;
 
 /* Find By Type Value Request */
-#define BT_ATT_OP_FIND_TYPE_REQ			0x06
+#define BT_ATT_OP_FIND_TYPE_REQ 0x06
 struct bt_att_find_type_req {
 	uint16_t start_handle;
 	uint16_t end_handle;
 	uint16_t type;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 struct bt_att_handle_group {
@@ -93,190 +93,188 @@ struct bt_att_handle_group {
 } __packed;
 
 /* Find By Type Value Response */
-#define BT_ATT_OP_FIND_TYPE_RSP			0x07
+#define BT_ATT_OP_FIND_TYPE_RSP 0x07
 struct bt_att_find_type_rsp {
 	struct bt_att_handle_group list[0];
 } __packed;
 
 /* Read By Type Request */
-#define BT_ATT_OP_READ_TYPE_REQ			0x08
+#define BT_ATT_OP_READ_TYPE_REQ 0x08
 struct bt_att_read_type_req {
 	uint16_t start_handle;
 	uint16_t end_handle;
-	uint8_t  uuid[0];
+	uint8_t uuid[0];
 } __packed;
 
 struct bt_att_data {
 	uint16_t handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Read By Type Response */
-#define BT_ATT_OP_READ_TYPE_RSP			0x09
+#define BT_ATT_OP_READ_TYPE_RSP 0x09
 struct bt_att_read_type_rsp {
-	uint8_t  len;
+	uint8_t len;
 	struct bt_att_data data[0];
 } __packed;
 
 /* Read Request */
-#define BT_ATT_OP_READ_REQ			0x0a
+#define BT_ATT_OP_READ_REQ 0x0a
 struct bt_att_read_req {
 	uint16_t handle;
 } __packed;
 
 /* Read Response */
-#define BT_ATT_OP_READ_RSP			0x0b
+#define BT_ATT_OP_READ_RSP 0x0b
 struct bt_att_read_rsp {
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Read Blob Request */
-#define BT_ATT_OP_READ_BLOB_REQ			0x0c
+#define BT_ATT_OP_READ_BLOB_REQ 0x0c
 struct bt_att_read_blob_req {
 	uint16_t handle;
 	uint16_t offset;
 } __packed;
 
 /* Read Blob Response */
-#define BT_ATT_OP_READ_BLOB_RSP			0x0d
+#define BT_ATT_OP_READ_BLOB_RSP 0x0d
 struct bt_att_read_blob_rsp {
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Read Multiple Request */
-#define BT_ATT_READ_MULT_MIN_LEN_REQ		0x04
+#define BT_ATT_READ_MULT_MIN_LEN_REQ 0x04
 
-#define BT_ATT_OP_READ_MULT_REQ			0x0e
+#define BT_ATT_OP_READ_MULT_REQ 0x0e
 struct bt_att_read_mult_req {
 	uint16_t handles[0];
 } __packed;
 
 /* Read Multiple Response */
-#define BT_ATT_OP_READ_MULT_RSP			0x0f
+#define BT_ATT_OP_READ_MULT_RSP 0x0f
 struct bt_att_read_mult_rsp {
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Read by Group Type Request */
-#define BT_ATT_OP_READ_GROUP_REQ		0x10
+#define BT_ATT_OP_READ_GROUP_REQ 0x10
 struct bt_att_read_group_req {
 	uint16_t start_handle;
 	uint16_t end_handle;
-	uint8_t  uuid[0];
+	uint8_t uuid[0];
 } __packed;
 
 struct bt_att_group_data {
 	uint16_t start_handle;
 	uint16_t end_handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Read by Group Type Response */
-#define BT_ATT_OP_READ_GROUP_RSP		0x11
+#define BT_ATT_OP_READ_GROUP_RSP 0x11
 struct bt_att_read_group_rsp {
-	uint8_t  len;
+	uint8_t len;
 	struct bt_att_group_data data[0];
 } __packed;
 
 /* Write Request */
-#define BT_ATT_OP_WRITE_REQ			0x12
+#define BT_ATT_OP_WRITE_REQ 0x12
 struct bt_att_write_req {
 	uint16_t handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Write Response */
-#define BT_ATT_OP_WRITE_RSP			0x13
+#define BT_ATT_OP_WRITE_RSP 0x13
 
 /* Prepare Write Request */
-#define BT_ATT_OP_PREPARE_WRITE_REQ		0x16
+#define BT_ATT_OP_PREPARE_WRITE_REQ 0x16
 struct bt_att_prepare_write_req {
 	uint16_t handle;
 	uint16_t offset;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Prepare Write Respond */
-#define BT_ATT_OP_PREPARE_WRITE_RSP		0x17
+#define BT_ATT_OP_PREPARE_WRITE_RSP 0x17
 struct bt_att_prepare_write_rsp {
 	uint16_t handle;
 	uint16_t offset;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Execute Write Request */
-#define BT_ATT_FLAG_CANCEL			0x00
-#define BT_ATT_FLAG_EXEC			0x01
+#define BT_ATT_FLAG_CANCEL 0x00
+#define BT_ATT_FLAG_EXEC   0x01
 
-#define BT_ATT_OP_EXEC_WRITE_REQ		0x18
+#define BT_ATT_OP_EXEC_WRITE_REQ 0x18
 struct bt_att_exec_write_req {
-	uint8_t  flags;
+	uint8_t flags;
 } __packed;
 
 /* Execute Write Response */
-#define BT_ATT_OP_EXEC_WRITE_RSP		0x19
+#define BT_ATT_OP_EXEC_WRITE_RSP 0x19
 
 /* Handle Value Notification */
-#define BT_ATT_OP_NOTIFY			0x1b
+#define BT_ATT_OP_NOTIFY 0x1b
 struct bt_att_notify {
 	uint16_t handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Handle Value Indication */
-#define BT_ATT_OP_INDICATE			0x1d
+#define BT_ATT_OP_INDICATE 0x1d
 struct bt_att_indicate {
 	uint16_t handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Handle Value Confirm */
-#define BT_ATT_OP_CONFIRM			0x1e
+#define BT_ATT_OP_CONFIRM 0x1e
 
 struct bt_att_signature {
-	uint8_t  value[12];
+	uint8_t value[12];
 } __packed;
 
-#define BT_ATT_OP_READ_MULT_VL_REQ		0x20
+#define BT_ATT_OP_READ_MULT_VL_REQ 0x20
 struct bt_att_read_mult_vl_req {
 	uint16_t handles[0];
 } __packed;
 
 /* Read Multiple Response */
-#define BT_ATT_OP_READ_MULT_VL_RSP		0x21
+#define BT_ATT_OP_READ_MULT_VL_RSP 0x21
 struct bt_att_read_mult_vl_rsp {
 	uint16_t len;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Handle Multiple Value Notification */
-#define BT_ATT_OP_NOTIFY_MULT			0x23
+#define BT_ATT_OP_NOTIFY_MULT 0x23
 struct bt_att_notify_mult {
 	uint16_t handle;
 	uint16_t len;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Write Command */
-#define BT_ATT_OP_WRITE_CMD			0x52
+#define BT_ATT_OP_WRITE_CMD 0x52
 struct bt_att_write_cmd {
 	uint16_t handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
 /* Signed Write Command */
-#define BT_ATT_OP_SIGNED_WRITE_CMD		0xd2
+#define BT_ATT_OP_SIGNED_WRITE_CMD 0xd2
 struct bt_att_signed_write_cmd {
 	uint16_t handle;
-	uint8_t  value[0];
+	uint8_t value[0];
 } __packed;
 
-typedef void (*bt_att_func_t)(struct bt_conn *conn, int err,
-			      const void *pdu, uint16_t length,
+typedef void (*bt_att_func_t)(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 			      void *user_data);
 
-typedef int (*bt_att_encode_t)(struct net_buf *buf, size_t len,
-			       void *user_data);
+typedef int (*bt_att_encode_t)(struct net_buf *buf, size_t len, void *user_data);
 
 /* ATT request context */
 struct bt_att_req {
@@ -285,7 +283,7 @@ struct bt_att_req {
 	struct net_buf *buf;
 #if defined(CONFIG_BT_SMP)
 	bt_att_encode_t encode;
-	uint8_t retrying : 1;
+	uint8_t retrying: 1;
 	uint8_t att_op;
 	size_t len;
 #endif /* CONFIG_BT_SMP */
@@ -295,8 +293,7 @@ struct bt_att_req {
 void bt_att_init(void);
 uint16_t bt_att_get_mtu(struct bt_conn *conn);
 uint16_t bt_att_get_uatt_mtu(struct bt_conn *conn);
-struct net_buf *bt_att_create_pdu(struct bt_conn *conn, uint8_t op,
-				  size_t len);
+struct net_buf *bt_att_create_pdu(struct bt_conn *conn, uint8_t op, size_t len);
 
 /* Allocate a new request */
 struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout);
@@ -332,7 +329,7 @@ void bt_att_clear_out_of_sync_sent(struct bt_conn *conn);
 /* Check if BT_ATT_ERR_DB_OUT_OF_SYNC has been sent on the fixed ATT channel */
 bool bt_att_out_of_sync_sent_on_fixed(struct bt_conn *conn);
 
-typedef void (*bt_gatt_complete_func_t) (struct bt_conn *conn, void *user_data);
+typedef void (*bt_gatt_complete_func_t)(struct bt_conn *conn, void *user_data);
 void bt_att_set_tx_meta_data(struct net_buf *buf, bt_gatt_complete_func_t func, void *user_data,
 			     enum bt_att_chan_opt chan_opt);
 void bt_att_increment_tx_meta_data_attr_count(struct net_buf *buf, uint16_t attr_count);
diff --git a/subsys/bluetooth/host/buf.c b/subsys/bluetooth/host/buf.c
index 75bd15834ae..cedecebb58e 100644
--- a/subsys/bluetooth/host/buf.c
+++ b/subsys/bluetooth/host/buf.c
@@ -97,8 +97,8 @@ struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
 {
 	struct net_buf *buf;
 
-	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN ||
-		 type == BT_BUF_ISO_IN, "Invalid buffer type requested");
+	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN || type == BT_BUF_ISO_IN,
+		 "Invalid buffer type requested");
 
 	if (IS_ENABLED(CONFIG_BT_ISO_RX) && type == BT_BUF_ISO_IN) {
 		return bt_iso_get_rx(timeout);
@@ -135,8 +135,7 @@ void bt_buf_rx_freed_cb_set(bt_buf_rx_freed_cb_t cb)
 	k_sched_unlock();
 }
 
-struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
-			       k_timeout_t timeout)
+struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable, k_timeout_t timeout)
 {
 	struct net_buf *buf;
 
@@ -197,9 +196,7 @@ struct net_buf_pool *bt_buf_get_num_complete_pool(void)
 #endif /* CONFIG_BT_CONN || CONFIG_BT_ISO */
 #endif /* ZTEST_UNITTEST */
 
-struct net_buf *bt_buf_make_view(struct net_buf *view,
-				 struct net_buf *parent,
-				 size_t len,
+struct net_buf *bt_buf_make_view(struct net_buf *view, struct net_buf *parent, size_t len,
 				 struct bt_buf_view_meta *meta)
 {
 	__ASSERT_NO_MSG(len);
diff --git a/subsys/bluetooth/host/buf_view.h b/subsys/bluetooth/host/buf_view.h
index 1b9a78ec7b4..79fe0d2e7ff 100644
--- a/subsys/bluetooth/host/buf_view.h
+++ b/subsys/bluetooth/host/buf_view.h
@@ -13,7 +13,6 @@
 
 #include <zephyr/net_buf.h>
 
-
 struct bt_buf_view_meta {
 	struct net_buf *parent;
 	/* saves the data pointers while the parent buffer is locked. */
@@ -53,9 +52,7 @@ struct bt_buf_view_meta {
  *
  *  @return view if the operation was successful. NULL on error.
  */
-struct net_buf *bt_buf_make_view(struct net_buf *view,
-				 struct net_buf *parent,
-				 size_t len,
+struct net_buf *bt_buf_make_view(struct net_buf *view, struct net_buf *parent, size_t len,
 				 struct bt_buf_view_meta *meta);
 
 /** @internal
diff --git a/subsys/bluetooth/host/classic/a2dp_codec_sbc.c b/subsys/bluetooth/host/classic/a2dp_codec_sbc.c
index e5f66cd1e93..4c20aa58dc2 100644
--- a/subsys/bluetooth/host/classic/a2dp_codec_sbc.c
+++ b/subsys/bluetooth/host/classic/a2dp_codec_sbc.c
@@ -15,7 +15,6 @@
 #include <zephyr/bluetooth/classic/a2dp_codec_sbc.h>
 #include <zephyr/bluetooth/classic/a2dp.h>
 
-
 uint8_t bt_a2dp_sbc_get_channel_num(struct bt_a2dp_codec_sbc_params *sbc_codec)
 {
 	__ASSERT_NO_MSG(sbc_codec != NULL);
diff --git a/subsys/bluetooth/host/classic/at.c b/subsys/bluetooth/host/classic/at.c
index fadeeab10fb..9abb3198a5d 100644
--- a/subsys/bluetooth/host/classic/at.c
+++ b/subsys/bluetooth/host/classic/at.c
@@ -49,9 +49,7 @@ int at_get_number(struct at_client *at, uint32_t *val)
 
 	skip_space(at);
 
-	for (i = 0U, *val = 0U;
-	     isdigit((unsigned char)at->buf[at->pos]) != 0;
-	     at->pos++, i++) {
+	for (i = 0U, *val = 0U; isdigit((unsigned char)at->buf[at->pos]) != 0; at->pos++, i++) {
 		*val = *val * 10U + at->buf[at->pos] - '0';
 	}
 
@@ -72,8 +70,7 @@ static bool str_has_prefix(const char *str, const char *prefix)
 	return true;
 }
 
-static int at_parse_result(const char *str, struct net_buf *buf,
-			   enum at_result *result)
+static int at_parse_result(const char *str, struct net_buf *buf, enum at_result *result)
 {
 	/* Map the result and check for end lf */
 	if ((!strncmp(str, "OK", 2)) && (at_check_byte(buf, '\n') == 0)) {
@@ -89,8 +86,8 @@ static int at_parse_result(const char *str, struct net_buf *buf,
 	return -ENOMSG;
 }
 
-static int get_cmd_value(struct at_client *at, struct net_buf *buf,
-			 char stop_byte, enum at_cmd_state cmd_state)
+static int get_cmd_value(struct at_client *at, struct net_buf *buf, char stop_byte,
+			 enum at_cmd_state cmd_state)
 {
 	int cmd_len = 0;
 	uint8_t pos = at->pos;
@@ -119,8 +116,8 @@ static int get_cmd_value(struct at_client *at, struct net_buf *buf,
 	return 0;
 }
 
-static int get_response_string(struct at_client *at, struct net_buf *buf,
-			       char stop_byte, enum at_state state)
+static int get_response_string(struct at_client *at, struct net_buf *buf, char stop_byte,
+			       enum at_state state)
 {
 	int cmd_len = 0;
 	uint8_t pos = at->pos;
@@ -287,8 +284,7 @@ int cme_handle(struct at_client *at)
 static int at_state_process_ag_nw_err(struct at_client *at, struct net_buf *buf)
 {
 	at->cmd_state = AT_CMD_GET_VALUE;
-	return at_parse_cmd_input(at, buf, NULL, cme_handle,
-				  AT_CMD_TYPE_NORMAL);
+	return at_parse_cmd_input(at, buf, NULL, cme_handle, AT_CMD_TYPE_NORMAL);
 }
 
 static int at_state_unsolicited_cmd(struct at_client *at, struct net_buf *buf)
@@ -302,15 +298,15 @@ static int at_state_unsolicited_cmd(struct at_client *at, struct net_buf *buf)
 
 /* The order of handler function should match the enum at_state */
 static handle_parse_input_t parser_cb[] = {
-	at_state_start, /* AT_STATE_START */
-	at_state_start_cr, /* AT_STATE_START_CR */
-	at_state_start_lf, /* AT_STATE_START_LF */
-	at_state_get_cmd_string, /* AT_STATE_GET_CMD_STRING */
-	at_state_process_cmd, /* AT_STATE_PROCESS_CMD */
+	at_state_start,             /* AT_STATE_START */
+	at_state_start_cr,          /* AT_STATE_START_CR */
+	at_state_start_lf,          /* AT_STATE_START_LF */
+	at_state_get_cmd_string,    /* AT_STATE_GET_CMD_STRING */
+	at_state_process_cmd,       /* AT_STATE_PROCESS_CMD */
 	at_state_get_result_string, /* AT_STATE_GET_RESULT_STRING */
-	at_state_process_result, /* AT_STATE_PROCESS_RESULT */
+	at_state_process_result,    /* AT_STATE_PROCESS_RESULT */
 	at_state_process_ag_nw_err, /* AT_STATE_PROCESS_AG_NW_ERR */
-	at_state_unsolicited_cmd /* AT_STATE_UNSOLICITED_CMD */
+	at_state_unsolicited_cmd    /* AT_STATE_UNSOLICITED_CMD */
 };
 
 int at_parse_input(struct at_client *at, struct net_buf *buf)
@@ -333,9 +329,8 @@ int at_parse_input(struct at_client *at, struct net_buf *buf)
 	return 0;
 }
 
-static int at_cmd_start(struct at_client *at, struct net_buf *buf,
-			const char *prefix, parse_val_t func,
-			enum at_cmd_type type)
+static int at_cmd_start(struct at_client *at, struct net_buf *buf, const char *prefix,
+			parse_val_t func, enum at_cmd_type type)
 {
 	if (!str_has_prefix(at->buf, prefix)) {
 		if (type == AT_CMD_TYPE_NORMAL) {
@@ -356,18 +351,16 @@ static int at_cmd_start(struct at_client *at, struct net_buf *buf,
 	return 0;
 }
 
-static int at_cmd_get_value(struct at_client *at, struct net_buf *buf,
-			    const char *prefix, parse_val_t func,
-			    enum at_cmd_type type)
+static int at_cmd_get_value(struct at_client *at, struct net_buf *buf, const char *prefix,
+			    parse_val_t func, enum at_cmd_type type)
 {
 	/* Reset buffer before getting the values */
 	reset_buffer(at);
 	return get_cmd_value(at, buf, '\r', AT_CMD_PROCESS_VALUE);
 }
 
-static int at_cmd_process_value(struct at_client *at, struct net_buf *buf,
-				const char *prefix, parse_val_t func,
-				enum at_cmd_type type)
+static int at_cmd_process_value(struct at_client *at, struct net_buf *buf, const char *prefix,
+				parse_val_t func, enum at_cmd_type type)
 {
 	int ret;
 
@@ -377,9 +370,8 @@ static int at_cmd_process_value(struct at_client *at, struct net_buf *buf,
 	return ret;
 }
 
-static int at_cmd_state_end_lf(struct at_client *at, struct net_buf *buf,
-			       const char *prefix, parse_val_t func,
-			       enum at_cmd_type type)
+static int at_cmd_state_end_lf(struct at_client *at, struct net_buf *buf, const char *prefix,
+			       parse_val_t func, enum at_cmd_type type)
 {
 	int err;
 
@@ -395,21 +387,19 @@ static int at_cmd_state_end_lf(struct at_client *at, struct net_buf *buf,
 
 /* The order of handler function should match the enum at_cmd_state */
 static handle_cmd_input_t cmd_parser_cb[] = {
-	at_cmd_start, /* AT_CMD_START */
-	at_cmd_get_value, /* AT_CMD_GET_VALUE */
+	at_cmd_start,         /* AT_CMD_START */
+	at_cmd_get_value,     /* AT_CMD_GET_VALUE */
 	at_cmd_process_value, /* AT_CMD_PROCESS_VALUE */
-	at_cmd_state_end_lf /* AT_CMD_STATE_END_LF */
+	at_cmd_state_end_lf   /* AT_CMD_STATE_END_LF */
 };
 
-int at_parse_cmd_input(struct at_client *at, struct net_buf *buf,
-		       const char *prefix, parse_val_t func,
-		       enum at_cmd_type type)
+int at_parse_cmd_input(struct at_client *at, struct net_buf *buf, const char *prefix,
+		       parse_val_t func, enum at_cmd_type type)
 {
 	int ret;
 
 	while (buf->len) {
-		if (at->cmd_state < AT_CMD_START ||
-		    at->cmd_state >= AT_CMD_STATE_END) {
+		if (at->cmd_state < AT_CMD_START || at->cmd_state >= AT_CMD_STATE_END) {
 			return -EINVAL;
 		}
 		ret = cmd_parser_cb[at->cmd_state](at, buf, prefix, func, type);
diff --git a/subsys/bluetooth/host/classic/at.h b/subsys/bluetooth/host/classic/at.h
index ae2c7f95d80..335810e2d10 100644
--- a/subsys/bluetooth/host/classic/at.h
+++ b/subsys/bluetooth/host/classic/at.h
@@ -15,30 +15,30 @@ enum at_result {
 };
 
 enum at_cme {
-	CME_ERROR_AG_FAILURE                    = 0,
-	CME_ERROR_NO_CONNECTION_TO_PHONE        = 1,
-	CME_ERROR_OPERATION_NOT_ALLOWED         = 3,
-	CME_ERROR_OPERATION_NOT_SUPPORTED       = 4,
-	CME_ERROR_PH_SIM_PIN_REQUIRED           = 5,
-	CME_ERROR_SIM_NOT_INSERTED              = 10,
-	CME_ERROR_SIM_PIN_REQUIRED              = 11,
-	CME_ERROR_SIM_PUK_REQUIRED              = 12,
-	CME_ERROR_SIM_FAILURE                   = 13,
-	CME_ERROR_SIM_BUSY                      = 14,
-	CME_ERROR_INCORRECT_PASSWORD            = 16,
-	CME_ERROR_SIM_PIN2_REQUIRED             = 17,
-	CME_ERROR_SIM_PUK2_REQUIRED             = 18,
-	CME_ERROR_MEMORY_FULL                   = 20,
-	CME_ERROR_INVALID_INDEX                 = 21,
-	CME_ERROR_MEMORY_FAILURE                = 23,
-	CME_ERROR_TEXT_STRING_TOO_LONG          = 24,
-	CME_ERROR_INVALID_CHARS_IN_TEXT_STRING  = 25,
-	CME_ERROR_DIAL_STRING_TO_LONG           = 26,
-	CME_ERROR_INVALID_CHARS_IN_DIAL_STRING  = 27,
-	CME_ERROR_NO_NETWORK_SERVICE            = 30,
-	CME_ERROR_NETWORK_TIMEOUT               = 31,
-	CME_ERROR_NETWORK_NOT_ALLOWED           = 32,
-	CME_ERROR_UNKNOWN                       = 33,
+	CME_ERROR_AG_FAILURE = 0,
+	CME_ERROR_NO_CONNECTION_TO_PHONE = 1,
+	CME_ERROR_OPERATION_NOT_ALLOWED = 3,
+	CME_ERROR_OPERATION_NOT_SUPPORTED = 4,
+	CME_ERROR_PH_SIM_PIN_REQUIRED = 5,
+	CME_ERROR_SIM_NOT_INSERTED = 10,
+	CME_ERROR_SIM_PIN_REQUIRED = 11,
+	CME_ERROR_SIM_PUK_REQUIRED = 12,
+	CME_ERROR_SIM_FAILURE = 13,
+	CME_ERROR_SIM_BUSY = 14,
+	CME_ERROR_INCORRECT_PASSWORD = 16,
+	CME_ERROR_SIM_PIN2_REQUIRED = 17,
+	CME_ERROR_SIM_PUK2_REQUIRED = 18,
+	CME_ERROR_MEMORY_FULL = 20,
+	CME_ERROR_INVALID_INDEX = 21,
+	CME_ERROR_MEMORY_FAILURE = 23,
+	CME_ERROR_TEXT_STRING_TOO_LONG = 24,
+	CME_ERROR_INVALID_CHARS_IN_TEXT_STRING = 25,
+	CME_ERROR_DIAL_STRING_TO_LONG = 26,
+	CME_ERROR_INVALID_CHARS_IN_DIAL_STRING = 27,
+	CME_ERROR_NO_NETWORK_SERVICE = 30,
+	CME_ERROR_NETWORK_TIMEOUT = 31,
+	CME_ERROR_NETWORK_NOT_ALLOWED = 32,
+	CME_ERROR_UNKNOWN = 33,
 };
 
 enum at_state {
@@ -80,13 +80,11 @@ typedef int (*at_resp_cb_t)(struct at_client *at, struct net_buf *buf);
  * Argument 'cme_err' is valid only when argument 'result' is equal to
  * AT_RESULT_CME_ERROR
  */
-typedef int (*at_finish_cb_t)(struct at_client *at, enum at_result result,
-			      enum at_cme cme_err);
+typedef int (*at_finish_cb_t)(struct at_client *at, enum at_result result, enum at_cme cme_err);
 typedef int (*parse_val_t)(struct at_client *at);
 typedef int (*handle_parse_input_t)(struct at_client *at, struct net_buf *buf);
-typedef int (*handle_cmd_input_t)(struct at_client *at, struct net_buf *buf,
-				  const char *prefix, parse_val_t func,
-				  enum at_cmd_type type);
+typedef int (*handle_cmd_input_t)(struct at_client *at, struct net_buf *buf, const char *prefix,
+				  parse_val_t func, enum at_cmd_type type);
 
 struct at_client {
 	char *buf;
@@ -100,16 +98,14 @@ struct at_client {
 };
 
 /* Register the callback functions */
-void at_register(struct at_client *at, at_resp_cb_t resp,
-		 at_finish_cb_t finish);
+void at_register(struct at_client *at, at_resp_cb_t resp, at_finish_cb_t finish);
 void at_register_unsolicited(struct at_client *at, at_resp_cb_t unsolicited);
 int at_get_number(struct at_client *at, uint32_t *val);
 /* This parsing will only works for non-fragmented net_buf */
 int at_parse_input(struct at_client *at, struct net_buf *buf);
 /* This command parsing will only works for non-fragmented net_buf */
-int at_parse_cmd_input(struct at_client *at, struct net_buf *buf,
-		       const char *prefix, parse_val_t func,
-		       enum at_cmd_type type);
+int at_parse_cmd_input(struct at_client *at, struct net_buf *buf, const char *prefix,
+		       parse_val_t func, enum at_cmd_type type);
 int at_check_byte(struct net_buf *buf, char check_byte);
 int at_list_get_range(struct at_client *at, uint32_t *min, uint32_t *max);
 int at_list_get_string(struct at_client *at, char *name, uint8_t len);
diff --git a/subsys/bluetooth/host/classic/avrcp.c b/subsys/bluetooth/host/classic/avrcp.c
index 049bc84a358..d5c11b48bca 100644
--- a/subsys/bluetooth/host/classic/avrcp.c
+++ b/subsys/bluetooth/host/classic/avrcp.c
@@ -55,66 +55,30 @@ static struct bt_avrcp avrcp_connection[CONFIG_BT_MAX_CONN];
 #if defined(CONFIG_BT_AVRCP_TARGET)
 static struct bt_sdp_attribute avrcp_tg_attrs[] = {
 	BT_SDP_NEW_SERVICE,
-	BT_SDP_LIST(
-		BT_SDP_ATTR_SVCLASS_ID_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_TARGET_SVCLASS)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROTO_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)
-			},
-			)
-		},
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(AVCTP_VER_1_4)
-			},
-			)
-		},
-		)
-	),
+	BT_SDP_LIST(BT_SDP_ATTR_SVCLASS_ID_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
+		    BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+					   BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_TARGET_SVCLASS)}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROTO_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)}, )},
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(AVCTP_VER_1_4)}, )}, )),
 	/* C1: Browsing not supported */
 	/* C2: Cover Art not supported */
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROFILE_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_SVCLASS)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(AVRCP_VER_1_6)
-			},
-			)
-		},
-		)
-	),
+	BT_SDP_LIST(BT_SDP_ATTR_PROFILE_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_SVCLASS)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(AVRCP_VER_1_6)}, )}, )),
 	BT_SDP_SUPPORTED_FEATURES(AVRCP_CAT_1 | AVRCP_CAT_2),
 	/* O: Provider Name not presented */
 	BT_SDP_SERVICE_NAME("AVRCP Target"),
@@ -127,71 +91,31 @@ static struct bt_sdp_record avrcp_tg_rec = BT_SDP_RECORD(avrcp_tg_attrs);
 static struct bt_sdp_attribute avrcp_ct_attrs[] = {
 	BT_SDP_NEW_SERVICE,
 	BT_SDP_LIST(
-		BT_SDP_ATTR_SVCLASS_ID_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_SVCLASS)
-		},
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_CONTROLLER_SVCLASS)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROTO_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)
-			},
-			)
-		},
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(AVCTP_VER_1_4)
-			},
-			)
-		},
-		)
-	),
+		BT_SDP_ATTR_SVCLASS_ID_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+		BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+				       BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_SVCLASS)},
+				      {BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+				       BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_CONTROLLER_SVCLASS)}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROTO_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)}, )},
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_UUID_AVCTP_VAL)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(AVCTP_VER_1_4)}, )}, )),
 	/* C1: Browsing not supported */
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROFILE_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_SVCLASS)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(AVRCP_VER_1_6)
-			},
-			)
-		},
-		)
-	),
+	BT_SDP_LIST(BT_SDP_ATTR_PROFILE_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_AV_REMOTE_SVCLASS)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(AVRCP_VER_1_6)}, )}, )),
 	BT_SDP_SUPPORTED_FEATURES(AVRCP_CAT_1 | AVRCP_CAT_2),
 	/* O: Provider Name not presented */
 	BT_SDP_SERVICE_NAME("AVRCP Controller"),
@@ -272,7 +196,7 @@ static void avrcp_unit_info_handler(struct bt_avrcp *avrcp, struct net_buf *buf,
 }
 
 static void avrcp_subunit_info_handler(struct bt_avrcp *avrcp, struct net_buf *buf,
-					   bt_avctp_cr_t cr)
+				       bt_avctp_cr_t cr)
 {
 	struct bt_avrcp_header *avrcp_hdr;
 	struct bt_avrcp_subunit_info_rsp rsp;
@@ -303,16 +227,16 @@ static void avrcp_subunit_info_handler(struct bt_avrcp *avrcp, struct net_buf *b
 }
 
 static void avrcp_pass_through_handler(struct bt_avrcp *avrcp, struct net_buf *buf,
-					   bt_avctp_cr_t cr)
+				       bt_avctp_cr_t cr)
 {
 	/* ToDo */
 }
 
 static const struct avrcp_handler handler[] = {
-	{ BT_AVRCP_OPC_VENDOR_DEPENDENT, avrcp_vendor_dependent_handler },
-	{ BT_AVRCP_OPC_UNIT_INFO, avrcp_unit_info_handler },
-	{ BT_AVRCP_OPC_SUBUNIT_INFO, avrcp_subunit_info_handler },
-	{ BT_AVRCP_OPC_PASS_THROUGH, avrcp_pass_through_handler },
+	{BT_AVRCP_OPC_VENDOR_DEPENDENT, avrcp_vendor_dependent_handler},
+	{BT_AVRCP_OPC_UNIT_INFO, avrcp_unit_info_handler},
+	{BT_AVRCP_OPC_SUBUNIT_INFO, avrcp_subunit_info_handler},
+	{BT_AVRCP_OPC_PASS_THROUGH, avrcp_pass_through_handler},
 };
 
 /* An AVRCP message received */
diff --git a/subsys/bluetooth/host/classic/hfp_ag.c b/subsys/bluetooth/host/classic/hfp_ag.c
index c9f92f1618c..8c8a1d6a41e 100644
--- a/subsys/bluetooth/host/classic/hfp_ag.c
+++ b/subsys/bluetooth/host/classic/hfp_ag.c
@@ -541,13 +541,13 @@ static int bt_hfp_ag_cind_handler(struct bt_hfp_ag *ag, struct net_buf *buf)
 			ag_ind[BT_HFP_AG_BATTERY_IND].max);
 	} else {
 		err = hfp_ag_send_data(ag, NULL, NULL, "\r\n+CIND:%d,%d,%d,%d,%d,%d,%d\r\n",
-					 ag->indicator_value[BT_HFP_AG_SERVICE_IND],
-					 ag->indicator_value[BT_HFP_AG_CALL_IND],
-					 ag->indicator_value[BT_HFP_AG_CALL_SETUP_IND],
-					 ag->indicator_value[BT_HFP_AG_CALL_HELD_IND],
-					 ag->indicator_value[BT_HFP_AG_SIGNAL_IND],
-					 ag->indicator_value[BT_HFP_AG_ROAM_IND],
-					 ag->indicator_value[BT_HFP_AG_BATTERY_IND]);
+				       ag->indicator_value[BT_HFP_AG_SERVICE_IND],
+				       ag->indicator_value[BT_HFP_AG_CALL_IND],
+				       ag->indicator_value[BT_HFP_AG_CALL_SETUP_IND],
+				       ag->indicator_value[BT_HFP_AG_CALL_HELD_IND],
+				       ag->indicator_value[BT_HFP_AG_SIGNAL_IND],
+				       ag->indicator_value[BT_HFP_AG_ROAM_IND],
+				       ag->indicator_value[BT_HFP_AG_BATTERY_IND]);
 	}
 
 	return err;
@@ -815,7 +815,7 @@ static void bt_hfp_ag_reject_cb(struct bt_hfp_ag *ag, void *user_data)
 static void bt_hfp_ag_call_reject(struct bt_hfp_ag *ag, void *user_data)
 {
 	int err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_NONE,
-					    bt_hfp_ag_reject_cb, user_data);
+					  bt_hfp_ag_reject_cb, user_data);
 	if (err != 0) {
 		LOG_ERR("Fail to send err :(%d)", err);
 	}
@@ -834,7 +834,7 @@ static void bt_hfp_ag_terminate_cb(struct bt_hfp_ag *ag, void *user_data)
 static void bt_hfp_ag_unit_call_terminate(struct bt_hfp_ag *ag, void *user_data)
 {
 	int err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_IND, 0, bt_hfp_ag_terminate_cb,
-					    user_data);
+					  user_data);
 	if (err != 0) {
 		LOG_ERR("Fail to send err :(%d)", err);
 	}
@@ -1160,7 +1160,7 @@ static void bt_hfp_ag_unit_call_accept(struct bt_hfp_ag *ag, void *user_data)
 	}
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_NONE,
-					bt_hfp_ag_audio_connection, user_data);
+				      bt_hfp_ag_audio_connection, user_data);
 	if (err != 0) {
 		LOG_ERR("Fail to send err :(%d)", err);
 	}
@@ -1248,10 +1248,8 @@ static int bt_hfp_ag_bcc_handler(struct bt_hfp_ag *ag, struct net_buf *buf)
 	}
 
 	hfp_ag_lock(ag);
-	if ((ag->selected_codec_id == 0) ||
-		(!(ag->hf_codec_ids & BIT(ag->selected_codec_id))) ||
-		(ag->call_state == BT_HFP_CALL_TERMINATE) ||
-		(ag->sco_chan.sco != NULL)) {
+	if ((ag->selected_codec_id == 0) || (!(ag->hf_codec_ids & BIT(ag->selected_codec_id))) ||
+	    (ag->call_state == BT_HFP_CALL_TERMINATE) || (ag->sco_chan.sco != NULL)) {
 		hfp_ag_unlock(ag);
 		return -ENOTSUP;
 	}
@@ -1295,12 +1293,12 @@ static int bt_hfp_ag_bcs_handler(struct bt_hfp_ag *ag, struct net_buf *buf)
 
 	hfp_ag_lock(ag);
 	if (ag->selected_codec_id != number) {
-		LOG_ERR("Received codec id %d is not aligned with selected %d",
-				number, ag->selected_codec_id);
+		LOG_ERR("Received codec id %d is not aligned with selected %d", number,
+			ag->selected_codec_id);
 		err = -ENOTSUP;
 	} else if (!(ag->hf_codec_ids & BIT(ag->selected_codec_id))) {
-		LOG_ERR("Selected codec id %d is unsupported %d",
-				ag->selected_codec_id, ag->hf_codec_ids);
+		LOG_ERR("Selected codec id %d is unsupported %d", ag->selected_codec_id,
+			ag->hf_codec_ids);
 		err = -ENOTSUP;
 	}
 	hfp_ag_unlock(ag);
@@ -1513,7 +1511,7 @@ static void hfp_ag_recv(struct bt_rfcomm_dlc *dlc, struct net_buf *buf)
 			continue;
 		}
 		if (strncmp((char *)data, cmd_handlers[index].cmd,
-				 strlen(cmd_handlers[index].cmd)) != 0) {
+			    strlen(cmd_handlers[index].cmd)) != 0) {
 			continue;
 		}
 		if (NULL != cmd_handlers[index].handler) {
@@ -1634,13 +1632,13 @@ static void bt_ag_deferred_work_cb(struct bt_hfp_ag *ag, void *user_data)
 		if (ag->indicator_value[BT_HFP_AG_CALL_SETUP_IND] &&
 		    ag->indicator_value[BT_HFP_AG_CALL_IND]) {
 			err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND,
-							BT_HFP_CALL_SETUP_NONE, NULL, NULL);
+						      BT_HFP_CALL_SETUP_NONE, NULL, NULL);
 			if (err) {
 				LOG_ERR("Fail to send indicator");
 				bt_hfp_ag_terminate_cb(ag, NULL);
 			} else {
 				err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_IND, 0,
-								bt_hfp_ag_terminate_cb, NULL);
+							      bt_hfp_ag_terminate_cb, NULL);
 				if (err) {
 					LOG_ERR("Fail to send indicator");
 					bt_hfp_ag_terminate_cb(ag, NULL);
@@ -1648,15 +1646,15 @@ static void bt_ag_deferred_work_cb(struct bt_hfp_ag *ag, void *user_data)
 			}
 		} else if (ag->indicator_value[BT_HFP_AG_CALL_SETUP_IND]) {
 			err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND,
-							BT_HFP_CALL_SETUP_NONE, bt_hfp_ag_reject_cb,
-							NULL);
+						      BT_HFP_CALL_SETUP_NONE, bt_hfp_ag_reject_cb,
+						      NULL);
 			if (err) {
 				LOG_ERR("Fail to send indicator");
 				bt_hfp_ag_terminate_cb(ag, NULL);
 			}
 		} else if (ag->indicator_value[BT_HFP_AG_CALL_IND]) {
 			err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_IND, 0,
-							bt_hfp_ag_terminate_cb, NULL);
+						      bt_hfp_ag_terminate_cb, NULL);
 			if (err) {
 				LOG_ERR("Fail to send indicator");
 				bt_hfp_ag_terminate_cb(ag, NULL);
@@ -1699,7 +1697,7 @@ static void bt_ag_ringing_work_cb(struct bt_hfp_ag *ag, void *user_data)
 		} else {
 			if (atomic_test_bit(ag->flags, BT_HFP_AG_CLIP_ENABLE)) {
 				err = hfp_ag_send_data(ag, NULL, NULL, "\r\n+CLIP:\"%s\",%d\r\n",
-							 ag->number, 0);
+						       ag->number, 0);
 				if (err) {
 					LOG_ERR("Fail to send CLIP %d", err);
 				}
@@ -1940,7 +1938,7 @@ int bt_hfp_ag_remote_incoming(struct bt_hfp_ag *ag, const char *number)
 	atomic_set_bit(ag->flags, BT_HFP_AG_INCOMING_CALL);
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_INCOMING,
-					bt_hfp_ag_incoming_cb, NULL);
+				      bt_hfp_ag_incoming_cb, NULL);
 	if (err != 0) {
 		atomic_clear_bit(ag->flags, BT_HFP_AG_INCOMING_CALL);
 	}
@@ -1975,7 +1973,7 @@ int bt_hfp_ag_reject(struct bt_hfp_ag *ag)
 	}
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_NONE,
-					bt_hfp_ag_reject_cb, NULL);
+				      bt_hfp_ag_reject_cb, NULL);
 
 	return err;
 }
@@ -2012,7 +2010,7 @@ int bt_hfp_ag_accept(struct bt_hfp_ag *ag)
 	}
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_NONE,
-					bt_hfp_ag_audio_connection, NULL);
+				      bt_hfp_ag_audio_connection, NULL);
 	if (err != 0) {
 		LOG_ERR("Fail to send err :(%d)", err);
 	}
@@ -2101,7 +2099,7 @@ int bt_hfp_ag_outgoing(struct bt_hfp_ag *ag, const char *number)
 	atomic_clear_bit(ag->flags, BT_HFP_AG_INCOMING_CALL);
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_OUTGOING,
-					bt_hfp_ag_outgoing_cb, NULL);
+				      bt_hfp_ag_outgoing_cb, NULL);
 
 	return err;
 }
@@ -2147,8 +2145,8 @@ int bt_hfp_ag_remote_ringing(struct bt_hfp_ag *ag)
 	hfp_ag_unlock(ag);
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND,
-					BT_HFP_CALL_SETUP_REMOTE_ALERTING, bt_hfp_ag_ringing_cb,
-					NULL);
+				      BT_HFP_CALL_SETUP_REMOTE_ALERTING, bt_hfp_ag_ringing_cb,
+				      NULL);
 
 	return err;
 }
@@ -2180,7 +2178,7 @@ int bt_hfp_ag_remote_reject(struct bt_hfp_ag *ag)
 	}
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_NONE,
-					bt_hfp_ag_reject_cb, NULL);
+				      bt_hfp_ag_reject_cb, NULL);
 
 	return err;
 }
@@ -2217,7 +2215,7 @@ int bt_hfp_ag_remote_accept(struct bt_hfp_ag *ag)
 	}
 
 	err = hfp_ag_update_indicator(ag, BT_HFP_AG_CALL_SETUP_IND, BT_HFP_CALL_SETUP_NONE,
-					bt_hfp_ag_audio_connection, NULL);
+				      bt_hfp_ag_audio_connection, NULL);
 	if (err != 0) {
 		LOG_ERR("Fail to send err :(%d)", err);
 	}
diff --git a/subsys/bluetooth/host/classic/hfp_hf.c b/subsys/bluetooth/host/classic/hfp_hf.c
index 4bde73e9399..52de7f83e38 100644
--- a/subsys/bluetooth/host/classic/hfp_hf.c
+++ b/subsys/bluetooth/host/classic/hfp_hf.c
@@ -36,8 +36,7 @@ LOG_MODULE_REGISTER(bt_hfp_hf);
 
 struct bt_hfp_hf_cb *bt_hf;
 
-NET_BUF_POOL_FIXED_DEFINE(hf_pool, CONFIG_BT_MAX_CONN + 1,
-			  BT_RFCOMM_BUF_SIZE(BT_HF_CLIENT_MAX_PDU),
+NET_BUF_POOL_FIXED_DEFINE(hf_pool, CONFIG_BT_MAX_CONN + 1, BT_RFCOMM_BUF_SIZE(BT_HF_CLIENT_MAX_PDU),
 			  CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);
 
 static struct bt_hfp_hf bt_hfp_hf_pool[CONFIG_BT_MAX_CONN];
@@ -48,74 +47,38 @@ static const struct {
 	uint32_t min;
 	uint32_t max;
 } ag_ind[] = {
-	{"service", 0, 1}, /* HF_SERVICE_IND */
-	{"call", 0, 1}, /* HF_CALL_IND */
+	{"service", 0, 1},   /* HF_SERVICE_IND */
+	{"call", 0, 1},      /* HF_CALL_IND */
 	{"callsetup", 0, 3}, /* HF_CALL_SETUP_IND */
-	{"callheld", 0, 2}, /* HF_CALL_HELD_IND */
-	{"signal", 0, 5}, /* HF_SIGNAL_IND */
-	{"roam", 0, 1}, /* HF_ROAM_IND */
-	{"battchg", 0, 5} /* HF_BATTERY_IND */
+	{"callheld", 0, 2},  /* HF_CALL_HELD_IND */
+	{"signal", 0, 5},    /* HF_SIGNAL_IND */
+	{"roam", 0, 1},      /* HF_ROAM_IND */
+	{"battchg", 0, 5}    /* HF_BATTERY_IND */
 };
 
 /* HFP Hands-Free SDP record */
 static struct bt_sdp_attribute hfp_attrs[] = {
 	BT_SDP_NEW_SERVICE,
-	BT_SDP_LIST(
-		BT_SDP_ATTR_SVCLASS_ID_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_HANDSFREE_SVCLASS)
-		},
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_GENERIC_AUDIO_SVCLASS)
-		}
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROTO_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 12),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)
-			},
-			)
-		},
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 5),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_RFCOMM)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT8),
-				BT_SDP_ARRAY_8(BT_RFCOMM_CHAN_HFP_HF)
-			},
-			)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROFILE_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_HANDSFREE_SVCLASS)
-		},
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-			BT_SDP_ARRAY_16(0x0109)
-		},
-		)
-	),
+	BT_SDP_LIST(BT_SDP_ATTR_SVCLASS_ID_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+		    BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+					   BT_SDP_ARRAY_16(BT_SDP_HANDSFREE_SVCLASS)},
+					  {BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+					   BT_SDP_ARRAY_16(BT_SDP_GENERIC_AUDIO_SVCLASS)})),
+	BT_SDP_LIST(BT_SDP_ATTR_PROTO_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 12),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)}, )},
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 5),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_RFCOMM)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT8),
+						    BT_SDP_ARRAY_8(BT_RFCOMM_CHAN_HFP_HF)}, )}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROFILE_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+			     BT_SDP_ARRAY_16(BT_SDP_HANDSFREE_SVCLASS)},
+			    {BT_SDP_TYPE_SIZE(BT_SDP_UINT16), BT_SDP_ARRAY_16(0x0109)}, )),
 	/* The values of the “SupportedFeatures” bitmap shall be the same as the
 	 * values of the Bits 0 to 4 of the AT-command AT+BRSF (see Section 5.3).
 	 */
@@ -136,8 +99,8 @@ void hf_slc_error(struct at_client *hf_at)
 	}
 }
 
-int hfp_hf_send_cmd(struct bt_hfp_hf *hf, at_resp_cb_t resp,
-		    at_finish_cb_t finish, const char *format, ...)
+int hfp_hf_send_cmd(struct bt_hfp_hf *hf, at_resp_cb_t resp, at_finish_cb_t finish,
+		    const char *format, ...)
 {
 	struct net_buf *buf;
 	va_list vargs;
@@ -197,8 +160,7 @@ int brsf_resp(struct at_client *hf_at, struct net_buf *buf)
 
 	LOG_DBG("");
 
-	err = at_parse_cmd_input(hf_at, buf, "BRSF", brsf_handle,
-				 AT_CMD_TYPE_NORMAL);
+	err = at_parse_cmd_input(hf_at, buf, "BRSF", brsf_handle, AT_CMD_TYPE_NORMAL);
 	if (err < 0) {
 		/* Returning negative value is avoided before SLC connection
 		 * established.
@@ -210,8 +172,8 @@ int brsf_resp(struct at_client *hf_at, struct net_buf *buf)
 	return 0;
 }
 
-static void cind_handle_values(struct at_client *hf_at, uint32_t index,
-			       char *name, uint32_t min, uint32_t max)
+static void cind_handle_values(struct at_client *hf_at, uint32_t index, char *name, uint32_t min,
+			       uint32_t max)
 {
 	struct bt_hfp_hf *hf = CONTAINER_OF(hf_at, struct bt_hfp_hf, at);
 	int i;
@@ -285,8 +247,7 @@ int cind_resp(struct at_client *hf_at, struct net_buf *buf)
 {
 	int err;
 
-	err = at_parse_cmd_input(hf_at, buf, "CIND", cind_handle,
-				 AT_CMD_TYPE_NORMAL);
+	err = at_parse_cmd_input(hf_at, buf, "CIND", cind_handle, AT_CMD_TYPE_NORMAL);
 	if (err < 0) {
 		LOG_ERR("Error parsing CMD input");
 		hf_slc_error(hf_at);
@@ -295,8 +256,7 @@ int cind_resp(struct at_client *hf_at, struct net_buf *buf)
 	return 0;
 }
 
-void ag_indicator_handle_values(struct at_client *hf_at, uint32_t index,
-				uint32_t value)
+void ag_indicator_handle_values(struct at_client *hf_at, uint32_t index, uint32_t value)
 {
 	struct bt_hfp_hf *hf = CONTAINER_OF(hf_at, struct bt_hfp_hf, at);
 	struct bt_conn *conn = hf->acl;
@@ -308,8 +268,7 @@ void ag_indicator_handle_values(struct at_client *hf_at, uint32_t index,
 		return;
 	}
 
-	if (value > ag_ind[hf->ind_table[index]].max ||
-	    value < ag_ind[hf->ind_table[index]].min) {
+	if (value > ag_ind[hf->ind_table[index]].max || value < ag_ind[hf->ind_table[index]].min) {
 		LOG_ERR("Indicators out of range - value: %u", value);
 		return;
 	}
@@ -382,8 +341,7 @@ int cind_status_resp(struct at_client *hf_at, struct net_buf *buf)
 {
 	int err;
 
-	err = at_parse_cmd_input(hf_at, buf, "CIND", cind_status_handle,
-				 AT_CMD_TYPE_NORMAL);
+	err = at_parse_cmd_input(hf_at, buf, "CIND", cind_status_handle, AT_CMD_TYPE_NORMAL);
 	if (err < 0) {
 		LOG_ERR("Error parsing CMD input");
 		hf_slc_error(hf_at);
@@ -435,18 +393,15 @@ static const struct unsolicited {
 	const char *cmd;
 	enum at_cmd_type type;
 	int (*func)(struct at_client *hf_at);
-} handlers[] = {
-	{ "CIEV", AT_CMD_TYPE_UNSOLICITED, ciev_handle },
-	{ "RING", AT_CMD_TYPE_OTHER, ring_handle }
-};
+} handlers[] = {{"CIEV", AT_CMD_TYPE_UNSOLICITED, ciev_handle},
+		{"RING", AT_CMD_TYPE_OTHER, ring_handle}};
 
 static const struct unsolicited *hfp_hf_unsol_lookup(struct at_client *hf_at)
 {
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(handlers); i++) {
-		if (!strncmp(hf_at->buf, handlers[i].cmd,
-			     strlen(handlers[i].cmd))) {
+		if (!strncmp(hf_at->buf, handlers[i].cmd, strlen(handlers[i].cmd))) {
 			return &handlers[i];
 		}
 	}
@@ -464,20 +419,18 @@ int unsolicited_cb(struct at_client *hf_at, struct net_buf *buf)
 		return -ENOMSG;
 	}
 
-	if (!at_parse_cmd_input(hf_at, buf, handler->cmd, handler->func,
-				handler->type)) {
+	if (!at_parse_cmd_input(hf_at, buf, handler->cmd, handler->func, handler->type)) {
 		return 0;
 	}
 
 	return -ENOMSG;
 }
 
-int cmd_complete(struct at_client *hf_at, enum at_result result,
-	       enum at_cme cme_err)
+int cmd_complete(struct at_client *hf_at, enum at_result result, enum at_cme cme_err)
 {
 	struct bt_hfp_hf *hf = CONTAINER_OF(hf_at, struct bt_hfp_hf, at);
 	struct bt_conn *conn = hf->acl;
-	struct bt_hfp_hf_cmd_complete cmd = { 0 };
+	struct bt_hfp_hf_cmd_complete cmd = {0};
 
 	LOG_DBG("");
 
@@ -505,8 +458,7 @@ int cmd_complete(struct at_client *hf_at, enum at_result result,
 	return 0;
 }
 
-int cmee_finish(struct at_client *hf_at, enum at_result result,
-		enum at_cme cme_err)
+int cmee_finish(struct at_client *hf_at, enum at_result result, enum at_cme cme_err)
 {
 	if (result != AT_RESULT_OK) {
 		LOG_ERR("SLC Connection ERROR in response");
@@ -530,8 +482,7 @@ static void slc_completed(struct at_client *hf_at)
 	}
 }
 
-int cmer_finish(struct at_client *hf_at, enum at_result result,
-		enum at_cme cme_err)
+int cmer_finish(struct at_client *hf_at, enum at_result result, enum at_cme cme_err)
 {
 	if (result != AT_RESULT_OK) {
 		LOG_ERR("SLC Connection ERROR in response");
@@ -544,8 +495,7 @@ int cmer_finish(struct at_client *hf_at, enum at_result result,
 	return 0;
 }
 
-int cind_status_finish(struct at_client *hf_at, enum at_result result,
-		       enum at_cme cme_err)
+int cind_status_finish(struct at_client *hf_at, enum at_result result, enum at_cme cme_err)
 {
 	struct bt_hfp_hf *hf = CONTAINER_OF(hf_at, struct bt_hfp_hf, at);
 	int err;
@@ -566,8 +516,7 @@ int cind_status_finish(struct at_client *hf_at, enum at_result result,
 	return 0;
 }
 
-int cind_finish(struct at_client *hf_at, enum at_result result,
-		enum at_cme cme_err)
+int cind_finish(struct at_client *hf_at, enum at_result result, enum at_cme cme_err)
 {
 	struct bt_hfp_hf *hf = CONTAINER_OF(hf_at, struct bt_hfp_hf, at);
 	int err;
@@ -578,8 +527,7 @@ int cind_finish(struct at_client *hf_at, enum at_result result,
 		return -EINVAL;
 	}
 
-	err = hfp_hf_send_cmd(hf, cind_status_resp, cind_status_finish,
-			      "AT+CIND?");
+	err = hfp_hf_send_cmd(hf, cind_status_resp, cind_status_finish, "AT+CIND?");
 	if (err < 0) {
 		hf_slc_error(hf_at);
 		return err;
@@ -588,8 +536,7 @@ int cind_finish(struct at_client *hf_at, enum at_result result,
 	return 0;
 }
 
-int brsf_finish(struct at_client *hf_at, enum at_result result,
-		enum at_cme cme_err)
+int brsf_finish(struct at_client *hf_at, enum at_result result, enum at_cme cme_err)
 {
 	struct bt_hfp_hf *hf = CONTAINER_OF(hf_at, struct bt_hfp_hf, at);
 	int err;
@@ -615,8 +562,7 @@ int hf_slc_establish(struct bt_hfp_hf *hf)
 
 	LOG_DBG("");
 
-	err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
-			      hf->hf_features);
+	err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u", hf->hf_features);
 	if (err < 0) {
 		hf_slc_error(&hf->at);
 		return err;
@@ -774,8 +720,7 @@ static void hfp_hf_sco_disconnected(struct bt_sco_chan *chan, uint8_t reason)
 	}
 }
 
-static int bt_hfp_hf_sco_accept(const struct bt_sco_accept_info *info,
-		      struct bt_sco_chan **chan)
+static int bt_hfp_hf_sco_accept(const struct bt_sco_accept_info *info, struct bt_sco_chan **chan)
 {
 	int i;
 	static struct bt_sco_chan_ops ops = {
diff --git a/subsys/bluetooth/host/classic/keys_br.c b/subsys/bluetooth/host/classic/keys_br.c
index 3c9536fe112..c1b439b2a32 100644
--- a/subsys/bluetooth/host/classic/keys_br.c
+++ b/subsys/bluetooth/host/classic/keys_br.c
@@ -166,8 +166,7 @@ void bt_foreach_bond_br(void (*func)(const struct bt_bond_info *info, void *user
 
 #if defined(CONFIG_BT_SETTINGS)
 
-static int link_key_set(const char *name, size_t len_rd,
-			settings_read_cb read_cb, void *cb_arg)
+static int link_key_set(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	int err;
 	ssize_t len;
@@ -212,13 +211,12 @@ static int link_key_set(const char *name, size_t len_rd,
 	if (aging_counter_val < link_key->aging_counter) {
 		aging_counter_val = link_key->aging_counter;
 	}
-#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
+#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 
 	return 0;
 }
 
-SETTINGS_STATIC_HANDLER_DEFINE(bt_link_key, "bt/link_key", NULL, link_key_set,
-			       NULL, NULL);
+SETTINGS_STATIC_HANDLER_DEFINE(bt_link_key, "bt/link_key", NULL, link_key_set, NULL, NULL);
 
 #if defined(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
 void bt_keys_link_key_update_usage(const bt_addr_t *addr)
@@ -242,6 +240,6 @@ void bt_keys_link_key_update_usage(const bt_addr_t *addr)
 		bt_keys_link_key_store(link_key);
 	}
 }
-#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
+#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 
 #endif /* defined(CONFIG_BT_SETTINGS) */
diff --git a/subsys/bluetooth/host/classic/l2cap_br.c b/subsys/bluetooth/host/classic/l2cap_br.c
index 405a971cfef..949594dee22 100644
--- a/subsys/bluetooth/host/classic/l2cap_br.c
+++ b/subsys/bluetooth/host/classic/l2cap_br.c
@@ -32,60 +32,58 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(bt_l2cap_br, CONFIG_BT_L2CAP_LOG_LEVEL);
 
-#define BR_CHAN_RTX(_w) CONTAINER_OF(k_work_delayable_from_work(_w), \
-				     struct bt_l2cap_br_chan, rtx_work)
+#define BR_CHAN_RTX(_w)                                                                            \
+	CONTAINER_OF(k_work_delayable_from_work(_w), struct bt_l2cap_br_chan, rtx_work)
 
-#define L2CAP_BR_PSM_START	0x0001
-#define L2CAP_BR_PSM_END	0xffff
+#define L2CAP_BR_PSM_START 0x0001
+#define L2CAP_BR_PSM_END   0xffff
 
-#define L2CAP_BR_CID_DYN_START	0x0040
-#define L2CAP_BR_CID_DYN_END	0xffff
-#define L2CAP_BR_CID_IS_DYN(_cid) \
-	(_cid >= L2CAP_BR_CID_DYN_START && _cid <= L2CAP_BR_CID_DYN_END)
+#define L2CAP_BR_CID_DYN_START    0x0040
+#define L2CAP_BR_CID_DYN_END      0xffff
+#define L2CAP_BR_CID_IS_DYN(_cid) (_cid >= L2CAP_BR_CID_DYN_START && _cid <= L2CAP_BR_CID_DYN_END)
 
-#define L2CAP_BR_MIN_MTU	48
-#define L2CAP_BR_DEFAULT_MTU	672
+#define L2CAP_BR_MIN_MTU     48
+#define L2CAP_BR_DEFAULT_MTU 672
 
-#define L2CAP_BR_PSM_SDP	0x0001
+#define L2CAP_BR_PSM_SDP 0x0001
 
-#define L2CAP_BR_INFO_TIMEOUT		K_SECONDS(4)
-#define L2CAP_BR_CFG_TIMEOUT		K_SECONDS(4)
-#define L2CAP_BR_DISCONN_TIMEOUT	K_SECONDS(1)
-#define L2CAP_BR_CONN_TIMEOUT		K_SECONDS(40)
+#define L2CAP_BR_INFO_TIMEOUT    K_SECONDS(4)
+#define L2CAP_BR_CFG_TIMEOUT     K_SECONDS(4)
+#define L2CAP_BR_DISCONN_TIMEOUT K_SECONDS(1)
+#define L2CAP_BR_CONN_TIMEOUT    K_SECONDS(40)
 
 /*
  * L2CAP extended feature mask:
  * BR/EDR fixed channel support enabled
  */
-#define L2CAP_FEAT_FIXED_CHAN_MASK	0x00000080
+#define L2CAP_FEAT_FIXED_CHAN_MASK 0x00000080
 
 enum {
 	/* Connection oriented channels flags */
-	L2CAP_FLAG_CONN_LCONF_DONE,	/* local config accepted by remote */
-	L2CAP_FLAG_CONN_RCONF_DONE,	/* remote config accepted by local */
-	L2CAP_FLAG_CONN_ACCEPTOR,	/* getting incoming connection req */
-	L2CAP_FLAG_CONN_PENDING,	/* remote sent pending result in rsp */
+	L2CAP_FLAG_CONN_LCONF_DONE, /* local config accepted by remote */
+	L2CAP_FLAG_CONN_RCONF_DONE, /* remote config accepted by local */
+	L2CAP_FLAG_CONN_ACCEPTOR,   /* getting incoming connection req */
+	L2CAP_FLAG_CONN_PENDING,    /* remote sent pending result in rsp */
 
 	/* Signaling channel flags */
-	L2CAP_FLAG_SIG_INFO_PENDING,	/* retrieving remote l2cap info */
-	L2CAP_FLAG_SIG_INFO_DONE,	/* remote l2cap info is done */
+	L2CAP_FLAG_SIG_INFO_PENDING, /* retrieving remote l2cap info */
+	L2CAP_FLAG_SIG_INFO_DONE,    /* remote l2cap info is done */
 
 	/* fixed channels flags */
-	L2CAP_FLAG_FIXED_CONNECTED,		/* fixed connected */
+	L2CAP_FLAG_FIXED_CONNECTED, /* fixed connected */
 };
 
 static sys_slist_t br_servers;
 
-
 /* Pool for outgoing BR/EDR signaling packets, min MTU is 48 */
-NET_BUF_POOL_FIXED_DEFINE(br_sig_pool, CONFIG_BT_MAX_CONN,
-			  BT_L2CAP_BUF_SIZE(L2CAP_BR_MIN_MTU), 8, NULL);
+NET_BUF_POOL_FIXED_DEFINE(br_sig_pool, CONFIG_BT_MAX_CONN, BT_L2CAP_BUF_SIZE(L2CAP_BR_MIN_MTU), 8,
+			  NULL);
 
 /* BR/EDR L2CAP signalling channel specific context */
 struct bt_l2cap_br {
 	/* The channel this context is associated with */
-	struct bt_l2cap_br_chan	chan;
-	uint8_t			info_ident;
+	struct bt_l2cap_br_chan chan;
+	uint8_t info_ident;
 	/*
 	 * 2.1 CHANNEL IDENTIFIERS in
 	 * BLUETOOTH CORE SPECIFICATION Version 5.4 | Vol 3, Part A.
@@ -93,14 +91,13 @@ struct bt_l2cap_br {
 	 * So use one octet buffer to keep the `Fixed channels supported`
 	 * of peer device.
 	 */
-	uint8_t			info_fixed_chan;
-	uint32_t			info_feat_mask;
+	uint8_t info_fixed_chan;
+	uint32_t info_feat_mask;
 };
 
 static struct bt_l2cap_br bt_l2cap_br_pool[CONFIG_BT_MAX_CONN];
 
-struct bt_l2cap_chan *bt_l2cap_br_lookup_rx_cid(struct bt_conn *conn,
-						uint16_t cid)
+struct bt_l2cap_chan *bt_l2cap_br_lookup_rx_cid(struct bt_conn *conn, uint16_t cid)
 {
 	struct bt_l2cap_chan *chan;
 
@@ -113,8 +110,7 @@ struct bt_l2cap_chan *bt_l2cap_br_lookup_rx_cid(struct bt_conn *conn,
 	return NULL;
 }
 
-struct bt_l2cap_chan *bt_l2cap_br_lookup_tx_cid(struct bt_conn *conn,
-						uint16_t cid)
+struct bt_l2cap_chan *bt_l2cap_br_lookup_tx_cid(struct bt_conn *conn, uint16_t cid)
 {
 	struct bt_l2cap_chan *chan;
 
@@ -142,8 +138,8 @@ uint8_t bt_l2cap_br_get_remote_fixed_chan(struct bt_conn *conn)
 	return br_chan_sig->info_fixed_chan;
 }
 
-static struct bt_l2cap_br_chan*
-l2cap_br_chan_alloc_cid(struct bt_conn *conn, struct bt_l2cap_chan *chan)
+static struct bt_l2cap_br_chan *l2cap_br_chan_alloc_cid(struct bt_conn *conn,
+							struct bt_l2cap_chan *chan)
 {
 	struct bt_l2cap_br_chan *br_chan = BR_CHAN(chan);
 	uint16_t cid;
@@ -267,8 +263,7 @@ static uint8_t l2cap_br_get_ident(void)
 static void raise_data_ready(struct bt_l2cap_br_chan *br_chan)
 {
 	if (!atomic_set(&br_chan->_pdu_ready_lock, 1)) {
-		sys_slist_append(&br_chan->chan.conn->l2cap_data_ready,
-				 &br_chan->_pdu_ready);
+		sys_slist_append(&br_chan->chan.conn->l2cap_data_ready, &br_chan->_pdu_ready);
 		LOG_DBG("data ready raised");
 	} else {
 		LOG_DBG("data ready already");
@@ -293,14 +288,13 @@ static void cancel_data_ready(struct bt_l2cap_br_chan *br_chan)
 {
 	struct bt_conn *conn = br_chan->chan.conn;
 
-	sys_slist_find_and_remove(&conn->l2cap_data_ready,
-				  &br_chan->_pdu_ready);
+	sys_slist_find_and_remove(&conn->l2cap_data_ready, &br_chan->_pdu_ready);
 
 	atomic_set(&br_chan->_pdu_ready_lock, 0);
 }
 
-int bt_l2cap_br_send_cb(struct bt_conn *conn, uint16_t cid, struct net_buf *buf,
-			bt_conn_tx_cb_t cb, void *user_data)
+int bt_l2cap_br_send_cb(struct bt_conn *conn, uint16_t cid, struct net_buf *buf, bt_conn_tx_cb_t cb,
+			void *user_data)
 {
 	struct bt_l2cap_hdr *hdr;
 	struct bt_l2cap_chan *ch = bt_l2cap_br_lookup_tx_cid(conn, cid);
@@ -313,10 +307,8 @@ int bt_l2cap_br_send_cb(struct bt_conn *conn, uint16_t cid, struct net_buf *buf,
 	hdr->cid = sys_cpu_to_le16(cid);
 
 	if (buf->user_data_size < sizeof(struct closure)) {
-		LOG_WRN("not enough room in user_data %d < %d pool %u",
-			buf->user_data_size,
-			CONFIG_BT_CONN_TX_USER_DATA_SIZE,
-			buf->pool_id);
+		LOG_WRN("not enough room in user_data %d < %d pool %u", buf->user_data_size,
+			CONFIG_BT_CONN_TX_USER_DATA_SIZE, buf->pool_id);
 		return -EINVAL;
 	}
 
@@ -333,20 +325,18 @@ int bt_l2cap_br_send_cb(struct bt_conn *conn, uint16_t cid, struct net_buf *buf,
  * Any other cleanup in failure to send should be handled by the disconnected
  * handler.
  */
-static inline void l2cap_send(struct bt_conn *conn, uint16_t cid,
-			      struct net_buf *buf)
+static inline void l2cap_send(struct bt_conn *conn, uint16_t cid, struct net_buf *buf)
 {
 	if (bt_l2cap_br_send_cb(conn, cid, buf, NULL, NULL)) {
 		net_buf_unref(buf);
 	}
 }
 
-static void l2cap_br_chan_send_req(struct bt_l2cap_br_chan *chan,
-				   struct net_buf *buf, k_timeout_t timeout)
+static void l2cap_br_chan_send_req(struct bt_l2cap_br_chan *chan, struct net_buf *buf,
+				   k_timeout_t timeout)
 {
 
-	if (bt_l2cap_br_send_cb(chan->chan.conn, BT_L2CAP_CID_BR_SIG, buf,
-			     NULL, NULL)) {
+	if (bt_l2cap_br_send_cb(chan->chan.conn, BT_L2CAP_CID_BR_SIG, buf, NULL, NULL)) {
 		net_buf_unref(buf);
 		return;
 	}
@@ -369,9 +359,7 @@ static bool chan_has_data(struct bt_l2cap_br_chan *br_chan)
 	return !k_fifo_is_empty(&br_chan->_pdu_tx_queue);
 }
 
-struct net_buf *l2cap_br_data_pull(struct bt_conn *conn,
-				   size_t amount,
-				   size_t *length)
+struct net_buf *l2cap_br_data_pull(struct bt_conn *conn, size_t amount, size_t *length)
 {
 	const sys_snode_t *pdu_ready = sys_slist_peek_head(&conn->l2cap_data_ready);
 
@@ -380,9 +368,8 @@ struct net_buf *l2cap_br_data_pull(struct bt_conn *conn,
 		return NULL;
 	}
 
-	struct bt_l2cap_br_chan *br_chan = CONTAINER_OF(pdu_ready,
-							struct bt_l2cap_br_chan,
-							_pdu_ready);
+	struct bt_l2cap_br_chan *br_chan =
+		CONTAINER_OF(pdu_ready, struct bt_l2cap_br_chan, _pdu_ready);
 
 	/* Leave the PDU buffer in the queue until we have sent all its
 	 * fragments.
@@ -477,16 +464,14 @@ static void connect_optional_fixed_channels(struct bt_l2cap_br *l2cap)
 	if (l2cap->info_fixed_chan & BIT(BT_L2CAP_CID_BR_SMP)) {
 		struct bt_l2cap_chan *chan;
 
-		chan = bt_l2cap_br_lookup_rx_cid(l2cap->chan.chan.conn,
-						 BT_L2CAP_CID_BR_SMP);
+		chan = bt_l2cap_br_lookup_rx_cid(l2cap->chan.chan.conn, BT_L2CAP_CID_BR_SMP);
 		if (chan) {
 			connect_fixed_channel(BR_CHAN(chan));
 		}
 	}
 }
 
-static int l2cap_br_info_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
-			     struct net_buf *buf)
+static int l2cap_br_info_rsp(struct bt_l2cap_br *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_l2cap_info_rsp *rsp;
 	uint16_t type, result;
@@ -496,8 +481,7 @@ static int l2cap_br_info_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
 		return 0;
 	}
 
-	if (atomic_test_and_clear_bit(l2cap->chan.flags,
-				      L2CAP_FLAG_SIG_INFO_PENDING)) {
+	if (atomic_test_and_clear_bit(l2cap->chan.flags, L2CAP_FLAG_SIG_INFO_PENDING)) {
 		/*
 		 * Release RTX timer since got the response & there's pending
 		 * command request.
@@ -586,8 +570,7 @@ static uint8_t get_fixed_channels_mask(void)
 	return mask;
 }
 
-static int l2cap_br_info_req(struct bt_l2cap_br *l2cap, uint8_t ident,
-			     struct net_buf *buf)
+static int l2cap_br_info_req(struct bt_l2cap_br *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_info_req *req = (void *)buf->data;
@@ -767,8 +750,8 @@ enum l2cap_br_conn_security_result {
  * - bt_conn_set_security API returns < 0.
  */
 
-static enum l2cap_br_conn_security_result
-l2cap_br_conn_security(struct bt_l2cap_chan *chan, const uint16_t psm)
+static enum l2cap_br_conn_security_result l2cap_br_conn_security(struct bt_l2cap_chan *chan,
+								 const uint16_t psm)
 {
 	int check;
 	struct bt_l2cap_br_chan *br_chan = BR_CHAN(chan);
@@ -813,8 +796,7 @@ l2cap_br_conn_security(struct bt_l2cap_chan *chan, const uint16_t psm)
 	 * bt_conn_set_security API returns 0 what implies also there was no
 	 * need to trigger authentication.
 	 */
-	if (check == 0 &&
-	    chan->conn->sec_level >= br_chan->required_sec_level) {
+	if (check == 0 && chan->conn->sec_level >= br_chan->required_sec_level) {
 		return L2CAP_CONN_SECURITY_PASSED;
 	}
 
@@ -842,8 +824,8 @@ l2cap_br_conn_security(struct bt_l2cap_chan *chan, const uint16_t psm)
 	return L2CAP_CONN_SECURITY_REJECT;
 }
 
-static void l2cap_br_send_conn_rsp(struct bt_conn *conn, uint16_t scid,
-				  uint16_t dcid, uint8_t ident, uint16_t result)
+static void l2cap_br_send_conn_rsp(struct bt_conn *conn, uint16_t scid, uint16_t dcid,
+				   uint8_t ident, uint16_t result)
 {
 	struct net_buf *buf;
 	struct bt_l2cap_conn_rsp *rsp;
@@ -877,8 +859,8 @@ static int l2cap_br_conn_req_reply(struct bt_l2cap_chan *chan, uint16_t result)
 		return -ESRCH;
 	}
 
-	l2cap_br_send_conn_rsp(chan->conn, BR_CHAN(chan)->tx.cid,
-			       BR_CHAN(chan)->rx.cid, BR_CHAN(chan)->ident, result);
+	l2cap_br_send_conn_rsp(chan->conn, BR_CHAN(chan)->tx.cid, BR_CHAN(chan)->rx.cid,
+			       BR_CHAN(chan)->ident, result);
 	BR_CHAN(chan)->ident = 0U;
 
 	return 0;
@@ -886,9 +868,8 @@ static int l2cap_br_conn_req_reply(struct bt_l2cap_chan *chan, uint16_t result)
 
 #if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
 #if defined(CONFIG_BT_L2CAP_LOG_LEVEL_DBG)
-void bt_l2cap_br_chan_set_state_debug(struct bt_l2cap_chan *chan,
-				   bt_l2cap_chan_state_t state,
-				   const char *func, int line)
+void bt_l2cap_br_chan_set_state_debug(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state,
+				      const char *func, int line)
 {
 	struct bt_l2cap_br_chan *br_chan;
 
@@ -913,14 +894,12 @@ void bt_l2cap_br_chan_set_state_debug(struct bt_l2cap_chan *chan,
 		}
 		break;
 	case BT_L2CAP_CONNECTED:
-		if (br_chan->state != BT_L2CAP_CONFIG &&
-		    br_chan->state != BT_L2CAP_CONNECTING) {
+		if (br_chan->state != BT_L2CAP_CONFIG && br_chan->state != BT_L2CAP_CONNECTING) {
 			LOG_WRN("%s()%d: invalid transition", func, line);
 		}
 		break;
 	case BT_L2CAP_DISCONNECTING:
-		if (br_chan->state != BT_L2CAP_CONFIG &&
-		    br_chan->state != BT_L2CAP_CONNECTED) {
+		if (br_chan->state != BT_L2CAP_CONFIG && br_chan->state != BT_L2CAP_CONNECTED) {
 			LOG_WRN("%s()%d: invalid transition", func, line);
 		}
 		break;
@@ -932,8 +911,7 @@ void bt_l2cap_br_chan_set_state_debug(struct bt_l2cap_chan *chan,
 	br_chan->state = state;
 }
 #else
-void bt_l2cap_br_chan_set_state(struct bt_l2cap_chan *chan,
-			     bt_l2cap_chan_state_t state)
+void bt_l2cap_br_chan_set_state(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state)
 {
 	BR_CHAN(chan)->state = state;
 }
@@ -981,8 +959,7 @@ destroy:
 	}
 }
 
-static void l2cap_br_conn_req(struct bt_l2cap_br *l2cap, uint8_t ident,
-			      struct net_buf *buf)
+static void l2cap_br_conn_req(struct bt_l2cap_br *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan;
@@ -1012,8 +989,8 @@ static void l2cap_br_conn_req(struct bt_l2cap_br *l2cap, uint8_t ident,
 	 * Report security violation for non SDP channel without encryption when
 	 * remote supports SSP.
 	 */
-	if (server->sec_level != BT_SECURITY_L0 &&
-	    BT_FEAT_HOST_SSP(conn->br.features) && !conn->encrypt) {
+	if (server->sec_level != BT_SECURITY_L0 && BT_FEAT_HOST_SSP(conn->br.features) &&
+	    !conn->encrypt) {
 		result = BT_L2CAP_BR_ERR_SEC_BLOCK;
 		goto no_chan;
 	}
@@ -1092,8 +1069,8 @@ no_chan:
 	l2cap_br_send_conn_rsp(conn, scid, 0, ident, result);
 }
 
-static void l2cap_br_conf_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
-			      uint16_t len, struct net_buf *buf)
+static void l2cap_br_conf_rsp(struct bt_l2cap_br *l2cap, uint8_t ident, uint16_t len,
+			      struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan;
@@ -1133,8 +1110,7 @@ static void l2cap_br_conf_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
 		atomic_set_bit(br_chan->flags, L2CAP_FLAG_CONN_LCONF_DONE);
 
 		if (br_chan->state == BT_L2CAP_CONFIG &&
-		    atomic_test_bit(br_chan->flags,
-				    L2CAP_FLAG_CONN_RCONF_DONE)) {
+		    atomic_test_bit(br_chan->flags, L2CAP_FLAG_CONN_RCONF_DONE)) {
 			LOG_DBG("scid 0x%04x rx MTU %u dcid 0x%04x tx MTU %u", br_chan->rx.cid,
 				br_chan->rx.mtu, br_chan->tx.cid, br_chan->tx.mtu);
 
@@ -1164,8 +1140,7 @@ int bt_l2cap_br_server_register(struct bt_l2cap_server *server)
 
 	if (server->sec_level > BT_SECURITY_L4) {
 		return -EINVAL;
-	} else if (server->sec_level == BT_SECURITY_L0 &&
-		   server->psm != L2CAP_BR_PSM_SDP) {
+	} else if (server->sec_level == BT_SECURITY_L0 && server->psm != L2CAP_BR_PSM_SDP) {
 		server->sec_level = BT_SECURITY_L1;
 	}
 
@@ -1182,8 +1157,8 @@ int bt_l2cap_br_server_register(struct bt_l2cap_server *server)
 	return 0;
 }
 
-static void l2cap_br_send_reject(struct bt_conn *conn, uint8_t ident,
-				 uint16_t reason, void *data, uint8_t data_len)
+static void l2cap_br_send_reject(struct bt_conn *conn, uint8_t ident, uint16_t reason, void *data,
+				 uint8_t data_len)
 {
 	struct bt_l2cap_cmd_reject *rej;
 	struct bt_l2cap_sig_hdr *hdr;
@@ -1211,8 +1186,7 @@ static void l2cap_br_send_reject(struct bt_conn *conn, uint8_t ident,
 	l2cap_send(conn, BT_L2CAP_CID_BR_SIG, buf);
 }
 
-static uint16_t l2cap_br_conf_opt_mtu(struct bt_l2cap_chan *chan,
-				   struct net_buf *buf, size_t len)
+static uint16_t l2cap_br_conf_opt_mtu(struct bt_l2cap_chan *chan, struct net_buf *buf, size_t len)
 {
 	uint16_t mtu, result = BT_L2CAP_CONF_SUCCESS;
 	struct bt_l2cap_conf_opt_mtu *opt_mtu;
@@ -1241,8 +1215,8 @@ done:
 	return result;
 }
 
-static uint16_t l2cap_br_conf_opt_flush_timeout(struct bt_l2cap_chan *chan,
-						struct net_buf *buf, size_t len)
+static uint16_t l2cap_br_conf_opt_flush_timeout(struct bt_l2cap_chan *chan, struct net_buf *buf,
+						size_t len)
 {
 	uint16_t result = BT_L2CAP_CONF_SUCCESS;
 	struct bt_l2cap_conf_opt_flush_timeout *opt_to;
@@ -1263,8 +1237,7 @@ done:
 	return result;
 }
 
-static uint16_t l2cap_br_conf_opt_qos(struct bt_l2cap_chan *chan,
-				      struct net_buf *buf, size_t len)
+static uint16_t l2cap_br_conf_opt_qos(struct bt_l2cap_chan *chan, struct net_buf *buf, size_t len)
 {
 	uint16_t result = BT_L2CAP_CONF_SUCCESS;
 	struct bt_l2cap_conf_opt_qos *opt_qos;
@@ -1299,8 +1272,8 @@ done:
 	return result;
 }
 
-static uint16_t l2cap_br_conf_opt_ret_fc(struct bt_l2cap_chan *chan,
-					 struct net_buf *buf, size_t len)
+static uint16_t l2cap_br_conf_opt_ret_fc(struct bt_l2cap_chan *chan, struct net_buf *buf,
+					 size_t len)
 {
 	uint16_t result = BT_L2CAP_CONF_SUCCESS;
 	struct bt_l2cap_conf_opt_ret_fc *opt_ret_fc;
@@ -1325,8 +1298,7 @@ done:
 	return result;
 }
 
-static uint16_t l2cap_br_conf_opt_fcs(struct bt_l2cap_chan *chan,
-				      struct net_buf *buf, size_t len)
+static uint16_t l2cap_br_conf_opt_fcs(struct bt_l2cap_chan *chan, struct net_buf *buf, size_t len)
 {
 	uint16_t result = BT_L2CAP_CONF_SUCCESS;
 	struct bt_l2cap_conf_opt_fcs *opt_fcs;
@@ -1351,8 +1323,8 @@ done:
 	return result;
 }
 
-static void l2cap_br_conf_req(struct bt_l2cap_br *l2cap, uint8_t ident,
-			      uint16_t len, struct net_buf *buf)
+static void l2cap_br_conf_req(struct bt_l2cap_br *l2cap, uint8_t ident, uint16_t len,
+			      struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan;
@@ -1382,8 +1354,7 @@ static void l2cap_br_conf_req(struct bt_l2cap_br *l2cap, uint8_t ident,
 			.dcid = 0,
 		};
 
-		l2cap_br_send_reject(conn, ident, BT_L2CAP_REJ_INVALID_CID,
-				     &data, sizeof(data));
+		l2cap_br_send_reject(conn, ident, BT_L2CAP_REJ_INVALID_CID, &data, sizeof(data));
 		return;
 	}
 
@@ -1513,8 +1484,7 @@ send_rsp:
 	}
 }
 
-static struct bt_l2cap_br_chan *l2cap_br_remove_tx_cid(struct bt_conn *conn,
-						       uint16_t cid)
+static struct bt_l2cap_br_chan *l2cap_br_remove_tx_cid(struct bt_conn *conn, uint16_t cid)
 {
 	struct bt_l2cap_chan *chan;
 	sys_snode_t *prev = NULL;
@@ -1536,8 +1506,7 @@ static struct bt_l2cap_br_chan *l2cap_br_remove_tx_cid(struct bt_conn *conn,
 	return NULL;
 }
 
-static void l2cap_br_disconn_req(struct bt_l2cap_br *l2cap, uint8_t ident,
-				 struct net_buf *buf)
+static void l2cap_br_disconn_req(struct bt_l2cap_br *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_br_chan *chan;
@@ -1562,8 +1531,7 @@ static void l2cap_br_disconn_req(struct bt_l2cap_br *l2cap, uint8_t ident,
 
 		data.scid = req->scid;
 		data.dcid = req->dcid;
-		l2cap_br_send_reject(conn, ident, BT_L2CAP_REJ_INVALID_CID,
-				     &data, sizeof(data));
+		l2cap_br_send_reject(conn, ident, BT_L2CAP_REJ_INVALID_CID, &data, sizeof(data));
 		return;
 	}
 
@@ -1594,8 +1562,7 @@ static void l2cap_br_disconnected(struct bt_l2cap_chan *chan)
 
 	LOG_DBG("ch %p cid 0x%04x", br_chan, br_chan->rx.cid);
 
-	if (atomic_test_and_clear_bit(br_chan->flags,
-				      L2CAP_FLAG_SIG_INFO_PENDING)) {
+	if (atomic_test_and_clear_bit(br_chan->flags, L2CAP_FLAG_SIG_INFO_PENDING)) {
 		/* Cancel RTX work on signal channel.
 		 * Disconnected callback is always called from system workqueue
 		 * so this should always succeed.
@@ -1641,8 +1608,7 @@ int bt_l2cap_br_chan_disconnect(struct bt_l2cap_chan *chan)
 	return 0;
 }
 
-static void l2cap_br_disconn_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
-				 struct net_buf *buf)
+static void l2cap_br_disconn_rsp(struct bt_l2cap_br *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_br_chan *chan;
@@ -1668,8 +1634,7 @@ static void l2cap_br_disconn_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
 	bt_l2cap_br_chan_del(&chan->chan);
 }
 
-int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
-			     uint16_t psm)
+int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan, uint16_t psm)
 {
 	struct net_buf *buf;
 	struct bt_l2cap_sig_hdr *hdr;
@@ -1691,8 +1656,7 @@ int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
 
 	if (br_chan->required_sec_level > BT_SECURITY_L4) {
 		return -EINVAL;
-	} else if (br_chan->required_sec_level == BT_SECURITY_L0 &&
-		   psm != L2CAP_BR_PSM_SDP) {
+	} else if (br_chan->required_sec_level == BT_SECURITY_L0 && psm != L2CAP_BR_PSM_SDP) {
 		br_chan->required_sec_level = BT_SECURITY_L1;
 	}
 
@@ -1724,7 +1688,7 @@ int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
 		 * Authentication was triggered, wait with sending request on
 		 * connection security changed callback context.
 		 */
-		 return 0;
+		return 0;
 	case L2CAP_CONN_SECURITY_PASSED:
 		break;
 	case L2CAP_CONN_SECURITY_REJECT:
@@ -1749,8 +1713,7 @@ int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
 	return 0;
 }
 
-static void l2cap_br_conn_rsp(struct bt_l2cap_br *l2cap, uint8_t ident,
-			      struct net_buf *buf)
+static void l2cap_br_conn_rsp(struct bt_l2cap_br *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan;
@@ -1838,7 +1801,7 @@ int bt_l2cap_br_chan_send(struct bt_l2cap_chan *chan, struct net_buf *buf)
 }
 
 static void l2cap_br_sig_handle(struct bt_l2cap_br *l2cap, struct bt_l2cap_sig_hdr *hdr,
-				      struct net_buf *buf)
+				struct net_buf *buf)
 {
 	uint16_t len;
 	struct net_buf_simple_state state;
@@ -1874,8 +1837,8 @@ static void l2cap_br_sig_handle(struct bt_l2cap_br *l2cap, struct bt_l2cap_sig_h
 		break;
 	default:
 		LOG_WRN("Unknown/Unsupported L2CAP PDU code 0x%02x", hdr->code);
-		l2cap_br_send_reject(l2cap->chan.chan.conn, hdr->ident,
-					BT_L2CAP_REJ_NOT_UNDERSTOOD, NULL, 0);
+		l2cap_br_send_reject(l2cap->chan.chan.conn, hdr->ident, BT_L2CAP_REJ_NOT_UNDERSTOOD,
+				     NULL, 0);
 		break;
 	}
 
@@ -1937,8 +1900,7 @@ static void l2cap_br_conn_pend(struct bt_l2cap_chan *chan, uint8_t status)
 		l2cap_br_conn_req_reply(chan, BT_L2CAP_BR_ERR_SEC_BLOCK);
 
 		/* Release channel allocated to outgoing connection request */
-		if (atomic_test_bit(BR_CHAN(chan)->flags,
-				    L2CAP_FLAG_CONN_PENDING)) {
+		if (atomic_test_bit(BR_CHAN(chan)->flags, L2CAP_FLAG_CONN_PENDING)) {
 			l2cap_br_chan_cleanup(chan);
 		}
 
@@ -1960,8 +1922,7 @@ static void l2cap_br_conn_pend(struct bt_l2cap_chan *chan, uint8_t status)
 		 * local MTU segmentation.
 		 */
 		l2cap_br_conf(chan);
-	} else if (atomic_test_and_clear_bit(BR_CHAN(chan)->flags,
-					     L2CAP_FLAG_CONN_PENDING)) {
+	} else if (atomic_test_and_clear_bit(BR_CHAN(chan)->flags, L2CAP_FLAG_CONN_PENDING)) {
 		buf = bt_l2cap_create_pdu(&br_sig_pool, 0);
 
 		hdr = net_buf_add(buf, sizeof(*hdr));
@@ -1973,8 +1934,7 @@ static void l2cap_br_conn_pend(struct bt_l2cap_chan *chan, uint8_t status)
 		req->psm = sys_cpu_to_le16(BR_CHAN(chan)->psm);
 		req->scid = sys_cpu_to_le16(BR_CHAN(chan)->rx.cid);
 
-		l2cap_br_chan_send_req(BR_CHAN(chan), buf,
-				       L2CAP_BR_CONN_TIMEOUT);
+		l2cap_br_chan_send_req(BR_CHAN(chan), buf, L2CAP_BR_CONN_TIMEOUT);
 	}
 }
 
diff --git a/subsys/bluetooth/host/classic/l2cap_br_interface.h b/subsys/bluetooth/host/classic/l2cap_br_interface.h
index fd64ed80102..48282c1ccfb 100644
--- a/subsys/bluetooth/host/classic/l2cap_br_interface.h
+++ b/subsys/bluetooth/host/classic/l2cap_br_interface.h
@@ -9,15 +9,15 @@
 
 /* Need a name different than bt_l2cap_fixed_chan for a different section */
 struct bt_l2cap_br_fixed_chan {
-	uint16_t		cid;
+	uint16_t cid;
 	int (*accept)(struct bt_conn *conn, struct bt_l2cap_chan **chan);
 };
 
-#define BT_L2CAP_BR_CHANNEL_DEFINE(_name, _cid, _accept)		\
-	const STRUCT_SECTION_ITERABLE(bt_l2cap_br_fixed_chan, _name) = { \
-				.cid = _cid,			\
-				.accept = _accept,		\
-			}
+#define BT_L2CAP_BR_CHANNEL_DEFINE(_name, _cid, _accept)                                           \
+	const STRUCT_SECTION_ITERABLE(bt_l2cap_br_fixed_chan, _name) = {                           \
+		.cid = _cid,                                                                       \
+		.accept = _accept,                                                                 \
+	}
 
 /* Initialize BR/EDR L2CAP signal layer */
 void bt_l2cap_br_init(void);
@@ -29,15 +29,13 @@ void bt_l2cap_br_connected(struct bt_conn *conn);
 void bt_l2cap_br_disconnected(struct bt_conn *conn);
 
 /* Lookup BR/EDR L2CAP channel by Receiver CID */
-struct bt_l2cap_chan *bt_l2cap_br_lookup_rx_cid(struct bt_conn *conn,
-						uint16_t cid);
+struct bt_l2cap_chan *bt_l2cap_br_lookup_rx_cid(struct bt_conn *conn, uint16_t cid);
 
 /* Disconnects dynamic channel */
 int bt_l2cap_br_chan_disconnect(struct bt_l2cap_chan *chan);
 
 /* Make connection to peer psm server */
-int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
-			     uint16_t psm);
+int bt_l2cap_br_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan, uint16_t psm);
 
 /* Send packet data to connected peer */
 int bt_l2cap_br_chan_send(struct bt_l2cap_chan *chan, struct net_buf *buf);
@@ -47,8 +45,8 @@ int bt_l2cap_br_chan_send_cb(struct bt_l2cap_chan *chan, struct net_buf *buf, bt
 /* Send a single PDU over a BR channel.
  * Used by e.g. SMP.
  */
-int bt_l2cap_br_send_cb(struct bt_conn *conn, uint16_t cid, struct net_buf *buf,
-			bt_conn_tx_cb_t cb, void *user_data);
+int bt_l2cap_br_send_cb(struct bt_conn *conn, uint16_t cid, struct net_buf *buf, bt_conn_tx_cb_t cb,
+			void *user_data);
 
 /*
  * Handle security level changed on link passing HCI status of performed
@@ -60,13 +58,10 @@ void l2cap_br_encrypt_change(struct bt_conn *conn, uint8_t hci_status);
 void bt_l2cap_br_recv(struct bt_conn *conn, struct net_buf *buf);
 
 /* Pull HCI fragments from buffers intended for `conn` */
-struct net_buf *l2cap_br_data_pull(struct bt_conn *conn,
-				   size_t amount,
-				   size_t *length);
+struct net_buf *l2cap_br_data_pull(struct bt_conn *conn, size_t amount, size_t *length);
 
 /* Find L2CAP BR channel by using specific cid on specific connection */
-struct bt_l2cap_chan *bt_l2cap_br_lookup_tx_cid(struct bt_conn *conn,
-						uint16_t cid);
+struct bt_l2cap_chan *bt_l2cap_br_lookup_tx_cid(struct bt_conn *conn, uint16_t cid);
 
 /* Get remote supported fixed channels */
 uint8_t bt_l2cap_br_get_remote_fixed_chan(struct bt_conn *conn);
diff --git a/subsys/bluetooth/host/classic/l2cap_br_internal.h b/subsys/bluetooth/host/classic/l2cap_br_internal.h
index 92a760173ed..ae5e5b9366a 100644
--- a/subsys/bluetooth/host/classic/l2cap_br_internal.h
+++ b/subsys/bluetooth/host/classic/l2cap_br_internal.h
@@ -12,9 +12,9 @@
 #include <zephyr/sys/iterable_sections.h>
 #include "l2cap_br_interface.h"
 
-#define BT_L2CAP_CID_BR_SIG             0x0001
-#define BT_L2CAP_CID_BR_SMP             0x0007
-#define BT_L2CAP_PSM_RFCOMM             0x0003
+#define BT_L2CAP_CID_BR_SIG 0x0001
+#define BT_L2CAP_CID_BR_SMP 0x0007
+#define BT_L2CAP_PSM_RFCOMM 0x0003
 
 struct bt_l2cap_hdr {
 	uint16_t len;
@@ -22,19 +22,19 @@ struct bt_l2cap_hdr {
 } __packed;
 
 struct bt_l2cap_sig_hdr {
-	uint8_t  code;
-	uint8_t  ident;
+	uint8_t code;
+	uint8_t ident;
 	uint16_t len;
 } __packed;
 
-#define BT_L2CAP_REJ_NOT_UNDERSTOOD     0x0000
-#define BT_L2CAP_REJ_MTU_EXCEEDED       0x0001
-#define BT_L2CAP_REJ_INVALID_CID        0x0002
+#define BT_L2CAP_REJ_NOT_UNDERSTOOD 0x0000
+#define BT_L2CAP_REJ_MTU_EXCEEDED   0x0001
+#define BT_L2CAP_REJ_INVALID_CID    0x0002
 
-#define BT_L2CAP_CMD_REJECT             0x01
+#define BT_L2CAP_CMD_REJECT 0x01
 struct bt_l2cap_cmd_reject {
 	uint16_t reason;
-	uint8_t  data[0];
+	uint8_t data[0];
 } __packed;
 
 struct bt_l2cap_cmd_reject_cid_data {
@@ -42,26 +42,26 @@ struct bt_l2cap_cmd_reject_cid_data {
 	uint16_t dcid;
 } __packed;
 
-#define BT_L2CAP_CONN_REQ               0x02
+#define BT_L2CAP_CONN_REQ 0x02
 struct bt_l2cap_conn_req {
 	uint16_t psm;
 	uint16_t scid;
 } __packed;
 
 /* command statuses in response */
-#define BT_L2CAP_CS_NO_INFO             0x0000
-#define BT_L2CAP_CS_AUTHEN_PEND         0x0001
+#define BT_L2CAP_CS_NO_INFO     0x0000
+#define BT_L2CAP_CS_AUTHEN_PEND 0x0001
 
 /* valid results in conn response on BR/EDR */
-#define BT_L2CAP_BR_SUCCESS             0x0000
-#define BT_L2CAP_BR_PENDING             0x0001
-#define BT_L2CAP_BR_ERR_PSM_NOT_SUPP    0x0002
-#define BT_L2CAP_BR_ERR_SEC_BLOCK       0x0003
-#define BT_L2CAP_BR_ERR_NO_RESOURCES    0x0004
-#define BT_L2CAP_BR_ERR_INVALID_SCID    0x0006
-#define BT_L2CAP_BR_ERR_SCID_IN_USE     0x0007
-
-#define BT_L2CAP_CONN_RSP               0x03
+#define BT_L2CAP_BR_SUCCESS          0x0000
+#define BT_L2CAP_BR_PENDING          0x0001
+#define BT_L2CAP_BR_ERR_PSM_NOT_SUPP 0x0002
+#define BT_L2CAP_BR_ERR_SEC_BLOCK    0x0003
+#define BT_L2CAP_BR_ERR_NO_RESOURCES 0x0004
+#define BT_L2CAP_BR_ERR_INVALID_SCID 0x0006
+#define BT_L2CAP_BR_ERR_SCID_IN_USE  0x0007
+
+#define BT_L2CAP_CONN_RSP 0x03
 struct bt_l2cap_conn_rsp {
 	uint16_t dcid;
 	uint16_t scid;
@@ -69,29 +69,29 @@ struct bt_l2cap_conn_rsp {
 	uint16_t status;
 } __packed;
 
-#define BT_L2CAP_CONF_SUCCESS           0x0000
-#define BT_L2CAP_CONF_UNACCEPT          0x0001
-#define BT_L2CAP_CONF_REJECT            0x0002
-#define BT_L2CAP_CONF_UNKNOWN_OPT       0x0003
-#define BT_L2CAP_CONF_PENDING           0x0004
-#define BT_L2CAP_CONF_FLOW_SPEC_REJECT  0x0005
+#define BT_L2CAP_CONF_SUCCESS          0x0000
+#define BT_L2CAP_CONF_UNACCEPT         0x0001
+#define BT_L2CAP_CONF_REJECT           0x0002
+#define BT_L2CAP_CONF_UNKNOWN_OPT      0x0003
+#define BT_L2CAP_CONF_PENDING          0x0004
+#define BT_L2CAP_CONF_FLOW_SPEC_REJECT 0x0005
 
-#define BT_L2CAP_CONF_FLAGS_C           BIT(0)
-#define BT_L2CAP_CONF_FLAGS_MASK        BT_L2CAP_CONF_FLAGS_C
+#define BT_L2CAP_CONF_FLAGS_C    BIT(0)
+#define BT_L2CAP_CONF_FLAGS_MASK BT_L2CAP_CONF_FLAGS_C
 
-#define BT_L2CAP_CONF_REQ               0x04
+#define BT_L2CAP_CONF_REQ 0x04
 struct bt_l2cap_conf_req {
 	uint16_t dcid;
 	uint16_t flags;
-	uint8_t  data[0];
+	uint8_t data[0];
 } __packed;
 
-#define BT_L2CAP_CONF_RSP               0x05
+#define BT_L2CAP_CONF_RSP 0x05
 struct bt_l2cap_conf_rsp {
 	uint16_t scid;
 	uint16_t flags;
 	uint16_t result;
-	uint8_t  data[0];
+	uint8_t data[0];
 } __packed;
 
 /* Option type used by MTU config request data */
@@ -104,8 +104,8 @@ struct bt_l2cap_conf_rsp {
 #define BT_L2CAP_CONF_OPT_EXT_WIN_SIZE  0x07
 
 /* Options bits selecting most significant bit (hint) in type field */
-#define BT_L2CAP_CONF_HINT              0x80
-#define BT_L2CAP_CONF_MASK              0x7f
+#define BT_L2CAP_CONF_HINT 0x80
+#define BT_L2CAP_CONF_MASK 0x7f
 
 struct bt_l2cap_conf_opt {
 	uint8_t type;
@@ -121,9 +121,9 @@ struct bt_l2cap_conf_opt_flush_timeout {
 	uint16_t timeout;
 } __packed;
 
-#define BT_L2CAP_QOS_TYPE_NO_TRAFFIC    0x00
-#define BT_L2CAP_QOS_TYPE_BEST_EFFORT   0x01
-#define BT_L2CAP_QOS_TYPE_GUARANTEED    0x02
+#define BT_L2CAP_QOS_TYPE_NO_TRAFFIC  0x00
+#define BT_L2CAP_QOS_TYPE_BEST_EFFORT 0x01
+#define BT_L2CAP_QOS_TYPE_GUARANTEED  0x02
 struct bt_l2cap_conf_opt_qos {
 	uint8_t flags;
 	uint8_t service_type;
@@ -148,41 +148,41 @@ struct bt_l2cap_conf_opt_ret_fc {
 	uint16_t mps;
 } __packed;
 
-#define BT_L2CAP_FCS_TYPE_NO         0x00
-#define BT_L2CAP_FCS_TYPE_16BIT      0x01
+#define BT_L2CAP_FCS_TYPE_NO    0x00
+#define BT_L2CAP_FCS_TYPE_16BIT 0x01
 struct bt_l2cap_conf_opt_fcs {
 	uint8_t type;
 } __packed;
 
-#define BT_L2CAP_DISCONN_REQ            0x06
+#define BT_L2CAP_DISCONN_REQ 0x06
 struct bt_l2cap_disconn_req {
 	uint16_t dcid;
 	uint16_t scid;
 } __packed;
 
-#define BT_L2CAP_DISCONN_RSP            0x07
+#define BT_L2CAP_DISCONN_RSP 0x07
 struct bt_l2cap_disconn_rsp {
 	uint16_t dcid;
 	uint16_t scid;
 } __packed;
 
-#define BT_L2CAP_INFO_FEAT_MASK         0x0002
-#define BT_L2CAP_INFO_FIXED_CHAN        0x0003
+#define BT_L2CAP_INFO_FEAT_MASK  0x0002
+#define BT_L2CAP_INFO_FIXED_CHAN 0x0003
 
-#define BT_L2CAP_INFO_REQ               0x0a
+#define BT_L2CAP_INFO_REQ 0x0a
 struct bt_l2cap_info_req {
 	uint16_t type;
 } __packed;
 
 /* info result */
-#define BT_L2CAP_INFO_SUCCESS           0x0000
-#define BT_L2CAP_INFO_NOTSUPP           0x0001
+#define BT_L2CAP_INFO_SUCCESS 0x0000
+#define BT_L2CAP_INFO_NOTSUPP 0x0001
 
-#define BT_L2CAP_INFO_RSP               0x0b
+#define BT_L2CAP_INFO_RSP 0x0b
 struct bt_l2cap_info_rsp {
 	uint16_t type;
 	uint16_t result;
-	uint8_t  data[0];
+	uint8_t data[0];
 } __packed;
 
 #define BR_CHAN(_ch) CONTAINER_OF(_ch, struct bt_l2cap_br_chan, chan)
@@ -200,20 +200,16 @@ void bt_l2cap_br_chan_del(struct bt_l2cap_chan *chan);
 const char *bt_l2cap_chan_state_str(bt_l2cap_chan_state_t state);
 
 #if defined(CONFIG_BT_L2CAP_LOG_LEVEL_DBG)
-void bt_l2cap_br_chan_set_state_debug(struct bt_l2cap_chan *chan,
-				   bt_l2cap_chan_state_t state,
-				   const char *func, int line);
-#define bt_l2cap_br_chan_set_state(_chan, _state) \
+void bt_l2cap_br_chan_set_state_debug(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state,
+				      const char *func, int line);
+#define bt_l2cap_br_chan_set_state(_chan, _state)                                                  \
 	bt_l2cap_br_chan_set_state_debug(_chan, _state, __func__, __LINE__)
 #else
-void bt_l2cap_br_chan_set_state(struct bt_l2cap_chan *chan,
-			     bt_l2cap_chan_state_t state);
+void bt_l2cap_br_chan_set_state(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state);
 #endif /* CONFIG_BT_L2CAP_LOG_LEVEL_DBG */
 
 /* Prepare an L2CAP PDU to be sent over a connection */
-struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool,
-					    size_t reserve,
+struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool, size_t reserve,
 					    k_timeout_t timeout);
 
-#define bt_l2cap_create_pdu(_pool, _reserve) \
-	bt_l2cap_create_pdu_timeout(_pool, _reserve, K_FOREVER)
+#define bt_l2cap_create_pdu(_pool, _reserve) bt_l2cap_create_pdu_timeout(_pool, _reserve, K_FOREVER)
diff --git a/subsys/bluetooth/host/classic/rfcomm.c b/subsys/bluetooth/host/classic/rfcomm.c
index 45e2a50b7e1..564d6e9304c 100644
--- a/subsys/bluetooth/host/classic/rfcomm.c
+++ b/subsys/bluetooth/host/classic/rfcomm.c
@@ -30,77 +30,66 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(bt_rfcomm);
 
-#define RFCOMM_CHANNEL_START	0x01
-#define RFCOMM_CHANNEL_END	0x1e
+#define RFCOMM_CHANNEL_START 0x01
+#define RFCOMM_CHANNEL_END   0x1e
 
-#define RFCOMM_MIN_MTU		BT_RFCOMM_SIG_MIN_MTU
-#define RFCOMM_DEFAULT_MTU	127
+#define RFCOMM_MIN_MTU     BT_RFCOMM_SIG_MIN_MTU
+#define RFCOMM_DEFAULT_MTU 127
 
-#define RFCOMM_MAX_CREDITS		(BT_BUF_ACL_RX_COUNT - 1)
-#define RFCOMM_CREDITS_THRESHOLD	(RFCOMM_MAX_CREDITS / 2)
-#define RFCOMM_DEFAULT_CREDIT		RFCOMM_MAX_CREDITS
+#define RFCOMM_MAX_CREDITS       (BT_BUF_ACL_RX_COUNT - 1)
+#define RFCOMM_CREDITS_THRESHOLD (RFCOMM_MAX_CREDITS / 2)
+#define RFCOMM_DEFAULT_CREDIT    RFCOMM_MAX_CREDITS
 
-#define RFCOMM_CONN_TIMEOUT     K_SECONDS(60)
-#define RFCOMM_DISC_TIMEOUT     K_SECONDS(20)
-#define RFCOMM_IDLE_TIMEOUT     K_SECONDS(2)
+#define RFCOMM_CONN_TIMEOUT K_SECONDS(60)
+#define RFCOMM_DISC_TIMEOUT K_SECONDS(20)
+#define RFCOMM_IDLE_TIMEOUT K_SECONDS(2)
 
-#define DLC_RTX(_w) CONTAINER_OF(k_work_delayable_from_work(_w), \
-				 struct bt_rfcomm_dlc, rtx_work)
-#define SESSION_RTX(_w) CONTAINER_OF(k_work_delayable_from_work(_w), \
-				     struct bt_rfcomm_session, rtx_work)
+#define DLC_RTX(_w) CONTAINER_OF(k_work_delayable_from_work(_w), struct bt_rfcomm_dlc, rtx_work)
+#define SESSION_RTX(_w)                                                                            \
+	CONTAINER_OF(k_work_delayable_from_work(_w), struct bt_rfcomm_session, rtx_work)
 
 static struct bt_rfcomm_server *servers;
 
 /* Pool for dummy buffers to wake up the tx threads */
 NET_BUF_POOL_DEFINE(dummy_pool, CONFIG_BT_MAX_CONN, 0, 0, NULL);
 
-#define RFCOMM_SESSION(_ch) CONTAINER_OF(_ch, \
-					 struct bt_rfcomm_session, br_chan.chan)
+#define RFCOMM_SESSION(_ch) CONTAINER_OF(_ch, struct bt_rfcomm_session, br_chan.chan)
 
 static struct bt_rfcomm_session bt_rfcomm_pool[CONFIG_BT_MAX_CONN];
 
 /* reversed, 8-bit, poly=0x07 */
 static const uint8_t rfcomm_crc_table[256] = {
-	0x00, 0x91, 0xe3, 0x72, 0x07, 0x96, 0xe4, 0x75,
-	0x0e, 0x9f, 0xed, 0x7c, 0x09, 0x98, 0xea, 0x7b,
-	0x1c, 0x8d, 0xff, 0x6e, 0x1b, 0x8a, 0xf8, 0x69,
-	0x12, 0x83, 0xf1, 0x60, 0x15, 0x84, 0xf6, 0x67,
-
-	0x38, 0xa9, 0xdb, 0x4a, 0x3f, 0xae, 0xdc, 0x4d,
-	0x36, 0xa7, 0xd5, 0x44, 0x31, 0xa0, 0xd2, 0x43,
-	0x24, 0xb5, 0xc7, 0x56, 0x23, 0xb2, 0xc0, 0x51,
-	0x2a, 0xbb, 0xc9, 0x58, 0x2d, 0xbc, 0xce, 0x5f,
-
-	0x70, 0xe1, 0x93, 0x02, 0x77, 0xe6, 0x94, 0x05,
-	0x7e, 0xef, 0x9d, 0x0c, 0x79, 0xe8, 0x9a, 0x0b,
-	0x6c, 0xfd, 0x8f, 0x1e, 0x6b, 0xfa, 0x88, 0x19,
-	0x62, 0xf3, 0x81, 0x10, 0x65, 0xf4, 0x86, 0x17,
-
-	0x48, 0xd9, 0xab, 0x3a, 0x4f, 0xde, 0xac, 0x3d,
-	0x46, 0xd7, 0xa5, 0x34, 0x41, 0xd0, 0xa2, 0x33,
-	0x54, 0xc5, 0xb7, 0x26, 0x53, 0xc2, 0xb0, 0x21,
-	0x5a, 0xcb, 0xb9, 0x28, 0x5d, 0xcc, 0xbe, 0x2f,
-
-	0xe0, 0x71, 0x03, 0x92, 0xe7, 0x76, 0x04, 0x95,
-	0xee, 0x7f, 0x0d, 0x9c, 0xe9, 0x78, 0x0a, 0x9b,
-	0xfc, 0x6d, 0x1f, 0x8e, 0xfb, 0x6a, 0x18, 0x89,
-	0xf2, 0x63, 0x11, 0x80, 0xf5, 0x64, 0x16, 0x87,
-
-	0xd8, 0x49, 0x3b, 0xaa, 0xdf, 0x4e, 0x3c, 0xad,
-	0xd6, 0x47, 0x35, 0xa4, 0xd1, 0x40, 0x32, 0xa3,
-	0xc4, 0x55, 0x27, 0xb6, 0xc3, 0x52, 0x20, 0xb1,
-	0xca, 0x5b, 0x29, 0xb8, 0xcd, 0x5c, 0x2e, 0xbf,
-
-	0x90, 0x01, 0x73, 0xe2, 0x97, 0x06, 0x74, 0xe5,
-	0x9e, 0x0f, 0x7d, 0xec, 0x99, 0x08, 0x7a, 0xeb,
-	0x8c, 0x1d, 0x6f, 0xfe, 0x8b, 0x1a, 0x68, 0xf9,
-	0x82, 0x13, 0x61, 0xf0, 0x85, 0x14, 0x66, 0xf7,
-
-	0xa8, 0x39, 0x4b, 0xda, 0xaf, 0x3e, 0x4c, 0xdd,
-	0xa6, 0x37, 0x45, 0xd4, 0xa1, 0x30, 0x42, 0xd3,
-	0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22, 0x50, 0xc1,
-	0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf
-};
+	0x00, 0x91, 0xe3, 0x72, 0x07, 0x96, 0xe4, 0x75, 0x0e, 0x9f, 0xed,
+	0x7c, 0x09, 0x98, 0xea, 0x7b, 0x1c, 0x8d, 0xff, 0x6e, 0x1b, 0x8a,
+	0xf8, 0x69, 0x12, 0x83, 0xf1, 0x60, 0x15, 0x84, 0xf6, 0x67,
+
+	0x38, 0xa9, 0xdb, 0x4a, 0x3f, 0xae, 0xdc, 0x4d, 0x36, 0xa7, 0xd5,
+	0x44, 0x31, 0xa0, 0xd2, 0x43, 0x24, 0xb5, 0xc7, 0x56, 0x23, 0xb2,
+	0xc0, 0x51, 0x2a, 0xbb, 0xc9, 0x58, 0x2d, 0xbc, 0xce, 0x5f,
+
+	0x70, 0xe1, 0x93, 0x02, 0x77, 0xe6, 0x94, 0x05, 0x7e, 0xef, 0x9d,
+	0x0c, 0x79, 0xe8, 0x9a, 0x0b, 0x6c, 0xfd, 0x8f, 0x1e, 0x6b, 0xfa,
+	0x88, 0x19, 0x62, 0xf3, 0x81, 0x10, 0x65, 0xf4, 0x86, 0x17,
+
+	0x48, 0xd9, 0xab, 0x3a, 0x4f, 0xde, 0xac, 0x3d, 0x46, 0xd7, 0xa5,
+	0x34, 0x41, 0xd0, 0xa2, 0x33, 0x54, 0xc5, 0xb7, 0x26, 0x53, 0xc2,
+	0xb0, 0x21, 0x5a, 0xcb, 0xb9, 0x28, 0x5d, 0xcc, 0xbe, 0x2f,
+
+	0xe0, 0x71, 0x03, 0x92, 0xe7, 0x76, 0x04, 0x95, 0xee, 0x7f, 0x0d,
+	0x9c, 0xe9, 0x78, 0x0a, 0x9b, 0xfc, 0x6d, 0x1f, 0x8e, 0xfb, 0x6a,
+	0x18, 0x89, 0xf2, 0x63, 0x11, 0x80, 0xf5, 0x64, 0x16, 0x87,
+
+	0xd8, 0x49, 0x3b, 0xaa, 0xdf, 0x4e, 0x3c, 0xad, 0xd6, 0x47, 0x35,
+	0xa4, 0xd1, 0x40, 0x32, 0xa3, 0xc4, 0x55, 0x27, 0xb6, 0xc3, 0x52,
+	0x20, 0xb1, 0xca, 0x5b, 0x29, 0xb8, 0xcd, 0x5c, 0x2e, 0xbf,
+
+	0x90, 0x01, 0x73, 0xe2, 0x97, 0x06, 0x74, 0xe5, 0x9e, 0x0f, 0x7d,
+	0xec, 0x99, 0x08, 0x7a, 0xeb, 0x8c, 0x1d, 0x6f, 0xfe, 0x8b, 0x1a,
+	0x68, 0xf9, 0x82, 0x13, 0x61, 0xf0, 0x85, 0x14, 0x66, 0xf7,
+
+	0xa8, 0x39, 0x4b, 0xda, 0xaf, 0x3e, 0x4c, 0xdd, 0xa6, 0x37, 0x45,
+	0xd4, 0xa1, 0x30, 0x42, 0xd3, 0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22,
+	0x50, 0xc1, 0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf};
 
 static uint8_t rfcomm_calc_fcs(uint16_t len, const uint8_t *data)
 {
@@ -114,8 +103,7 @@ static uint8_t rfcomm_calc_fcs(uint16_t len, const uint8_t *data)
 	return (0xff - fcs);
 }
 
-static bool rfcomm_check_fcs(uint16_t len, const uint8_t *data,
-			     uint8_t recvd_fcs)
+static bool rfcomm_check_fcs(uint16_t len, const uint8_t *data, uint8_t recvd_fcs)
 {
 	uint8_t fcs = 0xff;
 
@@ -130,8 +118,7 @@ static bool rfcomm_check_fcs(uint16_t len, const uint8_t *data,
 	return (fcs == 0xcf);
 }
 
-static struct bt_rfcomm_dlc *rfcomm_dlcs_lookup_dlci(struct bt_rfcomm_dlc *dlcs,
-						     uint8_t dlci)
+static struct bt_rfcomm_dlc *rfcomm_dlcs_lookup_dlci(struct bt_rfcomm_dlc *dlcs, uint8_t dlci)
 {
 	for (; dlcs; dlcs = dlcs->_next) {
 		if (dlcs->dlci == dlci) {
@@ -142,8 +129,7 @@ static struct bt_rfcomm_dlc *rfcomm_dlcs_lookup_dlci(struct bt_rfcomm_dlc *dlcs,
 	return NULL;
 }
 
-static struct bt_rfcomm_dlc *rfcomm_dlcs_remove_dlci(struct bt_rfcomm_dlc *dlcs,
-						     uint8_t dlci)
+static struct bt_rfcomm_dlc *rfcomm_dlcs_remove_dlci(struct bt_rfcomm_dlc *dlcs, uint8_t dlci)
 {
 	struct bt_rfcomm_dlc *tmp;
 
@@ -181,8 +167,7 @@ static struct bt_rfcomm_server *rfcomm_server_lookup_channel(uint8_t channel)
 	return NULL;
 }
 
-static struct bt_rfcomm_session *
-rfcomm_sessions_lookup_bt_conn(struct bt_conn *conn)
+static struct bt_rfcomm_session *rfcomm_sessions_lookup_bt_conn(struct bt_conn *conn)
 {
 	int i;
 
@@ -199,8 +184,8 @@ rfcomm_sessions_lookup_bt_conn(struct bt_conn *conn)
 
 int bt_rfcomm_server_register(struct bt_rfcomm_server *server)
 {
-	if (server->channel < RFCOMM_CHANNEL_START ||
-	    server->channel > RFCOMM_CHANNEL_END || !server->accept) {
+	if (server->channel < RFCOMM_CHANNEL_START || server->channel > RFCOMM_CHANNEL_END ||
+	    !server->accept) {
 		return -EINVAL;
 	}
 
@@ -218,8 +203,7 @@ int bt_rfcomm_server_register(struct bt_rfcomm_server *server)
 	return 0;
 }
 
-static void rfcomm_dlc_tx_give_credits(struct bt_rfcomm_dlc *dlc,
-				       uint8_t credits)
+static void rfcomm_dlc_tx_give_credits(struct bt_rfcomm_dlc *dlc, uint8_t credits)
 {
 	LOG_DBG("dlc %p credits %u", dlc, credits);
 
@@ -306,12 +290,11 @@ struct net_buf *bt_rfcomm_create_pdu(struct net_buf_pool *pool)
 	 * data
 	 */
 	return bt_conn_create_pdu(pool,
-				  sizeof(struct bt_l2cap_hdr) +
-				  sizeof(struct bt_rfcomm_hdr) + 1);
+				  sizeof(struct bt_l2cap_hdr) + sizeof(struct bt_rfcomm_hdr) + 1);
 }
 
 static int rfcomm_send_cb(struct bt_rfcomm_session *session, struct net_buf *buf,
-				 bt_conn_tx_cb_t cb, void *user_data)
+			  bt_conn_tx_cb_t cb, void *user_data)
 {
 	int err;
 
@@ -380,9 +363,8 @@ static void rfcomm_session_disconnect(struct bt_rfcomm_session *session)
 	k_work_reschedule(&session->rtx_work, RFCOMM_DISC_TIMEOUT);
 }
 
-static struct net_buf *rfcomm_make_uih_msg(struct bt_rfcomm_session *session,
-					   uint8_t cr, uint8_t type,
-					   uint8_t len)
+static struct net_buf *rfcomm_make_uih_msg(struct bt_rfcomm_session *session, uint8_t cr,
+					   uint8_t type, uint8_t len)
 {
 	struct bt_rfcomm_hdr *hdr;
 	struct bt_rfcomm_msg_hdr *msg_hdr;
@@ -411,9 +393,8 @@ static void rfcomm_connected(struct bt_l2cap_chan *chan)
 	LOG_DBG("Session %p", session);
 
 	/* Need to include UIH header and FCS*/
-	session->mtu = MIN(session->br_chan.rx.mtu,
-			   session->br_chan.tx.mtu) -
-			   BT_RFCOMM_HDR_SIZE + BT_RFCOMM_FCS_SIZE;
+	session->mtu = MIN(session->br_chan.rx.mtu, session->br_chan.tx.mtu) - BT_RFCOMM_HDR_SIZE +
+		       BT_RFCOMM_FCS_SIZE;
 
 	if (session->state == BT_RFCOMM_STATE_CONNECTING) {
 		rfcomm_send_sabm(session, 0);
@@ -443,10 +424,8 @@ static void rfcomm_dlc_rtx_timeout(struct k_work *work)
 	rfcomm_session_disconnect(session);
 }
 
-static void rfcomm_dlc_init(struct bt_rfcomm_dlc *dlc,
-			    struct bt_rfcomm_session *session,
-			    uint8_t dlci,
-			    bt_rfcomm_role_t role)
+static void rfcomm_dlc_init(struct bt_rfcomm_dlc *dlc, struct bt_rfcomm_session *session,
+			    uint8_t dlci, bt_rfcomm_role_t role)
 {
 	LOG_DBG("dlc %p", dlc);
 
@@ -464,8 +443,7 @@ static void rfcomm_dlc_init(struct bt_rfcomm_dlc *dlc,
 	session->dlcs = dlc;
 }
 
-static struct bt_rfcomm_dlc *rfcomm_dlc_accept(struct bt_rfcomm_session *session,
-					       uint8_t dlci)
+static struct bt_rfcomm_dlc *rfcomm_dlc_accept(struct bt_rfcomm_session *session, uint8_t dlci)
 {
 	struct bt_rfcomm_server *server;
 	struct bt_rfcomm_dlc *dlc;
@@ -558,7 +536,7 @@ static void rfcomm_sent(struct bt_conn *conn, void *user_data, int err)
 
 	LOG_DBG("conn %p", conn);
 
-	if (user_data == NULL)	{
+	if (user_data == NULL) {
 		return;
 	}
 
@@ -655,15 +633,13 @@ static int rfcomm_send_ua(struct bt_rfcomm_session *session, uint8_t dlci)
 	return rfcomm_send(session, buf);
 }
 
-static int rfcomm_send_msc(struct bt_rfcomm_dlc *dlc, uint8_t cr,
-			   uint8_t v24_signal)
+static int rfcomm_send_msc(struct bt_rfcomm_dlc *dlc, uint8_t cr, uint8_t v24_signal)
 {
 	struct bt_rfcomm_msc *msc;
 	struct net_buf *buf;
 	uint8_t fcs;
 
-	buf = rfcomm_make_uih_msg(dlc->session, cr, BT_RFCOMM_MSC,
-				  sizeof(*msc));
+	buf = rfcomm_make_uih_msg(dlc->session, cr, BT_RFCOMM_MSC, sizeof(*msc));
 
 	msc = net_buf_add(buf, sizeof(*msc));
 	/* cr bit should be always 1 in MSC */
@@ -676,15 +652,13 @@ static int rfcomm_send_msc(struct bt_rfcomm_dlc *dlc, uint8_t cr,
 	return rfcomm_send(dlc->session, buf);
 }
 
-static int rfcomm_send_rls(struct bt_rfcomm_dlc *dlc, uint8_t cr,
-			   uint8_t line_status)
+static int rfcomm_send_rls(struct bt_rfcomm_dlc *dlc, uint8_t cr, uint8_t line_status)
 {
 	struct bt_rfcomm_rls *rls;
 	struct net_buf *buf;
 	uint8_t fcs;
 
-	buf = rfcomm_make_uih_msg(dlc->session, cr, BT_RFCOMM_RLS,
-				  sizeof(*rls));
+	buf = rfcomm_make_uih_msg(dlc->session, cr, BT_RFCOMM_RLS, sizeof(*rls));
 
 	rls = net_buf_add(buf, sizeof(*rls));
 	/* cr bit should be always 1 in RLS */
@@ -697,8 +671,7 @@ static int rfcomm_send_rls(struct bt_rfcomm_dlc *dlc, uint8_t cr,
 	return rfcomm_send(dlc->session, buf);
 }
 
-static int rfcomm_send_rpn(struct bt_rfcomm_session *session, uint8_t cr,
-			   struct bt_rfcomm_rpn *rpn)
+static int rfcomm_send_rpn(struct bt_rfcomm_session *session, uint8_t cr, struct bt_rfcomm_rpn *rpn)
 {
 	struct net_buf *buf;
 	uint8_t fcs;
@@ -713,8 +686,8 @@ static int rfcomm_send_rpn(struct bt_rfcomm_session *session, uint8_t cr,
 	return rfcomm_send(session, buf);
 }
 
-static int rfcomm_send_test(struct bt_rfcomm_session *session, uint8_t cr,
-			    uint8_t *pattern, uint8_t len)
+static int rfcomm_send_test(struct bt_rfcomm_session *session, uint8_t cr, uint8_t *pattern,
+			    uint8_t len)
 {
 	struct net_buf *buf;
 	uint8_t fcs;
@@ -734,8 +707,7 @@ static int rfcomm_send_nsc(struct bt_rfcomm_session *session, uint8_t cmd_type)
 	struct net_buf *buf;
 	uint8_t fcs;
 
-	buf = rfcomm_make_uih_msg(session, BT_RFCOMM_MSG_RESP_CR,
-				  BT_RFCOMM_NSC, sizeof(cmd_type));
+	buf = rfcomm_make_uih_msg(session, BT_RFCOMM_MSG_RESP_CR, BT_RFCOMM_NSC, sizeof(cmd_type));
 
 	net_buf_add_u8(buf, cmd_type);
 
@@ -795,10 +767,8 @@ static void rfcomm_dlc_connected(struct bt_rfcomm_dlc *dlc)
 	k_work_cancel_delayable(&dlc->rtx_work);
 
 	k_fifo_init(&dlc->tx_queue);
-	k_thread_create(&dlc->tx_thread, dlc->stack,
-			K_KERNEL_STACK_SIZEOF(dlc->stack),
-			rfcomm_dlc_tx_thread, dlc, NULL, NULL, K_PRIO_COOP(7),
-			0, K_NO_WAIT);
+	k_thread_create(&dlc->tx_thread, dlc->stack, K_KERNEL_STACK_SIZEOF(dlc->stack),
+			rfcomm_dlc_tx_thread, dlc, NULL, NULL, K_PRIO_COOP(7), 0, K_NO_WAIT);
 	k_thread_name_set(&dlc->tx_thread, "BT DLC");
 
 	if (dlc->ops && dlc->ops->connected) {
@@ -876,8 +846,7 @@ static int rfcomm_dlc_close(struct bt_rfcomm_dlc *dlc)
 		/* Queue a dummy buffer to wake up and stop the
 		 * tx thread.
 		 */
-		k_fifo_put(&dlc->tx_queue,
-			    net_buf_alloc(&dummy_pool, K_NO_WAIT));
+		k_fifo_put(&dlc->tx_queue, net_buf_alloc(&dummy_pool, K_NO_WAIT));
 
 		/* There could be a writer waiting for credits so return a
 		 * dummy credit to wake it up.
@@ -993,8 +962,7 @@ static int rfcomm_send_credit(struct bt_rfcomm_dlc *dlc, uint8_t credits)
 	hdr = net_buf_add(buf, sizeof(*hdr));
 	cr = BT_RFCOMM_UIH_CR(dlc->session->role);
 	hdr->address = BT_RFCOMM_SET_ADDR(dlc->dlci, cr);
-	hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UIH,
-					  BT_RFCOMM_PF_UIH_CREDIT);
+	hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UIH, BT_RFCOMM_PF_UIH_CREDIT);
 	hdr->length = BT_RFCOMM_SET_LEN_8(0);
 	net_buf_add_u8(buf, credits);
 	fcs = rfcomm_calc_fcs(BT_RFCOMM_FCS_LEN_UIH, buf->data);
@@ -1095,8 +1063,7 @@ static void rfcomm_handle_dm(struct bt_rfcomm_session *session, uint8_t dlci)
 	rfcomm_session_disconnect(session);
 }
 
-static void rfcomm_handle_msc(struct bt_rfcomm_session *session,
-			      struct net_buf *buf, uint8_t cr)
+static void rfcomm_handle_msc(struct bt_rfcomm_session *session, struct net_buf *buf, uint8_t cr)
 {
 	struct bt_rfcomm_msc *msc = (void *)buf->data;
 	struct bt_rfcomm_dlc *dlc;
@@ -1135,8 +1102,7 @@ static void rfcomm_handle_msc(struct bt_rfcomm_session *session,
 	rfcomm_send_msc(dlc, BT_RFCOMM_MSG_RESP_CR, msc->v24_signal);
 }
 
-static void rfcomm_handle_rls(struct bt_rfcomm_session *session,
-			      struct net_buf *buf, uint8_t cr)
+static void rfcomm_handle_rls(struct bt_rfcomm_session *session, struct net_buf *buf, uint8_t cr)
 {
 	struct bt_rfcomm_rls *rls = (void *)buf->data;
 	uint8_t dlci = BT_RFCOMM_GET_DLCI(rls->dlci);
@@ -1158,8 +1124,7 @@ static void rfcomm_handle_rls(struct bt_rfcomm_session *session,
 	rfcomm_send_rls(dlc, BT_RFCOMM_MSG_RESP_CR, rls->line_status);
 }
 
-static void rfcomm_handle_rpn(struct bt_rfcomm_session *session,
-			      struct net_buf *buf, uint8_t cr)
+static void rfcomm_handle_rpn(struct bt_rfcomm_session *session, struct net_buf *buf, uint8_t cr)
 {
 	struct bt_rfcomm_rpn default_rpn, *rpn = (void *)buf->data;
 	uint8_t dlci = BT_RFCOMM_GET_DLCI(rpn->dlci);
@@ -1196,16 +1161,13 @@ static void rfcomm_handle_rpn(struct bt_rfcomm_session *session,
 	data_bits = BT_RFCOMM_RPN_DATA_BITS_8;
 	stop_bits = BT_RFCOMM_RPN_STOP_BITS_1;
 	parity_bits = BT_RFCOMM_RPN_PARITY_NONE;
-	default_rpn.line_settings = BT_RFCOMM_SET_LINE_SETTINGS(data_bits,
-								stop_bits,
-								parity_bits);
+	default_rpn.line_settings = BT_RFCOMM_SET_LINE_SETTINGS(data_bits, stop_bits, parity_bits);
 	default_rpn.param_mask = sys_cpu_to_le16(BT_RFCOMM_RPN_PARAM_MASK_ALL);
 
 	rfcomm_send_rpn(session, BT_RFCOMM_MSG_RESP_CR, &default_rpn);
 }
 
-static void rfcomm_handle_pn(struct bt_rfcomm_session *session,
-			     struct net_buf *buf, uint8_t cr)
+static void rfcomm_handle_pn(struct bt_rfcomm_session *session, struct net_buf *buf, uint8_t cr)
 {
 	struct bt_rfcomm_pn *pn = (void *)buf->data;
 	struct bt_rfcomm_dlc *dlc;
@@ -1297,8 +1259,7 @@ static void rfcomm_handle_disc(struct bt_rfcomm_session *session, uint8_t dlci)
 
 		if (!session->dlcs) {
 			/* Start a session idle timer */
-			k_work_reschedule(&dlc->session->rtx_work,
-					  RFCOMM_IDLE_TIMEOUT);
+			k_work_reschedule(&dlc->session->rtx_work, RFCOMM_IDLE_TIMEOUT);
 		}
 	} else {
 		/* Cancel idle timer */
@@ -1308,8 +1269,7 @@ static void rfcomm_handle_disc(struct bt_rfcomm_session *session, uint8_t dlci)
 	}
 }
 
-static void rfcomm_handle_msg(struct bt_rfcomm_session *session,
-			      struct net_buf *buf)
+static void rfcomm_handle_msg(struct bt_rfcomm_session *session, struct net_buf *buf)
 {
 	struct bt_rfcomm_msg_hdr *hdr;
 	uint8_t msg_type, len, cr;
@@ -1343,8 +1303,7 @@ static void rfcomm_handle_msg(struct bt_rfcomm_session *session,
 		if (!cr) {
 			break;
 		}
-		rfcomm_send_test(session, BT_RFCOMM_MSG_RESP_CR, buf->data,
-				 buf->len - 1);
+		rfcomm_send_test(session, BT_RFCOMM_MSG_RESP_CR, buf->data, buf->len - 1);
 		break;
 	case BT_RFCOMM_FCON:
 		if (session->cfc == BT_RFCOMM_CFC_SUPPORTED) {
@@ -1410,8 +1369,8 @@ static void rfcomm_dlc_update_credits(struct bt_rfcomm_dlc *dlc)
 	rfcomm_send_credit(dlc, credits);
 }
 
-static void rfcomm_handle_data(struct bt_rfcomm_session *session,
-			       struct net_buf *buf, uint8_t dlci, uint8_t pf)
+static void rfcomm_handle_data(struct bt_rfcomm_session *session, struct net_buf *buf, uint8_t dlci,
+			       uint8_t pf)
 
 {
 	struct bt_rfcomm_dlc *dlc;
@@ -1440,8 +1399,7 @@ static void rfcomm_handle_data(struct bt_rfcomm_session *session,
 	}
 
 	if (buf->len > BT_RFCOMM_FCS_SIZE) {
-		if (dlc->session->cfc == BT_RFCOMM_CFC_SUPPORTED &&
-		    !dlc->rx_credit) {
+		if (dlc->session->cfc == BT_RFCOMM_CFC_SUPPORTED && !dlc->rx_credit) {
 			LOG_ERR("Data recvd when rx credit is 0");
 			rfcomm_dlc_close(dlc);
 			return;
@@ -1485,8 +1443,7 @@ int bt_rfcomm_dlc_send(struct bt_rfcomm_dlc *dlc, struct net_buf *buf)
 	}
 
 	/* control */
-	net_buf_push_u8(buf, BT_RFCOMM_SET_CTRL(BT_RFCOMM_UIH,
-					BT_RFCOMM_PF_UIH_NO_CREDIT));
+	net_buf_push_u8(buf, BT_RFCOMM_SET_CTRL(BT_RFCOMM_UIH, BT_RFCOMM_PF_UIH_NO_CREDIT));
 	/* address */
 	cr = BT_RFCOMM_UIH_CR(dlc->session->role);
 	net_buf_push_u8(buf, BT_RFCOMM_SET_ADDR(dlc->dlci, cr));
@@ -1570,8 +1527,7 @@ static int rfcomm_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 	return 0;
 }
 
-static void rfcomm_encrypt_change(struct bt_l2cap_chan *chan,
-				  uint8_t hci_status)
+static void rfcomm_encrypt_change(struct bt_l2cap_chan *chan, uint8_t hci_status)
 {
 	struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
 	struct bt_conn *conn = chan->conn;
@@ -1586,8 +1542,7 @@ static void rfcomm_encrypt_change(struct bt_l2cap_chan *chan,
 			continue;
 		}
 
-		if (hci_status || !conn->encrypt ||
-		    conn->sec_level < dlc->required_sec_level) {
+		if (hci_status || !conn->encrypt || conn->sec_level < dlc->required_sec_level) {
 			rfcomm_dlc_close(dlc);
 			continue;
 		}
@@ -1642,12 +1597,11 @@ static struct bt_rfcomm_session *rfcomm_session_new(bt_rfcomm_role_t role)
 		LOG_DBG("session %p initialized", session);
 
 		session->br_chan.chan.ops = &ops;
-		session->br_chan.rx.mtu	= CONFIG_BT_RFCOMM_L2CAP_MTU;
+		session->br_chan.rx.mtu = CONFIG_BT_RFCOMM_L2CAP_MTU;
 		session->state = BT_RFCOMM_STATE_INIT;
 		session->role = role;
 		session->cfc = BT_RFCOMM_CFC_UNKNOWN;
-		k_work_init_delayable(&session->rtx_work,
-				      rfcomm_session_rtx_timeout);
+		k_work_init_delayable(&session->rtx_work, rfcomm_session_rtx_timeout);
 		k_sem_init(&session->fc, 0, 1);
 
 		return session;
@@ -1656,8 +1610,7 @@ static struct bt_rfcomm_session *rfcomm_session_new(bt_rfcomm_role_t role)
 	return NULL;
 }
 
-int bt_rfcomm_dlc_connect(struct bt_conn *conn, struct bt_rfcomm_dlc *dlc,
-			  uint8_t channel)
+int bt_rfcomm_dlc_connect(struct bt_conn *conn, struct bt_rfcomm_dlc *dlc, uint8_t channel)
 {
 	struct bt_rfcomm_session *session;
 	struct bt_l2cap_chan *chan;
@@ -1753,8 +1706,7 @@ int bt_rfcomm_dlc_disconnect(struct bt_rfcomm_dlc *dlc)
 		 * and stop the tx thread.
 		 */
 		dlc->state = BT_RFCOMM_STATE_USER_DISCONNECT;
-		k_fifo_put(&dlc->tx_queue,
-			    net_buf_alloc(&dummy_pool, K_NO_WAIT));
+		k_fifo_put(&dlc->tx_queue, net_buf_alloc(&dummy_pool, K_NO_WAIT));
 
 		k_work_reschedule(&dlc->rtx_work, RFCOMM_DISC_TIMEOUT);
 
@@ -1785,8 +1737,8 @@ static int rfcomm_accept(struct bt_conn *conn, struct bt_l2cap_server *server,
 void bt_rfcomm_init(void)
 {
 	static struct bt_l2cap_server server = {
-		.psm       = BT_L2CAP_PSM_RFCOMM,
-		.accept    = rfcomm_accept,
+		.psm = BT_L2CAP_PSM_RFCOMM,
+		.accept = rfcomm_accept,
 		.sec_level = BT_SECURITY_L1,
 	};
 
diff --git a/subsys/bluetooth/host/classic/rfcomm_internal.h b/subsys/bluetooth/host/classic/rfcomm_internal.h
index 07ff13bd0e9..ab622b8ae9f 100644
--- a/subsys/bluetooth/host/classic/rfcomm_internal.h
+++ b/subsys/bluetooth/host/classic/rfcomm_internal.h
@@ -54,93 +54,91 @@ struct bt_rfcomm_hdr_ext {
 	uint8_t second_length;
 } __packed;
 
-#define BT_RFCOMM_SABM  0x2f
-#define BT_RFCOMM_UA    0x63
-#define BT_RFCOMM_UIH   0xef
+#define BT_RFCOMM_SABM 0x2f
+#define BT_RFCOMM_UA   0x63
+#define BT_RFCOMM_UIH  0xef
 
 struct bt_rfcomm_msg_hdr {
 	uint8_t type;
 	uint8_t len;
 } __packed;
 
-#define BT_RFCOMM_PN    0x20
+#define BT_RFCOMM_PN 0x20
 struct bt_rfcomm_pn {
-	uint8_t  dlci;
-	uint8_t  flow_ctrl;
-	uint8_t  priority;
-	uint8_t  ack_timer;
+	uint8_t dlci;
+	uint8_t flow_ctrl;
+	uint8_t priority;
+	uint8_t ack_timer;
 	uint16_t mtu;
-	uint8_t  max_retrans;
-	uint8_t  credits;
+	uint8_t max_retrans;
+	uint8_t credits;
 } __packed;
 
-#define BT_RFCOMM_MSC    0x38
+#define BT_RFCOMM_MSC 0x38
 struct bt_rfcomm_msc {
-	uint8_t  dlci;
-	uint8_t  v24_signal;
+	uint8_t dlci;
+	uint8_t v24_signal;
 } __packed;
 
-#define BT_RFCOMM_DISC  0x43
-#define BT_RFCOMM_DM    0x0f
+#define BT_RFCOMM_DISC 0x43
+#define BT_RFCOMM_DM   0x0f
 
-#define BT_RFCOMM_RLS   0x14
+#define BT_RFCOMM_RLS 0x14
 struct bt_rfcomm_rls {
-	uint8_t  dlci;
-	uint8_t  line_status;
+	uint8_t dlci;
+	uint8_t line_status;
 } __packed;
 
-#define BT_RFCOMM_RPN   0x24
+#define BT_RFCOMM_RPN 0x24
 struct bt_rfcomm_rpn {
-	uint8_t  dlci;
-	uint8_t  baud_rate;
-	uint8_t  line_settings;
-	uint8_t  flow_control;
-	uint8_t  xon_char;
-	uint8_t  xoff_char;
+	uint8_t dlci;
+	uint8_t baud_rate;
+	uint8_t line_settings;
+	uint8_t flow_control;
+	uint8_t xon_char;
+	uint8_t xoff_char;
 	uint16_t param_mask;
 } __packed;
 
-#define BT_RFCOMM_TEST  0x08
-#define BT_RFCOMM_NSC   0x04
+#define BT_RFCOMM_TEST 0x08
+#define BT_RFCOMM_NSC  0x04
 
 #define BT_RFCOMM_FCON  0x28
 #define BT_RFCOMM_FCOFF 0x18
 
 /* Default RPN Settings */
-#define BT_RFCOMM_RPN_BAUD_RATE_9600    0x03
-#define BT_RFCOMM_RPN_DATA_BITS_8       0x03
-#define BT_RFCOMM_RPN_STOP_BITS_1       0x00
-#define BT_RFCOMM_RPN_PARITY_NONE       0x00
-#define BT_RFCOMM_RPN_FLOW_NONE         0x00
-#define BT_RFCOMM_RPN_XON_CHAR          0x11
-#define BT_RFCOMM_RPN_XOFF_CHAR         0x13
+#define BT_RFCOMM_RPN_BAUD_RATE_9600 0x03
+#define BT_RFCOMM_RPN_DATA_BITS_8    0x03
+#define BT_RFCOMM_RPN_STOP_BITS_1    0x00
+#define BT_RFCOMM_RPN_PARITY_NONE    0x00
+#define BT_RFCOMM_RPN_FLOW_NONE      0x00
+#define BT_RFCOMM_RPN_XON_CHAR       0x11
+#define BT_RFCOMM_RPN_XOFF_CHAR      0x13
 
 /* Set 1 to all the param mask except reserved */
-#define BT_RFCOMM_RPN_PARAM_MASK_ALL    0x3f7f
+#define BT_RFCOMM_RPN_PARAM_MASK_ALL 0x3f7f
 
-#define BT_RFCOMM_SET_LINE_SETTINGS(data, stop, parity) ((data & 0x3) | \
-							 ((stop & 0x1) << 2) | \
-							 ((parity & 0x7) << 3))
+#define BT_RFCOMM_SET_LINE_SETTINGS(data, stop, parity)                                            \
+	((data & 0x3) | ((stop & 0x1) << 2) | ((parity & 0x7) << 3))
 
 /* DV = 1 IC = 0 RTR = 1 RTC = 1 FC = 0 EXT = 0 */
 #define BT_RFCOMM_DEFAULT_V24_SIG 0x8d
 
 #define BT_RFCOMM_GET_FC(v24_signal) (((v24_signal) & 0x02) >> 1)
 
-#define BT_RFCOMM_SIG_MIN_MTU   23
-#define BT_RFCOMM_SIG_MAX_MTU   32767
+#define BT_RFCOMM_SIG_MIN_MTU 23
+#define BT_RFCOMM_SIG_MAX_MTU 32767
 
-#define BT_RFCOMM_CHECK_MTU(mtu) (!!((mtu) >= BT_RFCOMM_SIG_MIN_MTU && \
-				     (mtu) <= BT_RFCOMM_SIG_MAX_MTU))
+#define BT_RFCOMM_CHECK_MTU(mtu)                                                                   \
+	(!!((mtu) >= BT_RFCOMM_SIG_MIN_MTU && (mtu) <= BT_RFCOMM_SIG_MAX_MTU))
 
 /* Helper to calculate needed outgoing buffer size.
  * Length in rfcomm header can be two bytes depending on user data length.
  * One byte in the tail should be reserved for FCS.
  */
-#define BT_RFCOMM_BUF_SIZE(mtu) (BT_BUF_RESERVE + \
-				 BT_HCI_ACL_HDR_SIZE + BT_L2CAP_HDR_SIZE + \
-				 sizeof(struct bt_rfcomm_hdr) + 1 + (mtu) + \
-				 BT_RFCOMM_FCS_SIZE)
+#define BT_RFCOMM_BUF_SIZE(mtu)                                                                    \
+	(BT_BUF_RESERVE + BT_HCI_ACL_HDR_SIZE + BT_L2CAP_HDR_SIZE + sizeof(struct bt_rfcomm_hdr) + \
+	 1 + (mtu) + BT_RFCOMM_FCS_SIZE)
 
 #define BT_RFCOMM_GET_DLCI(addr)                  (((addr) & 0xfc) >> 2)
 #define BT_RFCOMM_GET_FRAME_TYPE(ctrl)            ((ctrl) & 0xef)
@@ -151,20 +149,19 @@ struct bt_rfcomm_rpn {
 #define BT_RFCOMM_GET_CHANNEL(dlci)               ((dlci) >> 1)
 #define BT_RFCOMM_GET_PF(ctrl)                    (((ctrl) & 0x10) >> 4)
 
-#define BT_RFCOMM_SET_ADDR(dlci, cr)       ((((dlci) & 0x3f) << 2) | \
-					    ((cr) << 1) | 0x01)
-#define BT_RFCOMM_SET_CTRL(type, pf)       (((type) & 0xef) | ((pf) << 4))
-#define BT_RFCOMM_SET_LEN_8(len)           (((len) << 1) | 1)
-#define BT_RFCOMM_SET_LEN_16(len)          ((len) << 1)
-#define BT_RFCOMM_SET_MSG_TYPE(type, cr)   (((type) << 2) | (cr << 1) | 0x01)
+#define BT_RFCOMM_SET_ADDR(dlci, cr)     ((((dlci) & 0x3f) << 2) | ((cr) << 1) | 0x01)
+#define BT_RFCOMM_SET_CTRL(type, pf)     (((type) & 0xef) | ((pf) << 4))
+#define BT_RFCOMM_SET_LEN_8(len)         (((len) << 1) | 1)
+#define BT_RFCOMM_SET_LEN_16(len)        ((len) << 1)
+#define BT_RFCOMM_SET_MSG_TYPE(type, cr) (((type) << 2) | (cr << 1) | 0x01)
 
-#define BT_RFCOMM_LEN_EXTENDED(len)        (!((len) & 0x01))
+#define BT_RFCOMM_LEN_EXTENDED(len) (!((len) & 0x01))
 
 /* For CR in UIH Packet header
  * Initiating station have the C/R bit set to 1 and those sent by the
  * responding station have the C/R bit set to 0
  */
-#define BT_RFCOMM_UIH_CR(role)             ((role) == BT_RFCOMM_ROLE_INITIATOR)
+#define BT_RFCOMM_UIH_CR(role) ((role) == BT_RFCOMM_ROLE_INITIATOR)
 
 /* For CR in Non UIH Packet header
  * Command
@@ -174,46 +171,46 @@ struct bt_rfcomm_rpn {
  * Initiator --> Responder 0
  * Responder --> Initiator 1
  */
-#define BT_RFCOMM_CMD_CR(role)             ((role) == BT_RFCOMM_ROLE_INITIATOR)
-#define BT_RFCOMM_RESP_CR(role)            ((role) == BT_RFCOMM_ROLE_ACCEPTOR)
+#define BT_RFCOMM_CMD_CR(role)  ((role) == BT_RFCOMM_ROLE_INITIATOR)
+#define BT_RFCOMM_RESP_CR(role) ((role) == BT_RFCOMM_ROLE_ACCEPTOR)
 
 /* For CR in MSG header
  * If the C/R bit is set to 1 the message is a command,
  * if it is set to 0 the message is a response.
  */
-#define BT_RFCOMM_MSG_CMD_CR               1
-#define BT_RFCOMM_MSG_RESP_CR              0
+#define BT_RFCOMM_MSG_CMD_CR  1
+#define BT_RFCOMM_MSG_RESP_CR 0
 
-#define BT_RFCOMM_DLCI(role, channel)      ((((channel) & 0x1f) << 1) | \
-					    ((role) == BT_RFCOMM_ROLE_ACCEPTOR))
+#define BT_RFCOMM_DLCI(role, channel)                                                              \
+	((((channel) & 0x1f) << 1) | ((role) == BT_RFCOMM_ROLE_ACCEPTOR))
 
 /* Excluding ext bit */
 #define BT_RFCOMM_MAX_LEN_8 127
 
 /* Length can be 2 bytes depending on data size */
-#define BT_RFCOMM_HDR_SIZE  (sizeof(struct bt_rfcomm_hdr) + 1)
-#define BT_RFCOMM_FCS_SIZE  1
+#define BT_RFCOMM_HDR_SIZE (sizeof(struct bt_rfcomm_hdr) + 1)
+#define BT_RFCOMM_FCS_SIZE 1
 
-#define BT_RFCOMM_FCS_LEN_UIH      2
-#define BT_RFCOMM_FCS_LEN_NON_UIH  3
+#define BT_RFCOMM_FCS_LEN_UIH     2
+#define BT_RFCOMM_FCS_LEN_NON_UIH 3
 
 /* For non UIH packets
  * The P bit set to 1 shall be used to solicit a response frame with the
  * F bit set to 1 from the other station.
  */
-#define BT_RFCOMM_PF_NON_UIH         1
+#define BT_RFCOMM_PF_NON_UIH 1
 
 /* For UIH packets
  * Both stations set the P-bit to 0
  * If credit based flow control is used, If P/F is 1 then one credit byte
  * will be there after control in the frame else no credit byte.
  */
-#define BT_RFCOMM_PF_UIH             0
-#define BT_RFCOMM_PF_UIH_CREDIT      1
-#define BT_RFCOMM_PF_UIH_NO_CREDIT   0
+#define BT_RFCOMM_PF_UIH           0
+#define BT_RFCOMM_PF_UIH_CREDIT    1
+#define BT_RFCOMM_PF_UIH_NO_CREDIT 0
 
-#define BT_RFCOMM_PN_CFC_CMD   0xf0
-#define BT_RFCOMM_PN_CFC_RESP  0xe0
+#define BT_RFCOMM_PN_CFC_CMD  0xf0
+#define BT_RFCOMM_PN_CFC_RESP 0xe0
 
 /* Initialize RFCOMM signal layer */
 void bt_rfcomm_init(void);
diff --git a/subsys/bluetooth/host/classic/sco.c b/subsys/bluetooth/host/classic/sco.c
index 51433c9090b..cbac5fb4480 100644
--- a/subsys/bluetooth/host/classic/sco.c
+++ b/subsys/bluetooth/host/classic/sco.c
@@ -159,8 +159,7 @@ const char *bt_sco_chan_state_str(uint8_t state)
 	}
 }
 
-void bt_sco_chan_set_state_debug(struct bt_sco_chan *chan,
-				 enum bt_sco_state state,
+void bt_sco_chan_set_state_debug(struct bt_sco_chan *chan, enum bt_sco_state state,
 				 const char *func, int line)
 {
 	LOG_DBG("chan %p sco %p %s -> %s", chan, chan->sco, bt_sco_chan_state_str(chan->state),
@@ -185,7 +184,7 @@ void bt_sco_chan_set_state_debug(struct bt_sco_chan *chan,
 		break;
 	case BT_SCO_STATE_DISCONNECTING:
 		if (chan->state != BT_SCO_STATE_CONNECTING &&
-			chan->state != BT_SCO_STATE_CONNECTED) {
+		    chan->state != BT_SCO_STATE_CONNECTED) {
 			LOG_WRN("%s()%d: invalid transition", func, line);
 		}
 		break;
@@ -203,7 +202,6 @@ void bt_sco_chan_set_state(struct bt_sco_chan *chan, enum bt_sco_state state)
 }
 #endif /* CONFIG_BT_CONN_LOG_LEVEL_DBG */
 
-
 static void bt_sco_chan_add(struct bt_conn *sco, struct bt_sco_chan *chan)
 {
 	/* Attach SCO channel to the connection */
diff --git a/subsys/bluetooth/host/classic/sco_internal.h b/subsys/bluetooth/host/classic/sco_internal.h
index 1018f0a0b54..25661166739 100644
--- a/subsys/bluetooth/host/classic/sco_internal.h
+++ b/subsys/bluetooth/host/classic/sco_internal.h
@@ -50,9 +50,9 @@ struct bt_sco_chan_ops {
 struct bt_sco_chan {
 	struct bt_conn *sco;
 	/** Channel operations reference */
-	struct bt_sco_chan_ops		*ops;
+	struct bt_sco_chan_ops *ops;
 
-	enum bt_sco_state		state;
+	enum bt_sco_state state;
 };
 
 /** @brief Initiate an SCO connection to a remote device.
@@ -75,10 +75,10 @@ struct bt_sco_accept_info {
 	struct bt_conn *acl;
 
 	/** class code of peer device */
-	uint8_t   dev_class[3];
+	uint8_t dev_class[3];
 
 	/** link type */
-	uint8_t   link_type;
+	uint8_t link_type;
 };
 
 /** @brief SCO Server structure. */
@@ -86,7 +86,7 @@ struct bt_sco_server {
 	/** Required minimum security level.
 	 * Only available when @kconfig{CONFIG_BT_SMP} is enabled.
 	 */
-	bt_security_t		sec_level;
+	bt_security_t sec_level;
 	/** @brief Server accept callback
 	 *
 	 *  This callback is called whenever a new incoming connection requires
@@ -97,8 +97,7 @@ struct bt_sco_server {
 	 *
 	 *  @return 0 in case of success or negative value in case of error.
 	 */
-	int (*accept)(const struct bt_sco_accept_info *info,
-			  struct bt_sco_chan **chan);
+	int (*accept)(const struct bt_sco_accept_info *info, struct bt_sco_chan **chan);
 };
 
 /** @brief Register SCO server.
@@ -142,10 +141,9 @@ void bt_sco_disconnected(struct bt_conn *sco);
 uint8_t bt_esco_conn_req(struct bt_hci_evt_conn_request *evt);
 
 #if defined(CONFIG_BT_CONN_LOG_LEVEL_DBG)
-void bt_sco_chan_set_state_debug(struct bt_sco_chan *chan,
-				 enum bt_sco_state state,
+void bt_sco_chan_set_state_debug(struct bt_sco_chan *chan, enum bt_sco_state state,
 				 const char *func, int line);
-#define bt_sco_chan_set_state(_chan, _state) \
+#define bt_sco_chan_set_state(_chan, _state)                                                       \
 	bt_sco_chan_set_state_debug(_chan, _state, __func__, __LINE__)
 #else
 void bt_sco_chan_set_state(struct bt_sco_chan *chan, enum bt_sco_state state);
diff --git a/subsys/bluetooth/host/classic/sdp.c b/subsys/bluetooth/host/classic/sdp.c
index 124ca2e3a4a..d833d9329e7 100644
--- a/subsys/bluetooth/host/classic/sdp.c
+++ b/subsys/bluetooth/host/classic/sdp.c
@@ -63,7 +63,7 @@ LOG_MODULE_REGISTER(bt_sdp);
 
 struct bt_sdp {
 	struct bt_l2cap_br_chan chan;
-	struct k_fifo           partial_resp_queue;
+	struct k_fifo partial_resp_queue;
 	/* TODO: Allow more than one pending request */
 };
 
@@ -81,17 +81,17 @@ NET_BUF_POOL_FIXED_DEFINE(sdp_pool, CONFIG_BT_MAX_CONN, BT_L2CAP_BUF_SIZE(SDP_MT
 #define SDP_CLIENT_MTU 64
 
 struct bt_sdp_client {
-	struct bt_l2cap_br_chan              chan;
+	struct bt_l2cap_br_chan chan;
 	/* list of waiting to be resolved UUID params */
-	sys_slist_t                          reqs;
+	sys_slist_t reqs;
 	/* required SDP transaction ID */
-	uint16_t                                tid;
+	uint16_t tid;
 	/* UUID params holder being now resolved */
 	const struct bt_sdp_discover_params *param;
 	/* PDU continuation state object */
-	struct bt_sdp_pdu_cstate             cstate;
+	struct bt_sdp_pdu_cstate cstate;
 	/* buffer for collecting record data */
-	struct net_buf                      *rec_buf;
+	struct net_buf *rec_buf;
 };
 
 static struct bt_sdp_client bt_sdp_client_pool[CONFIG_BT_MAX_CONN];
@@ -103,23 +103,23 @@ enum {
 
 struct search_state {
 	uint16_t att_list_size;
-	uint8_t  current_svc;
-	uint8_t  last_att;
-	bool     pkt_full;
+	uint8_t current_svc;
+	uint8_t last_att;
+	bool pkt_full;
 };
 
 struct select_attrs_data {
-	struct bt_sdp_record        *rec;
-	struct net_buf              *rsp_buf;
-	struct bt_sdp               *sdp;
+	struct bt_sdp_record *rec;
+	struct net_buf *rsp_buf;
+	struct bt_sdp *sdp;
 	struct bt_sdp_data_elem_seq *seq;
-	struct search_state         *state;
-	uint32_t                       *filter;
-	uint16_t                        max_att_len;
-	uint16_t                        att_list_len;
-	uint8_t                         cont_state_size;
-	size_t                          num_filters;
-	bool                         new_service;
+	struct search_state *state;
+	uint32_t *filter;
+	uint16_t max_att_len;
+	uint16_t att_list_len;
+	uint8_t cont_state_size;
+	size_t num_filters;
+	bool new_service;
 };
 
 /* @typedef bt_sdp_attr_func_t
@@ -132,8 +132,8 @@ struct select_attrs_data {
  *  @return BT_SDP_ITER_CONTINUE if should continue to the next attribute
  *  or BT_SDP_ITER_STOP to stop.
  */
-typedef uint8_t (*bt_sdp_attr_func_t)(struct bt_sdp_attribute *attr,
-				   uint8_t att_idx, void *user_data);
+typedef uint8_t (*bt_sdp_attr_func_t)(struct bt_sdp_attribute *attr, uint8_t att_idx,
+				      void *user_data);
 
 /* @typedef bt_sdp_svc_func_t
  * @brief SDP service record iterator callback.
@@ -144,8 +144,7 @@ typedef uint8_t (*bt_sdp_attr_func_t)(struct bt_sdp_attribute *attr,
  * @return BT_SDP_ITER_CONTINUE if should continue to the next service record
  *  or BT_SDP_ITER_STOP to stop.
  */
-typedef uint8_t (*bt_sdp_svc_func_t)(struct bt_sdp_record *rec,
-				  void *user_data);
+typedef uint8_t (*bt_sdp_svc_func_t)(struct bt_sdp_record *rec, void *user_data);
 
 /* @brief Callback for SDP connection
  *
@@ -157,9 +156,7 @@ typedef uint8_t (*bt_sdp_svc_func_t)(struct bt_sdp_record *rec,
  */
 static void bt_sdp_connected(struct bt_l2cap_chan *chan)
 {
-	struct bt_l2cap_br_chan *ch = CONTAINER_OF(chan,
-						   struct bt_l2cap_br_chan,
-						   chan);
+	struct bt_l2cap_br_chan *ch = CONTAINER_OF(chan, struct bt_l2cap_br_chan, chan);
 
 	struct bt_sdp *sdp = CONTAINER_OF(ch, struct bt_sdp, chan);
 
@@ -178,9 +175,7 @@ static void bt_sdp_connected(struct bt_l2cap_chan *chan)
  */
 static void bt_sdp_disconnected(struct bt_l2cap_chan *chan)
 {
-	struct bt_l2cap_br_chan *ch = CONTAINER_OF(chan,
-						   struct bt_l2cap_br_chan,
-						   chan);
+	struct bt_l2cap_br_chan *ch = CONTAINER_OF(chan, struct bt_l2cap_br_chan, chan);
 
 	struct bt_sdp *sdp = CONTAINER_OF(ch, struct bt_sdp, chan);
 
@@ -213,8 +208,7 @@ static struct net_buf *bt_sdp_create_pdu(void)
  *
  *  @return None
  */
-static int bt_sdp_send(struct bt_l2cap_chan *chan, struct net_buf *buf,
-		       uint8_t op, uint16_t tid)
+static int bt_sdp_send(struct bt_l2cap_chan *chan, struct net_buf *buf, uint8_t op, uint16_t tid)
 {
 	struct bt_sdp_hdr *hdr;
 	uint16_t param_len = buf->len;
@@ -243,8 +237,7 @@ static int bt_sdp_send(struct bt_l2cap_chan *chan, struct net_buf *buf,
  *
  *  @return None
  */
-static void send_err_rsp(struct bt_l2cap_chan *chan, uint16_t err,
-			 uint16_t tid)
+static void send_err_rsp(struct bt_l2cap_chan *chan, uint16_t err, uint16_t tid)
 {
 	struct net_buf *buf;
 
@@ -268,8 +261,7 @@ static void send_err_rsp(struct bt_l2cap_chan *chan, uint16_t err,
  *
  * @return 0 for success, or relevant error code
  */
-static uint16_t parse_data_elem(struct net_buf *buf,
-				struct bt_sdp_data_elem *data_elem)
+static uint16_t parse_data_elem(struct net_buf *buf, struct bt_sdp_data_elem *data_elem)
 {
 	uint8_t size_field_len = 0U; /* Space used to accommodate the size */
 
@@ -285,15 +277,14 @@ static uint16_t parse_data_elem(struct net_buf *buf,
 	case BT_SDP_INT8:
 	case BT_SDP_UUID_UNSPEC:
 	case BT_SDP_BOOL:
-		data_elem->data_size = BIT(data_elem->type &
-					   BT_SDP_SIZE_DESC_MASK);
+		data_elem->data_size = BIT(data_elem->type & BT_SDP_SIZE_DESC_MASK);
 		break;
 	case BT_SDP_TEXT_STR_UNSPEC:
 	case BT_SDP_SEQ_UNSPEC:
 	case BT_SDP_ALT_UNSPEC:
 	case BT_SDP_URL_STR_UNSPEC:
-		size_field_len = BIT((data_elem->type & BT_SDP_SIZE_DESC_MASK) -
-				     BT_SDP_SIZE_INDEX_OFFSET);
+		size_field_len =
+			BIT((data_elem->type & BT_SDP_SIZE_DESC_MASK) - BT_SDP_SIZE_INDEX_OFFSET);
 		if (buf->len < size_field_len) {
 			LOG_WRN("Malformed packet");
 			return BT_SDP_INVALID_SYNTAX;
@@ -344,8 +335,8 @@ static uint16_t parse_data_elem(struct net_buf *buf,
  * @return Size of the last data element that has been searched
  *  (used in recursion)
  */
-static uint32_t search_uuid(struct bt_sdp_data_elem *elem, struct bt_uuid *uuid,
-			 bool *found, uint8_t nest_level)
+static uint32_t search_uuid(struct bt_sdp_data_elem *elem, struct bt_uuid *uuid, bool *found,
+			    uint8_t nest_level)
 {
 	const uint8_t *cur_elem;
 	uint32_t seq_size, size;
@@ -397,8 +388,8 @@ static uint32_t search_uuid(struct bt_sdp_data_elem *elem, struct bt_uuid *uuid,
 	    (elem->type & BT_SDP_TYPE_DESC_MASK) == BT_SDP_ALT_UNSPEC) {
 		do {
 			/* Recursively parse data elements */
-			size = search_uuid((struct bt_sdp_data_elem *)cur_elem,
-					   uuid, found, nest_level + 1);
+			size = search_uuid((struct bt_sdp_data_elem *)cur_elem, uuid, found,
+					   nest_level + 1);
 			if (*found) {
 				return 0;
 			}
@@ -420,8 +411,7 @@ static uint32_t search_uuid(struct bt_sdp_data_elem *elem, struct bt_uuid *uuid,
  * @return Pointer to the record where the iterator stopped, or NULL if all
  *  records are covered
  */
-static struct bt_sdp_record *bt_sdp_foreach_svc(bt_sdp_svc_func_t func,
-						void *user_data)
+static struct bt_sdp_record *bt_sdp_foreach_svc(bt_sdp_svc_func_t func, void *user_data)
 {
 	struct bt_sdp_record *rec = db;
 
@@ -466,8 +456,7 @@ static uint8_t insert_record(struct bt_sdp_record *rec, void *user_data)
  *
  * @return 0 for success, or relevant error code
  */
-static uint16_t find_services(struct net_buf *buf,
-			      struct bt_sdp_record **matching_recs)
+static uint16_t find_services(struct net_buf *buf, struct bt_sdp_record **matching_recs)
 {
 	struct bt_sdp_data_elem data_elem;
 	struct bt_sdp_record *record;
@@ -504,8 +493,7 @@ static uint16_t find_services(struct net_buf *buf,
 			return res;
 		}
 
-		if ((data_elem.type & BT_SDP_TYPE_DESC_MASK) !=
-		    BT_SDP_UUID_UNSPEC) {
+		if ((data_elem.type & BT_SDP_TYPE_DESC_MASK) != BT_SDP_UUID_UNSPEC) {
 			LOG_WRN("Invalid type %u in service search pattern", data_elem.type);
 			return BT_SDP_INVALID_SYNTAX;
 		}
@@ -523,8 +511,7 @@ static uint16_t find_services(struct net_buf *buf,
 			u.u32.val = net_buf_pull_be32(buf);
 		} else if (data_elem.data_size == 16U) {
 			u.uuid.type = BT_UUID_TYPE_128;
-			sys_memcpy_swap(u.u128.val, buf->data,
-					data_elem.data_size);
+			sys_memcpy_swap(u.u128.val, buf->data, data_elem.data_size);
 			net_buf_pull(buf, data_elem.data_size);
 		} else {
 			LOG_WRN("Invalid UUID len %u in service search pattern",
@@ -547,10 +534,8 @@ static uint16_t find_services(struct net_buf *buf,
 			found = false;
 
 			/* Search for the UUID in all the attrs of the svc */
-			for (att_idx = 0U; att_idx < record->attr_count;
-			     att_idx++) {
-				search_uuid(&record->attrs[att_idx].val,
-					    &u.uuid, &found, 1);
+			for (att_idx = 0U; att_idx < record->attr_count; att_idx++) {
+				search_uuid(&record->attrs[att_idx].val, &u.uuid, &found, 1);
 				if (found) {
 					break;
 				}
@@ -578,8 +563,7 @@ static uint16_t find_services(struct net_buf *buf,
  *
  * @return 0 for success, or relevant error code
  */
-static uint16_t sdp_svc_search_req(struct bt_sdp *sdp, struct net_buf *buf,
-				uint16_t tid)
+static uint16_t sdp_svc_search_req(struct bt_sdp *sdp, struct net_buf *buf, uint16_t tid)
 {
 	struct bt_sdp_svc_rsp *rsp;
 	struct net_buf *resp_buf;
@@ -713,8 +697,8 @@ static uint16_t sdp_svc_search_req(struct bt_sdp *sdp, struct net_buf *buf,
  *  @return Size of the last data element that has been searched
  *  (used in recursion)
  */
-static uint32_t copy_attribute(struct bt_sdp_data_elem *elem,
-			    struct net_buf *buf, uint8_t nest_level)
+static uint32_t copy_attribute(struct bt_sdp_data_elem *elem, struct net_buf *buf,
+			       uint8_t nest_level)
 {
 	const uint8_t *cur_elem;
 	uint32_t size, seq_size, total_size;
@@ -749,8 +733,8 @@ static uint32_t copy_attribute(struct bt_sdp_data_elem *elem,
 	if ((elem->type & BT_SDP_TYPE_DESC_MASK) == BT_SDP_SEQ_UNSPEC ||
 	    (elem->type & BT_SDP_TYPE_DESC_MASK) == BT_SDP_ALT_UNSPEC) {
 		do {
-			size = copy_attribute((struct bt_sdp_data_elem *)
-					      cur_elem, buf, nest_level + 1);
+			size = copy_attribute((struct bt_sdp_data_elem *)cur_elem, buf,
+					      nest_level + 1);
 			cur_elem += sizeof(struct bt_sdp_data_elem);
 			seq_size -= size;
 		} while (seq_size);
@@ -786,11 +770,10 @@ static uint32_t copy_attribute(struct bt_sdp_data_elem *elem,
  *  @return Index of the attribute where the iterator stopped
  */
 static uint8_t bt_sdp_foreach_attr(struct bt_sdp_record *record, uint8_t idx,
-				bt_sdp_attr_func_t func, void *user_data)
+				   bt_sdp_attr_func_t func, void *user_data)
 {
 	for (; idx < record->attr_count; idx++) {
-		if (func(&record->attrs[idx], idx, user_data) ==
-		    BT_SDP_ITER_STOP) {
+		if (func(&record->attrs[idx], idx, user_data) == BT_SDP_ITER_STOP) {
 			break;
 		}
 	}
@@ -811,8 +794,7 @@ static uint8_t bt_sdp_foreach_attr(struct bt_sdp_record *record, uint8_t idx,
  *  @return BT_SDP_ITER_CONTINUE if should continue to the next attribute
  *   or BT_SDP_ITER_STOP to stop.
  */
-static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx,
-			 void *user_data)
+static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx, void *user_data)
 {
 	struct select_attrs_data *sad = user_data;
 	uint16_t att_id_lower, att_id_upper, att_id_cur, space;
@@ -826,8 +808,7 @@ static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx,
 		att_id_cur = attr->id;
 
 		/* Check for range values */
-		if (att_id_lower != 0xffff &&
-		    (!IN_RANGE(att_id_cur, att_id_lower, att_id_upper))) {
+		if (att_id_lower != 0xffff && (!IN_RANGE(att_id_cur, att_id_lower, att_id_upper))) {
 			continue;
 		}
 
@@ -845,8 +826,7 @@ static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx,
 		 * to account for the space required to add the per-service
 		 * data element sequence header as well.
 		 */
-		if ((sad->state->current_svc != sad->rec->index) &&
-		    sad->new_service) {
+		if ((sad->state->current_svc != sad->rec->index) && sad->new_service) {
 			/* 3 bytes for Per-Service Data Elem Seq declaration */
 			seq_size = attr_size + 3;
 		} else {
@@ -854,8 +834,8 @@ static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx,
 		}
 
 		if (sad->rsp_buf) {
-			space = MIN(SDP_MTU, sad->sdp->chan.tx.mtu) -
-				sad->rsp_buf->len - sizeof(struct bt_sdp_hdr);
+			space = MIN(SDP_MTU, sad->sdp->chan.tx.mtu) - sad->rsp_buf->len -
+				sizeof(struct bt_sdp_hdr);
 
 			if ((!sad->state->pkt_full) &&
 			    ((seq_size > sad->max_att_len) ||
@@ -870,10 +850,8 @@ static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx,
 			/* Add Per-Service Data Element Seq declaration once
 			 * only when we are starting from the first attribute
 			 */
-			if (!sad->seq &&
-			    (sad->state->current_svc != sad->rec->index)) {
-				sad->seq = net_buf_add(sad->rsp_buf,
-						       sizeof(*sad->seq));
+			if (!sad->seq && (sad->state->current_svc != sad->rec->index)) {
+				sad->seq = net_buf_add(sad->rsp_buf, sizeof(*sad->seq));
 				sad->seq->type = BT_SDP_SEQ16;
 				sad->seq->size = 0U;
 			}
@@ -941,11 +919,10 @@ static uint8_t select_attrs(struct bt_sdp_attribute *attr, uint8_t att_idx,
  *
  *  @return len Length of the attribute list created
  */
-static uint16_t create_attr_list(struct bt_sdp *sdp, struct bt_sdp_record *record,
-			      uint32_t *filter, size_t num_filters,
-			      uint16_t max_att_len, uint8_t cont_state_size,
-			      uint8_t next_att, struct search_state *state,
-			      struct net_buf *rsp_buf)
+static uint16_t create_attr_list(struct bt_sdp *sdp, struct bt_sdp_record *record, uint32_t *filter,
+				 size_t num_filters, uint16_t max_att_len, uint8_t cont_state_size,
+				 uint8_t next_att, struct search_state *state,
+				 struct net_buf *rsp_buf)
 {
 	struct select_attrs_data sad;
 	uint8_t idx_att;
@@ -986,8 +963,8 @@ static uint16_t create_attr_list(struct bt_sdp *sdp, struct bt_sdp_record *recor
  *
  *  @return 0 for success, or relevant error code
  */
-static uint16_t get_att_search_list(struct net_buf *buf, uint32_t *filter,
-				 size_t max_filters, size_t *num_filters)
+static uint16_t get_att_search_list(struct net_buf *buf, uint32_t *filter, size_t max_filters,
+				    size_t *num_filters)
 {
 	struct bt_sdp_data_elem data_elem;
 	uint16_t res;
@@ -1024,8 +1001,7 @@ static uint16_t get_att_search_list(struct net_buf *buf, uint32_t *filter,
 
 		/* This is an attribute ID */
 		if (data_elem.data_size == 2U) {
-			filter[(*num_filters)++] = 0xffff0000 |
-							net_buf_pull_be16(buf);
+			filter[(*num_filters)++] = 0xffff0000 | net_buf_pull_be16(buf);
 		}
 
 		/* This is an attribute ID range */
@@ -1070,15 +1046,11 @@ static uint8_t find_handle(struct bt_sdp_record *rec, void *user_data)
  *
  *  @return 0 for success, or relevant error code
  */
-static uint16_t sdp_svc_att_req(struct bt_sdp *sdp, struct net_buf *buf,
-			     uint16_t tid)
+static uint16_t sdp_svc_att_req(struct bt_sdp *sdp, struct net_buf *buf, uint16_t tid)
 {
 	uint32_t filter[MAX_NUM_ATT_ID_FILTER];
 	struct search_state state = {
-		.current_svc = SDP_INVALID,
-		.last_att = SDP_INVALID,
-		.pkt_full = false
-	};
+		.current_svc = SDP_INVALID, .last_att = SDP_INVALID, .pkt_full = false};
 	struct bt_sdp_record *record;
 	struct bt_sdp_att_rsp *rsp;
 	struct net_buf *rsp_buf;
@@ -1147,9 +1119,8 @@ static uint16_t sdp_svc_att_req(struct bt_sdp *sdp, struct net_buf *buf,
 	rsp = net_buf_add(rsp_buf, sizeof(*rsp));
 
 	/* cont_state_size should include 1 byte header */
-	att_list_len = create_attr_list(sdp, record, filter, num_filters,
-					max_att_len, SDP_SA_CONT_STATE_SIZE + 1,
-					next_att, &state, rsp_buf);
+	att_list_len = create_attr_list(sdp, record, filter, num_filters, max_att_len,
+					SDP_SA_CONT_STATE_SIZE + 1, next_att, &state, rsp_buf);
 
 	if (!att_list_len) {
 		/* For empty responses, add an empty data element sequence */
@@ -1185,17 +1156,14 @@ static uint16_t sdp_svc_att_req(struct bt_sdp *sdp, struct net_buf *buf,
  *
  *  @return 0 for success, or relevant error code
  */
-static uint16_t sdp_svc_search_att_req(struct bt_sdp *sdp, struct net_buf *buf,
-				    uint16_t tid)
+static uint16_t sdp_svc_search_att_req(struct bt_sdp *sdp, struct net_buf *buf, uint16_t tid)
 {
 	uint32_t filter[MAX_NUM_ATT_ID_FILTER];
 	struct bt_sdp_record *matching_recs[BT_SDP_MAX_SERVICES];
-	struct search_state state = {
-		.att_list_size = 0,
-		.current_svc = SDP_INVALID,
-		.last_att = SDP_INVALID,
-		.pkt_full = false
-	};
+	struct search_state state = {.att_list_size = 0,
+				     .current_svc = SDP_INVALID,
+				     .last_att = SDP_INVALID,
+				     .pkt_full = false};
 	struct net_buf *rsp_buf, *rsp_buf_cpy;
 	struct bt_sdp_record *record;
 	struct bt_sdp_att_rsp *rsp;
@@ -1278,10 +1246,9 @@ static uint16_t sdp_svc_search_att_req(struct bt_sdp *sdp, struct net_buf *buf,
 			continue;
 		}
 
-		att_list_len += create_attr_list(sdp, record, filter,
-						 num_filters, max_att_len,
-						 SDP_SSA_CONT_STATE_SIZE + 1,
-						 next_att, &state, rsp_buf_cpy);
+		att_list_len += create_attr_list(sdp, record, filter, num_filters, max_att_len,
+						 SDP_SSA_CONT_STATE_SIZE + 1, next_att, &state,
+						 rsp_buf_cpy);
 
 		/* Check if packet is full and not dry run */
 		if (state.pkt_full && !dry_run) {
@@ -1323,19 +1290,18 @@ static uint16_t sdp_svc_search_att_req(struct bt_sdp *sdp, struct net_buf *buf,
 	}
 
 	LOG_DBG("Sending response, len %u", rsp_buf->len);
-	bt_sdp_send(&sdp->chan.chan, rsp_buf, BT_SDP_SVC_SEARCH_ATTR_RSP,
-		    tid);
+	bt_sdp_send(&sdp->chan.chan, rsp_buf, BT_SDP_SVC_SEARCH_ATTR_RSP, tid);
 
 	return 0;
 }
 
 static const struct {
-	uint8_t  op_code;
-	uint16_t  (*func)(struct bt_sdp *sdp, struct net_buf *buf, uint16_t tid);
+	uint8_t op_code;
+	uint16_t (*func)(struct bt_sdp *sdp, struct net_buf *buf, uint16_t tid);
 } handlers[] = {
-	{ BT_SDP_SVC_SEARCH_REQ, sdp_svc_search_req },
-	{ BT_SDP_SVC_ATTR_REQ, sdp_svc_att_req },
-	{ BT_SDP_SVC_SEARCH_ATTR_REQ, sdp_svc_search_att_req },
+	{BT_SDP_SVC_SEARCH_REQ, sdp_svc_search_req},
+	{BT_SDP_SVC_ATTR_REQ, sdp_svc_att_req},
+	{BT_SDP_SVC_SEARCH_ATTR_REQ, sdp_svc_search_att_req},
 };
 
 /* @brief Callback for SDP data receive
@@ -1350,8 +1316,7 @@ static const struct {
  */
 static int bt_sdp_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 {
-	struct bt_l2cap_br_chan *ch = CONTAINER_OF(chan,
-			struct bt_l2cap_br_chan, chan);
+	struct bt_l2cap_br_chan *ch = CONTAINER_OF(chan, struct bt_l2cap_br_chan, chan);
 	struct bt_sdp *sdp = CONTAINER_OF(ch, struct bt_sdp, chan);
 	struct bt_sdp_hdr *hdr;
 	uint16_t err = BT_SDP_INVALID_SYNTAX;
@@ -1476,8 +1441,7 @@ int bt_sdp_register_service(struct bt_sdp_record *service)
 	return 0;
 }
 
-#define GET_PARAM(__node) \
-	CONTAINER_OF(__node, struct bt_sdp_discover_params, _node)
+#define GET_PARAM(__node) CONTAINER_OF(__node, struct bt_sdp_discover_params, _node)
 
 /* ServiceSearch PDU, ref to BT Core 5.4, Vol 3, part B, 4.5.1 */
 static int sdp_client_ss_search(struct bt_sdp_client *session,
@@ -1642,16 +1606,14 @@ static int sdp_client_ssa_search(struct bt_sdp_client *session,
 		net_buf_add_u8(buf, 0x00);
 	} else {
 		net_buf_add_u8(buf, session->cstate.length);
-		net_buf_add_mem(buf, session->cstate.data,
-				session->cstate.length);
+		net_buf_add_mem(buf, session->cstate.data, session->cstate.length);
 	}
 
 	/* Update context param to the one being resolving now */
 	session->param = param;
 	session->tid++;
 
-	return bt_sdp_send(&session->chan.chan, buf, BT_SDP_SVC_SEARCH_ATTR_REQ,
-			   session->tid);
+	return bt_sdp_send(&session->chan.chan, buf, BT_SDP_SVC_SEARCH_ATTR_REQ, session->tid);
 }
 
 static void sdp_client_params_iterator(struct bt_sdp_client *session);
@@ -1735,8 +1697,8 @@ static void sdp_client_params_iterator(struct bt_sdp_client *session)
 	}
 }
 
-static uint16_t sdp_client_get_total(struct bt_sdp_client *session,
-				  struct net_buf *buf, uint16_t *total)
+static uint16_t sdp_client_get_total(struct bt_sdp_client *session, struct net_buf *buf,
+				     uint16_t *total)
 {
 	uint16_t pulled;
 	uint8_t seq;
@@ -1849,8 +1811,7 @@ enum uuid_state {
 	UUID_RESOLVED,
 };
 
-static void sdp_client_notify_result(struct bt_sdp_client *session,
-				     enum uuid_state state)
+static void sdp_client_notify_result(struct bt_sdp_client *session, enum uuid_state state)
 {
 	struct bt_conn *conn = session->chan.chan.conn;
 	struct bt_sdp_client_result result;
@@ -2182,15 +2143,14 @@ static void sdp_client_disconnected(struct bt_l2cap_chan *chan)
 	 * Reset session excluding L2CAP channel member. Let's the channel
 	 * resets autonomous.
 	 */
-	(void)memset(&session->reqs, 0,
-		     sizeof(*session) - sizeof(session->chan));
+	(void)memset(&session->reqs, 0, sizeof(*session) - sizeof(session->chan));
 }
 
 static const struct bt_l2cap_chan_ops sdp_client_chan_ops = {
-		.connected = sdp_client_connected,
-		.disconnected = sdp_client_disconnected,
-		.recv = sdp_client_receive,
-		.alloc_buf = sdp_client_alloc_buf,
+	.connected = sdp_client_connected,
+	.disconnected = sdp_client_disconnected,
+	.recv = sdp_client_receive,
+	.alloc_buf = sdp_client_alloc_buf,
 };
 
 static struct bt_sdp_client *sdp_client_new_session(struct bt_conn *conn)
@@ -2243,8 +2203,7 @@ static struct bt_sdp_client *sdp_client_get_session(struct bt_conn *conn)
 	return sdp_client_new_session(conn);
 }
 
-int bt_sdp_discover(struct bt_conn *conn,
-		    const struct bt_sdp_discover_params *params)
+int bt_sdp_discover(struct bt_conn *conn, const struct bt_sdp_discover_params *params)
 {
 	struct bt_sdp_client *session;
 
@@ -2479,35 +2438,34 @@ static ssize_t sdp_get_attr_value_len(const uint8_t *data, size_t len)
 err:
 	LOG_ERR("Too short buffer length %zu", len);
 	return -EMSGSIZE;
-
 }
 
 /* Type holding UUID item and related to it specific information. */
 struct bt_sdp_uuid_desc {
 	union {
-		struct bt_uuid    uuid;
+		struct bt_uuid uuid;
 		struct bt_uuid_16 uuid16;
 		struct bt_uuid_32 uuid32;
-	      };
-	uint16_t                     attr_id;
-	uint8_t                     *params;
-	uint16_t                     params_len;
+	};
+	uint16_t attr_id;
+	uint8_t *params;
+	uint16_t params_len;
 };
 
 /* Generic attribute item collector. */
 struct bt_sdp_attr_item {
 	/*  Attribute identifier. */
-	uint16_t                  attr_id;
+	uint16_t attr_id;
 	/*  Address of beginning attribute value taken from original buffer
 	 *  holding response from server.
 	 */
-	uint8_t                  *val;
+	uint8_t *val;
 	/*  Says about the length of attribute value. */
-	uint16_t                  len;
+	uint16_t len;
 };
 
-static int bt_sdp_get_attr(const struct net_buf *buf,
-			   struct bt_sdp_attr_item *attr, uint16_t attr_id)
+static int bt_sdp_get_attr(const struct net_buf *buf, struct bt_sdp_attr_item *attr,
+			   uint16_t attr_id)
 {
 	uint8_t *data;
 	uint16_t id;
@@ -2530,8 +2488,7 @@ static int bt_sdp_get_attr(const struct net_buf *buf,
 		LOG_DBG("Attribute ID 0x%04x", id);
 		data += sizeof(uint16_t);
 
-		dlen = sdp_get_attr_value_len(data,
-					      buf->len - (data - buf->data));
+		dlen = sdp_get_attr_value_len(data, buf->len - (data - buf->data));
 		if (dlen < 0) {
 			LOG_ERR("Invalid attribute value data");
 			return -EINVAL;
@@ -2642,10 +2599,8 @@ static int sdp_loop_seqs(uint8_t **data, size_t len)
 	return pre_slen;
 }
 
-static int sdp_get_uuid_data(const struct bt_sdp_attr_item *attr,
-			     struct bt_sdp_uuid_desc *pd,
-			     uint16_t proto_profile,
-			     uint8_t proto_profile_index)
+static int sdp_get_uuid_data(const struct bt_sdp_attr_item *attr, struct bt_sdp_uuid_desc *pd,
+			     uint16_t proto_profile, uint8_t proto_profile_index)
 {
 	/* get start address of attribute value */
 	uint8_t *p = attr->val;
@@ -2682,9 +2637,8 @@ static int sdp_get_uuid_data(const struct bt_sdp_attr_item *attr,
 		left -= sizeof(dtd);
 		switch (dtd) {
 		case BT_SDP_UUID16:
-			memcpy(&pd->uuid16,
-				BT_UUID_DECLARE_16(sys_get_be16(p)),
-				sizeof(struct bt_uuid_16));
+			memcpy(&pd->uuid16, BT_UUID_DECLARE_16(sys_get_be16(p)),
+			       sizeof(struct bt_uuid_16));
 			p += sizeof(uint16_t);
 			left -= sizeof(uint16_t);
 			break;
@@ -2694,9 +2648,8 @@ static int sdp_get_uuid_data(const struct bt_sdp_attr_item *attr,
 				return -EMSGSIZE;
 			}
 
-			memcpy(&pd->uuid32,
-				BT_UUID_DECLARE_32(sys_get_be32(p)),
-				sizeof(struct bt_uuid_32));
+			memcpy(&pd->uuid32, BT_UUID_DECLARE_32(sys_get_be32(p)),
+			       sizeof(struct bt_uuid_32));
 			p += sizeof(BT_UUID_SIZE_32);
 			left -= sizeof(BT_UUID_SIZE_32);
 			break;
@@ -2706,11 +2659,11 @@ static int sdp_get_uuid_data(const struct bt_sdp_attr_item *attr,
 		}
 
 		/*
-			* Check if current UUID value matches input one given by user.
-			* If found save it's location and length and return.
-			*/
+		 * Check if current UUID value matches input one given by user.
+		 * If found save it's location and length and return.
+		 */
 		if ((proto_profile == BT_UUID_16(&pd->uuid)->val) ||
-			(proto_profile == BT_UUID_32(&pd->uuid)->val)) {
+		    (proto_profile == BT_UUID_32(&pd->uuid)->val)) {
 			pd->params = p;
 			pd->params_len = left;
 
@@ -2789,8 +2742,7 @@ static int sdp_get_param_item(struct bt_sdp_uuid_desc *pd_item, uint16_t *param)
 	return 0;
 }
 
-int bt_sdp_get_proto_param(const struct net_buf *buf, enum bt_sdp_proto proto,
-			   uint16_t *param)
+int bt_sdp_get_proto_param(const struct net_buf *buf, enum bt_sdp_proto proto, uint16_t *param)
 {
 	struct bt_sdp_attr_item attr;
 	struct bt_sdp_uuid_desc pd;
@@ -2843,8 +2795,7 @@ int bt_sdp_get_addl_proto_param(const struct net_buf *buf, enum bt_sdp_proto pro
 	return sdp_get_param_item(&pd, param);
 }
 
-int bt_sdp_get_profile_version(const struct net_buf *buf, uint16_t profile,
-			       uint16_t *version)
+int bt_sdp_get_profile_version(const struct net_buf *buf, uint16_t profile, uint16_t *version)
 {
 	struct bt_sdp_attr_item attr;
 	struct bt_sdp_uuid_desc pd;
diff --git a/subsys/bluetooth/host/classic/sdp_internal.h b/subsys/bluetooth/host/classic/sdp_internal.h
index 1524318c4a1..95f7df2170c 100644
--- a/subsys/bluetooth/host/classic/sdp_internal.h
+++ b/subsys/bluetooth/host/classic/sdp_internal.h
@@ -37,22 +37,22 @@
 #define BT_SDP_INVALID_PDU_SIZE      0x0004
 #define BT_SDP_INVALID_CSTATE        0x0005
 
-#define BT_SDP_MAX_SERVICES   10
+#define BT_SDP_MAX_SERVICES 10
 
 struct bt_sdp_data_elem_seq {
-	uint8_t  type; /* Type: Will be data element sequence */
+	uint8_t type;  /* Type: Will be data element sequence */
 	uint16_t size; /* We only support 2 byte sizes for now */
 } __packed;
 
 struct bt_sdp_hdr {
-	uint8_t  op_code;
+	uint8_t op_code;
 	uint16_t tid;
 	uint16_t param_len;
 } __packed;
 
 struct bt_sdp_svc_rsp {
-	uint16_t  total_recs;
-	uint16_t  current_recs;
+	uint16_t total_recs;
+	uint16_t current_recs;
 } __packed;
 
 struct bt_sdp_att_rsp {
diff --git a/subsys/bluetooth/host/classic/shell/a2dp.c b/subsys/bluetooth/host/classic/shell/a2dp.c
index 2e8ffc5a08c..28f5425df68 100644
--- a/subsys/bluetooth/host/classic/shell/a2dp.c
+++ b/subsys/bluetooth/host/classic/shell/a2dp.c
@@ -43,86 +43,66 @@ static struct bt_a2dp_stream_ops stream_ops;
 
 #if defined(CONFIG_BT_A2DP_SOURCE)
 static uint8_t media_data[] = {
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
-0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
+	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
+	0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
+	0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,
+	0x0d, 0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
+	0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
+	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+	0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+	0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
+	0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
 };
 #endif
 
-NET_BUF_POOL_DEFINE(a2dp_tx_pool, CONFIG_BT_MAX_CONN,
-		BT_L2CAP_BUF_SIZE(CONFIG_BT_L2CAP_TX_MTU),
-		CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);
+NET_BUF_POOL_DEFINE(a2dp_tx_pool, CONFIG_BT_MAX_CONN, BT_L2CAP_BUF_SIZE(CONFIG_BT_L2CAP_TX_MTU),
+		    CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);
 
 static struct bt_sdp_attribute a2dp_sink_attrs[] = {
 	BT_SDP_NEW_SERVICE,
+	BT_SDP_LIST(BT_SDP_ATTR_SVCLASS_ID_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3), /* 35 03 */
+		    BT_SDP_DATA_ELEM_LIST(
+			    {
+				    BT_SDP_TYPE_SIZE(BT_SDP_UUID16),           /* 19 */
+				    BT_SDP_ARRAY_16(BT_SDP_AUDIO_SINK_SVCLASS) /* 11 0B */
+			    }, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROTO_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16), /* 35 10 */
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6), /* 35 06 */
+			     BT_SDP_DATA_ELEM_LIST(
+				     {
+					     BT_SDP_TYPE_SIZE(BT_SDP_UUID16),    /* 19 */
+					     BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP) /* 01 00 */
+				     },
+				     {
+					     BT_SDP_TYPE_SIZE(BT_SDP_UINT16),   /* 09 */
+					     BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL) /* 00 19 */
+				     }, )},
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6), /* 35 06 */
+			     BT_SDP_DATA_ELEM_LIST(
+				     {
+					     BT_SDP_TYPE_SIZE(BT_SDP_UUID16),   /* 19 */
+					     BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL) /* 00 19 */
+				     },
+				     {
+					     BT_SDP_TYPE_SIZE(BT_SDP_UINT16), /* 09 */
+					     BT_SDP_ARRAY_16(0x0100U) /* AVDTP version: 01 00 */
+				     }, )}, )),
 	BT_SDP_LIST(
-		BT_SDP_ATTR_SVCLASS_ID_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3), /* 35 03 */
+		BT_SDP_ATTR_PROFILE_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8), /* 35 08 */
 		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16), /* 19 */
-			BT_SDP_ARRAY_16(BT_SDP_AUDIO_SINK_SVCLASS) /* 11 0B */
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROTO_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),/* 35 10 */
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),/* 35 06 */
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16), /* 19 */
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP) /* 01 00 */
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16), /* 09 */
-				BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL) /* 00 19 */
-			},
-			)
-		},
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),/* 35 06 */
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16), /* 19 */
-				BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL) /* 00 19 */
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16), /* 09 */
-				BT_SDP_ARRAY_16(0x0100U) /* AVDTP version: 01 00 */
-			},
-			)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROFILE_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8), /* 35 08 */
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6), /* 35 06 */
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16), /* 19 */
-				BT_SDP_ARRAY_16(BT_SDP_ADVANCED_AUDIO_SVCLASS) /* 11 0d */
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16), /* 09 */
-				BT_SDP_ARRAY_16(0x0103U) /* 01 03 */
-			},
-			)
-		},
-		)
-	),
+			{BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6), /* 35 06 */
+			 BT_SDP_DATA_ELEM_LIST(
+				 {
+					 BT_SDP_TYPE_SIZE(BT_SDP_UUID16),               /* 19 */
+					 BT_SDP_ARRAY_16(BT_SDP_ADVANCED_AUDIO_SVCLASS) /* 11 0d */
+				 },
+				 {
+					 BT_SDP_TYPE_SIZE(BT_SDP_UINT16), /* 09 */
+					 BT_SDP_ARRAY_16(0x0103U)         /* 01 03 */
+				 }, )}, )),
 	BT_SDP_SERVICE_NAME("A2DPSink"),
 	BT_SDP_SUPPORTED_FEATURES(0x0001U),
 };
@@ -131,67 +111,28 @@ static struct bt_sdp_record a2dp_sink_rec = BT_SDP_RECORD(a2dp_sink_attrs);
 
 static struct bt_sdp_attribute a2dp_source_attrs[] = {
 	BT_SDP_NEW_SERVICE,
-	BT_SDP_LIST(
-		BT_SDP_ATTR_SVCLASS_ID_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_AUDIO_SOURCE_SVCLASS)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROTO_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL)
-			},
-			)
-		},
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(0x0100U)
-			},
-			)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROFILE_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_ADVANCED_AUDIO_SVCLASS)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(0x0103U)
-			},
-			)
-		},
-		)
-	),
+	BT_SDP_LIST(BT_SDP_ATTR_SVCLASS_ID_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
+		    BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+					   BT_SDP_ARRAY_16(BT_SDP_AUDIO_SOURCE_SVCLASS)}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROTO_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 16),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL)}, )},
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_UUID_AVDTP_VAL)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(0x0100U)}, )}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROFILE_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_ADVANCED_AUDIO_SVCLASS)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(0x0103U)}, )}, )),
 	BT_SDP_SERVICE_NAME("A2DPSink"),
 	BT_SDP_SUPPORTED_FEATURES(0x0001U),
 };
@@ -208,8 +149,8 @@ static void shell_a2dp_print_capabilities(struct bt_a2dp_ep_info *ep_info)
 	codec_ie = ep_info->codec_cap.codec_ie;
 	codec_ie_len = ep_info->codec_cap.len;
 	shell_print(ctx_shell, "endpoint id: %d, %s, %s:", ep_info->sep_info.id,
-			(ep_info->sep_info.tsep == BT_AVDTP_SINK) ? "(sink)" : "(source)",
-			(ep_info->sep_info.inuse) ? "(in use)" : "(idle)");
+		    (ep_info->sep_info.tsep == BT_AVDTP_SINK) ? "(sink)" : "(source)",
+		    (ep_info->sep_info.inuse) ? "(in use)" : "(idle)");
 	if (BT_A2DP_SBC == codec_type) {
 		shell_print(ctx_shell, "  codec type: SBC");
 
@@ -246,7 +187,7 @@ static void shell_a2dp_print_capabilities(struct bt_a2dp_ep_info *ep_info)
 			shell_print(ctx_shell, "	Joint-Stereo");
 		}
 
-		 /* Decode Support for Block Length */
+		/* Decode Support for Block Length */
 		shell_print(ctx_shell, "  Block Length:");
 		if (0U != (codec_ie[1U] & A2DP_SBC_BLK_LEN_4)) {
 			shell_print(ctx_shell, "	4 ");
@@ -279,8 +220,7 @@ static void shell_a2dp_print_capabilities(struct bt_a2dp_ep_info *ep_info)
 			shell_print(ctx_shell, "	Loudness");
 		}
 
-		shell_print(ctx_shell, "  Bitpool Range: %d - %d",
-					codec_ie[2U], codec_ie[3U]);
+		shell_print(ctx_shell, "  Bitpool Range: %d - %d", codec_ie[2U], codec_ie[3U]);
 	} else {
 		shell_print(ctx_shell, "  not SBC codecs");
 	}
@@ -302,9 +242,8 @@ void app_disconnected(struct bt_a2dp *a2dp)
 	shell_print(ctx_shell, "a2dp disconnected");
 }
 
-int app_config_req(struct bt_a2dp *a2dp, struct bt_a2dp_ep *ep,
-		struct bt_a2dp_codec_cfg *codec_cfg, struct bt_a2dp_stream **stream,
-		uint8_t *rsp_err_code)
+int app_config_req(struct bt_a2dp *a2dp, struct bt_a2dp_ep *ep, struct bt_a2dp_codec_cfg *codec_cfg,
+		   struct bt_a2dp_stream **stream, uint8_t *rsp_err_code)
 {
 	uint32_t sample_rate;
 
@@ -320,8 +259,8 @@ int app_config_req(struct bt_a2dp *a2dp, struct bt_a2dp_ep *ep,
 	return 0;
 }
 
-int app_reconfig_req(struct bt_a2dp_stream *stream,
-	struct bt_a2dp_codec_cfg *codec_cfg, uint8_t *rsp_err_code)
+int app_reconfig_req(struct bt_a2dp_stream *stream, struct bt_a2dp_codec_cfg *codec_cfg,
+		     uint8_t *rsp_err_code)
 {
 	uint32_t sample_rate;
 
@@ -437,8 +376,8 @@ void stream_aborted(struct bt_a2dp_stream *stream)
 	shell_print(ctx_shell, "stream aborted");
 }
 
-void sink_sbc_streamer_data(struct bt_a2dp_stream *stream, struct net_buf *buf,
-			uint16_t seq_num, uint32_t ts)
+void sink_sbc_streamer_data(struct bt_a2dp_stream *stream, struct net_buf *buf, uint16_t seq_num,
+			    uint32_t ts)
 {
 	uint8_t sbc_hdr;
 
@@ -447,13 +386,12 @@ void sink_sbc_streamer_data(struct bt_a2dp_stream *stream, struct net_buf *buf,
 	}
 	sbc_hdr = net_buf_pull_u8(buf);
 	shell_print(ctx_shell, "received, num of frames: %d, data length:%d",
-		(uint8_t)BT_A2DP_SBC_MEDIA_HDR_NUM_FRAMES_GET(sbc_hdr), buf->len);
-	shell_print(ctx_shell, "data: %d, %d, %d, %d, %d, %d ......", buf->data[0],
-		buf->data[1], buf->data[2], buf->data[3], buf->data[4], buf->data[5]);
+		    (uint8_t)BT_A2DP_SBC_MEDIA_HDR_NUM_FRAMES_GET(sbc_hdr), buf->len);
+	shell_print(ctx_shell, "data: %d, %d, %d, %d, %d, %d ......", buf->data[0], buf->data[1],
+		    buf->data[2], buf->data[3], buf->data[4], buf->data[5]);
 }
 
-void stream_recv(struct bt_a2dp_stream *stream,
-		struct net_buf *buf, uint16_t seq_num, uint32_t ts)
+void stream_recv(struct bt_a2dp_stream *stream, struct net_buf *buf, uint16_t seq_num, uint32_t ts)
 {
 	sink_sbc_streamer_data(stream, buf, seq_num, ts);
 }
@@ -513,8 +451,8 @@ static int cmd_register_ep(const struct shell *sh, int32_t argc, char *argv[])
 				a2dp_sink_sdp_registered = 1;
 				bt_sdp_register_service(&a2dp_sink_rec);
 			}
-			err = bt_a2dp_register_ep(&sink_sbc_endpoint,
-				BT_AVDTP_AUDIO, BT_AVDTP_SINK);
+			err = bt_a2dp_register_ep(&sink_sbc_endpoint, BT_AVDTP_AUDIO,
+						  BT_AVDTP_SINK);
 			if (!err) {
 				shell_print(sh, "SBC sink endpoint is registered");
 				registered_sbc_endpoint = &sink_sbc_endpoint;
@@ -524,8 +462,8 @@ static int cmd_register_ep(const struct shell *sh, int32_t argc, char *argv[])
 				a2dp_source_sdp_registered = 1;
 				bt_sdp_register_service(&a2dp_source_rec);
 			}
-			err = bt_a2dp_register_ep(&source_sbc_endpoint,
-				BT_AVDTP_AUDIO, BT_AVDTP_SOURCE);
+			err = bt_a2dp_register_ep(&source_sbc_endpoint, BT_AVDTP_AUDIO,
+						  BT_AVDTP_SOURCE);
 			if (!err) {
 				shell_print(sh, "SBC source endpoint is registered");
 				registered_sbc_endpoint = &source_sbc_endpoint;
@@ -626,9 +564,8 @@ static int cmd_configure(const struct shell *sh, int32_t argc, char *argv[])
 
 		bt_a2dp_stream_cb_register(&sbc_stream, &stream_ops);
 
-		err = bt_a2dp_stream_config(default_a2dp, &sbc_stream,
-			registered_sbc_endpoint, found_peer_sbc_endpoint,
-			&sbc_cfg_default);
+		err = bt_a2dp_stream_config(default_a2dp, &sbc_stream, registered_sbc_endpoint,
+					    found_peer_sbc_endpoint, &sbc_cfg_default);
 		if (err) {
 			shell_error(sh, "fail to configure");
 		}
@@ -651,14 +588,13 @@ static int cmd_reconfigure(const struct shell *sh, int32_t argc, char *argv[])
 	return 0;
 }
 
-static uint8_t bt_a2dp_discover_peer_endpoint_cb(struct bt_a2dp *a2dp,
-		struct bt_a2dp_ep_info *info, struct bt_a2dp_ep **ep)
+static uint8_t bt_a2dp_discover_peer_endpoint_cb(struct bt_a2dp *a2dp, struct bt_a2dp_ep_info *info,
+						 struct bt_a2dp_ep **ep)
 {
 	if (info != NULL) {
 		shell_print(ctx_shell, "find one endpoint");
 		shell_a2dp_print_capabilities(info);
-		if ((info->codec_type == BT_A2DP_SBC) &&
-		    (ep != NULL)) {
+		if ((info->codec_type == BT_A2DP_SBC) && (ep != NULL)) {
 			*ep = &peer_sbc_endpoint;
 			found_peer_sbc_endpoint = &peer_sbc_endpoint;
 		}
@@ -776,8 +712,8 @@ static int cmd_send_media(const struct shell *sh, int32_t argc, char *argv[])
 	net_buf_add_u8(buf, (uint8_t)BT_A2DP_SBC_MEDIA_HDR_ENCODE(1, 0, 0, 0));
 	net_buf_add_mem(buf, media_data, sizeof(media_data));
 	shell_print(sh, "num of frames: %d, data length: %d", 1U, sizeof(media_data));
-	shell_print(sh, "data: %d, %d, %d, %d, %d, %d ......", media_data[0],
-		media_data[1], media_data[2], media_data[3], media_data[4], media_data[5]);
+	shell_print(sh, "data: %d, %d, %d, %d, %d, %d ......", media_data[0], media_data[1],
+		    media_data[2], media_data[3], media_data[4], media_data[5]);
 
 	ret = bt_a2dp_stream_send(&sbc_stream, buf, 0U, 0U);
 	if (ret < 0) {
@@ -790,11 +726,12 @@ static int cmd_send_media(const struct shell *sh, int32_t argc, char *argv[])
 
 #define HELP_NONE "[none]"
 
-SHELL_STATIC_SUBCMD_SET_CREATE(a2dp_cmds,
-	SHELL_CMD_ARG(register_cb, NULL, "register a2dp connection callbacks",
-			cmd_register_cb, 1, 0),
-	SHELL_CMD_ARG(register_ep, NULL, "<type: sink or source> <value: sbc>",
-			cmd_register_ep, 3, 0),
+SHELL_STATIC_SUBCMD_SET_CREATE(
+	a2dp_cmds,
+	SHELL_CMD_ARG(register_cb, NULL, "register a2dp connection callbacks", cmd_register_cb, 1,
+		      0),
+	SHELL_CMD_ARG(register_ep, NULL, "<type: sink or source> <value: sbc>", cmd_register_ep, 3,
+		      0),
 	SHELL_CMD_ARG(connect, NULL, HELP_NONE, cmd_connect, 1, 0),
 	SHELL_CMD_ARG(disconnect, NULL, HELP_NONE, cmd_disconnect, 1, 0),
 	SHELL_CMD_ARG(discover_peer_eps, NULL, HELP_NONE, cmd_get_peer_eps, 1, 0),
@@ -805,9 +742,7 @@ SHELL_STATIC_SUBCMD_SET_CREATE(a2dp_cmds,
 	SHELL_CMD_ARG(start, NULL, "\"start the stream\"", cmd_start, 1, 0),
 	SHELL_CMD_ARG(suspend, NULL, "\"suspend the stream\"", cmd_suspend, 1, 0),
 	SHELL_CMD_ARG(abort, NULL, "\"abort the stream\"", cmd_abort, 1, 0),
-	SHELL_CMD_ARG(send_media, NULL, HELP_NONE, cmd_send_media, 1, 0),
-	SHELL_SUBCMD_SET_END
-);
+	SHELL_CMD_ARG(send_media, NULL, HELP_NONE, cmd_send_media, 1, 0), SHELL_SUBCMD_SET_END);
 
 static int cmd_a2dp(const struct shell *sh, size_t argc, char **argv)
 {
@@ -822,5 +757,4 @@ static int cmd_a2dp(const struct shell *sh, size_t argc, char **argv)
 	return -ENOEXEC;
 }
 
-SHELL_CMD_ARG_REGISTER(a2dp, &a2dp_cmds, "Bluetooth A2DP sh commands",
-			   cmd_a2dp, 1, 1);
+SHELL_CMD_ARG_REGISTER(a2dp, &a2dp_cmds, "Bluetooth A2DP sh commands", cmd_a2dp, 1, 1);
diff --git a/subsys/bluetooth/host/classic/shell/bredr.c b/subsys/bluetooth/host/classic/shell/bredr.c
index b59dee96fb7..1647c1a6da6 100644
--- a/subsys/bluetooth/host/classic/shell/bredr.c
+++ b/subsys/bluetooth/host/classic/shell/bredr.c
@@ -36,16 +36,14 @@
 static struct bt_conn *pairing_conn;
 #endif /* CONFIG_BT_CONN */
 
-#define DATA_BREDR_MTU		48
+#define DATA_BREDR_MTU 48
 
 NET_BUF_POOL_FIXED_DEFINE(data_pool, 1, DATA_BREDR_MTU, 8, NULL);
 
-#define SDP_CLIENT_USER_BUF_LEN		512
-NET_BUF_POOL_FIXED_DEFINE(sdp_client_pool, CONFIG_BT_MAX_CONN,
-			  SDP_CLIENT_USER_BUF_LEN, 8, NULL);
+#define SDP_CLIENT_USER_BUF_LEN 512
+NET_BUF_POOL_FIXED_DEFINE(sdp_client_pool, CONFIG_BT_MAX_CONN, SDP_CLIENT_USER_BUF_LEN, 8, NULL);
 
-static int cmd_auth_pincode(const struct shell *sh,
-			    size_t argc, char *argv[])
+static int cmd_auth_pincode(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_conn *conn;
 	uint8_t max = 16U;
@@ -64,8 +62,10 @@ static int cmd_auth_pincode(const struct shell *sh,
 	}
 
 	if (strlen(argv[1]) > max) {
-		shell_print(sh, "PIN code value invalid - enter max %u "
-			    "digits", max);
+		shell_print(sh,
+			    "PIN code value invalid - enter max %u "
+			    "digits",
+			    max);
 		return -ENOEXEC;
 	}
 
@@ -102,8 +102,8 @@ static int cmd_connect(const struct shell *sh, size_t argc, char *argv[])
 	return 0;
 }
 
-static void br_device_found(const bt_addr_t *addr, int8_t rssi,
-				  const uint8_t cod[3], const uint8_t eir[240])
+static void br_device_found(const bt_addr_t *addr, int8_t rssi, const uint8_t cod[3],
+			    const uint8_t eir[240])
 {
 	char br_addr[BT_ADDR_STR_LEN];
 	char name[239];
@@ -151,16 +151,14 @@ static void br_device_found(const bt_addr_t *addr, int8_t rssi,
 
 static struct bt_br_discovery_result br_discovery_results[5];
 
-static void br_discovery_complete(const struct bt_br_discovery_result *results,
-				  size_t count)
+static void br_discovery_complete(const struct bt_br_discovery_result *results, size_t count)
 {
 	size_t i;
 
 	shell_print(ctx_shell, "BR/EDR discovery complete");
 
 	for (i = 0; i < count; i++) {
-		br_device_found(&results[i].addr, results[i].rssi,
-				results[i].cod, results[i].eir);
+		br_device_found(&results[i].addr, results[i].rssi, results[i].cod, results[i].eir);
 	}
 }
 
@@ -218,8 +216,7 @@ static int cmd_discovery(const struct shell *sh, size_t argc, char *argv[])
 
 static int l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 {
-	shell_print(ctx_shell, "Incoming data channel %p len %u", chan,
-		    buf->len);
+	shell_print(ctx_shell, "Incoming data channel %p len %u", chan, buf->len);
 
 	return 0;
 }
@@ -242,16 +239,16 @@ static struct net_buf *l2cap_alloc_buf(struct bt_l2cap_chan *chan)
 }
 
 static const struct bt_l2cap_chan_ops l2cap_ops = {
-	.alloc_buf	= l2cap_alloc_buf,
-	.recv		= l2cap_recv,
-	.connected	= l2cap_connected,
-	.disconnected	= l2cap_disconnected,
+	.alloc_buf = l2cap_alloc_buf,
+	.recv = l2cap_recv,
+	.connected = l2cap_connected,
+	.disconnected = l2cap_disconnected,
 };
 
 static struct bt_l2cap_br_chan l2cap_chan = {
-	.chan.ops	= &l2cap_ops,
-	 /* Set for now min. MTU */
-	.rx.mtu		= 48,
+	.chan.ops = &l2cap_ops,
+	/* Set for now min. MTU */
+	.rx.mtu = 48,
 };
 
 static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_server *server,
@@ -273,8 +270,7 @@ static struct bt_l2cap_server br_server = {
 	.accept = l2cap_accept,
 };
 
-static int cmd_l2cap_register(const struct shell *sh,
-			      size_t argc, char *argv[])
+static int cmd_l2cap_register(const struct shell *sh, size_t argc, char *argv[])
 {
 	if (br_server.psm) {
 		shell_print(sh, "Already registered");
@@ -294,8 +290,7 @@ static int cmd_l2cap_register(const struct shell *sh,
 	return 0;
 }
 
-static int cmd_discoverable(const struct shell *sh,
-			    size_t argc, char *argv[])
+static int cmd_discoverable(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 	const char *action;
@@ -312,8 +307,10 @@ static int cmd_discoverable(const struct shell *sh,
 	}
 
 	if (err) {
-		shell_print(sh, "BR/EDR set/reset discoverable failed "
-			    "(err %d)", err);
+		shell_print(sh,
+			    "BR/EDR set/reset discoverable failed "
+			    "(err %d)",
+			    err);
 		return -ENOEXEC;
 	}
 
@@ -322,8 +319,7 @@ static int cmd_discoverable(const struct shell *sh,
 	return 0;
 }
 
-static int cmd_connectable(const struct shell *sh,
-			   size_t argc, char *argv[])
+static int cmd_connectable(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 	const char *action;
@@ -340,8 +336,10 @@ static int cmd_connectable(const struct shell *sh,
 	}
 
 	if (err) {
-		shell_print(sh, "BR/EDR set/rest connectable failed "
-			    "(err %d)", err);
+		shell_print(sh,
+			    "BR/EDR set/rest connectable failed "
+			    "(err %d)",
+			    err);
 		return -ENOEXEC;
 	}
 
@@ -369,8 +367,7 @@ static int cmd_oob(const struct shell *sh, size_t argc, char *argv[])
 	return 0;
 }
 
-static uint8_t sdp_hfp_ag_user(struct bt_conn *conn,
-			       struct bt_sdp_client_result *result,
+static uint8_t sdp_hfp_ag_user(struct bt_conn *conn, struct bt_sdp_client_result *result,
 			       const struct bt_sdp_discover_params *params)
 {
 	char addr[BT_ADDR_STR_LEN];
@@ -381,30 +378,33 @@ static uint8_t sdp_hfp_ag_user(struct bt_conn *conn,
 	conn_addr_str(conn, addr, sizeof(addr));
 
 	if (result && result->resp_buf) {
-		shell_print(ctx_shell, "SDP HFPAG data@%p (len %u) hint %u from"
-			    " remote %s", result->resp_buf,
-			    result->resp_buf->len, result->next_record_hint,
+		shell_print(ctx_shell,
+			    "SDP HFPAG data@%p (len %u) hint %u from"
+			    " remote %s",
+			    result->resp_buf, result->resp_buf->len, result->next_record_hint,
 			    addr);
 
 		/*
 		 * Focus to get BT_SDP_ATTR_PROTO_DESC_LIST attribute item to
 		 * get HFPAG Server Channel Number operating on RFCOMM protocol.
 		 */
-		err = bt_sdp_get_proto_param(result->resp_buf,
-					     BT_SDP_PROTO_RFCOMM, &param);
+		err = bt_sdp_get_proto_param(result->resp_buf, BT_SDP_PROTO_RFCOMM, &param);
 		if (err < 0) {
-			shell_error(ctx_shell, "Error getting Server CN, "
-				    "err %d", err);
+			shell_error(ctx_shell,
+				    "Error getting Server CN, "
+				    "err %d",
+				    err);
 			goto done;
 		}
 		shell_print(ctx_shell, "HFPAG Server CN param 0x%04x", param);
 
-		err = bt_sdp_get_profile_version(result->resp_buf,
-						 BT_SDP_HANDSFREE_SVCLASS,
+		err = bt_sdp_get_profile_version(result->resp_buf, BT_SDP_HANDSFREE_SVCLASS,
 						 &version);
 		if (err < 0) {
-			shell_error(ctx_shell, "Error getting profile version, "
-				    "err %d", err);
+			shell_error(ctx_shell,
+				    "Error getting profile version, "
+				    "err %d",
+				    err);
 			goto done;
 		}
 		shell_print(ctx_shell, "HFP version param 0x%04x", version);
@@ -415,22 +415,21 @@ static uint8_t sdp_hfp_ag_user(struct bt_conn *conn,
 		 */
 		err = bt_sdp_get_features(result->resp_buf, &features);
 		if (err < 0) {
-			shell_error(ctx_shell, "Error getting HFPAG Features, "
-				    "err %d", err);
+			shell_error(ctx_shell,
+				    "Error getting HFPAG Features, "
+				    "err %d",
+				    err);
 			goto done;
 		}
-		shell_print(ctx_shell, "HFPAG Supported Features param 0x%04x",
-		      features);
+		shell_print(ctx_shell, "HFPAG Supported Features param 0x%04x", features);
 	} else {
-		shell_print(ctx_shell, "No SDP HFPAG data from remote %s",
-			    addr);
+		shell_print(ctx_shell, "No SDP HFPAG data from remote %s", addr);
 	}
 done:
 	return BT_SDP_DISCOVER_UUID_CONTINUE;
 }
 
-static uint8_t sdp_a2src_user(struct bt_conn *conn,
-			      struct bt_sdp_client_result *result,
+static uint8_t sdp_a2src_user(struct bt_conn *conn, struct bt_sdp_client_result *result,
 			      const struct bt_sdp_discover_params *params)
 {
 	char addr[BT_ADDR_STR_LEN];
@@ -441,36 +440,38 @@ static uint8_t sdp_a2src_user(struct bt_conn *conn,
 	conn_addr_str(conn, addr, sizeof(addr));
 
 	if (result && result->resp_buf) {
-		shell_print(ctx_shell, "SDP A2SRC data@%p (len %u) hint %u from"
-			    " remote %s", result->resp_buf,
-			    result->resp_buf->len, result->next_record_hint,
+		shell_print(ctx_shell,
+			    "SDP A2SRC data@%p (len %u) hint %u from"
+			    " remote %s",
+			    result->resp_buf, result->resp_buf->len, result->next_record_hint,
 			    addr);
 
 		/*
 		 * Focus to get BT_SDP_ATTR_PROTO_DESC_LIST attribute item to
 		 * get A2SRC Server PSM Number.
 		 */
-		err = bt_sdp_get_proto_param(result->resp_buf,
-					     BT_SDP_PROTO_L2CAP, &param);
+		err = bt_sdp_get_proto_param(result->resp_buf, BT_SDP_PROTO_L2CAP, &param);
 		if (err < 0) {
-			shell_error(ctx_shell, "A2SRC PSM Number not found, "
-				    "err %d", err);
+			shell_error(ctx_shell,
+				    "A2SRC PSM Number not found, "
+				    "err %d",
+				    err);
 			goto done;
 		}
 
-		shell_print(ctx_shell, "A2SRC Server PSM Number param 0x%04x",
-			    param);
+		shell_print(ctx_shell, "A2SRC Server PSM Number param 0x%04x", param);
 
 		/*
 		 * Focus to get BT_SDP_ATTR_PROFILE_DESC_LIST attribute item to
 		 * get profile version number.
 		 */
-		err = bt_sdp_get_profile_version(result->resp_buf,
-						 BT_SDP_ADVANCED_AUDIO_SVCLASS,
+		err = bt_sdp_get_profile_version(result->resp_buf, BT_SDP_ADVANCED_AUDIO_SVCLASS,
 						 &version);
 		if (err < 0) {
-			shell_error(ctx_shell, "A2SRC version not found, "
-				    "err %d", err);
+			shell_error(ctx_shell,
+				    "A2SRC version not found, "
+				    "err %d",
+				    err);
 			goto done;
 		}
 		shell_print(ctx_shell, "A2SRC version param 0x%04x", version);
@@ -481,15 +482,15 @@ static uint8_t sdp_a2src_user(struct bt_conn *conn,
 		 */
 		err = bt_sdp_get_features(result->resp_buf, &features);
 		if (err < 0) {
-			shell_error(ctx_shell, "A2SRC Features not found, "
-				    "err %d", err);
+			shell_error(ctx_shell,
+				    "A2SRC Features not found, "
+				    "err %d",
+				    err);
 			goto done;
 		}
-		shell_print(ctx_shell, "A2SRC Supported Features param 0x%04x",
-		      features);
+		shell_print(ctx_shell, "A2SRC Supported Features param 0x%04x", features);
 	} else {
-		shell_print(ctx_shell, "No SDP A2SRC data from remote %s",
-			    addr);
+		shell_print(ctx_shell, "No SDP A2SRC data from remote %s", addr);
 	}
 done:
 	return BT_SDP_DISCOVER_UUID_CONTINUE;
@@ -511,8 +512,7 @@ static struct bt_sdp_discover_params discov_a2src = {
 
 static struct bt_sdp_discover_params discov;
 
-static int cmd_sdp_find_record(const struct shell *sh,
-			       size_t argc, char *argv[])
+static int cmd_sdp_find_record(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 	const char *action;
@@ -546,22 +546,20 @@ static int cmd_sdp_find_record(const struct shell *sh,
 	return 0;
 }
 
-#define HELP_NONE "[none]"
+#define HELP_NONE    "[none]"
 #define HELP_ADDR_LE "<address: XX:XX:XX:XX:XX:XX> <type: (public|random)>"
 
-SHELL_STATIC_SUBCMD_SET_CREATE(br_cmds,
-	SHELL_CMD_ARG(auth-pincode, NULL, "<pincode>", cmd_auth_pincode, 2, 0),
+SHELL_STATIC_SUBCMD_SET_CREATE(
+	br_cmds, SHELL_CMD_ARG(auth - pincode, NULL, "<pincode>", cmd_auth_pincode, 2, 0),
 	SHELL_CMD_ARG(connect, NULL, "<address>", cmd_connect, 2, 0),
-	SHELL_CMD_ARG(discovery, NULL,
-		      "<value: on, off> [length: 1-48] [mode: limited]",
+	SHELL_CMD_ARG(discovery, NULL, "<value: on, off> [length: 1-48] [mode: limited]",
 		      cmd_discovery, 2, 2),
 	SHELL_CMD_ARG(iscan, NULL, "<value: on, off>", cmd_discoverable, 2, 0),
-	SHELL_CMD_ARG(l2cap-register, NULL, "<psm>", cmd_l2cap_register, 2, 0),
+	SHELL_CMD_ARG(l2cap - register, NULL, "<psm>", cmd_l2cap_register, 2, 0),
 	SHELL_CMD_ARG(oob, NULL, NULL, cmd_oob, 1, 0),
 	SHELL_CMD_ARG(pscan, NULL, "<value: on, off>", cmd_connectable, 2, 0),
-	SHELL_CMD_ARG(sdp-find, NULL, "<HFPAG>", cmd_sdp_find_record, 2, 0),
-	SHELL_SUBCMD_SET_END
-);
+	SHELL_CMD_ARG(sdp - find, NULL, "<HFPAG>", cmd_sdp_find_record, 2, 0),
+	SHELL_SUBCMD_SET_END);
 
 static int cmd_br(const struct shell *sh, size_t argc, char **argv)
 {
@@ -575,5 +573,4 @@ static int cmd_br(const struct shell *sh, size_t argc, char **argv)
 	return -ENOEXEC;
 }
 
-SHELL_CMD_ARG_REGISTER(br, &br_cmds, "Bluetooth BR/EDR shell commands", cmd_br,
-		       1, 1);
+SHELL_CMD_ARG_REGISTER(br, &br_cmds, "Bluetooth BR/EDR shell commands", cmd_br, 1, 1);
diff --git a/subsys/bluetooth/host/classic/shell/rfcomm.c b/subsys/bluetooth/host/classic/shell/rfcomm.c
index a3990b59d86..8ed62bc1ce8 100644
--- a/subsys/bluetooth/host/classic/shell/rfcomm.c
+++ b/subsys/bluetooth/host/classic/shell/rfcomm.c
@@ -37,63 +37,26 @@ NET_BUF_POOL_FIXED_DEFINE(pool, 1, DATA_MTU, CONFIG_BT_CONN_TX_USER_DATA_SIZE, N
 
 static struct bt_sdp_attribute spp_attrs[] = {
 	BT_SDP_NEW_SERVICE,
-	BT_SDP_LIST(
-		BT_SDP_ATTR_SVCLASS_ID_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-			BT_SDP_ARRAY_16(BT_SDP_SERIAL_PORT_SVCLASS)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROTO_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 12),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)
-			},
-			)
-		},
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 5),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_PROTO_RFCOMM)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT8),
-				BT_SDP_ARRAY_8(BT_RFCOMM_CHAN_SPP)
-			},
-			)
-		},
-		)
-	),
-	BT_SDP_LIST(
-		BT_SDP_ATTR_PROFILE_DESC_LIST,
-		BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
-		BT_SDP_DATA_ELEM_LIST(
-		{
-			BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
-			BT_SDP_DATA_ELEM_LIST(
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
-				BT_SDP_ARRAY_16(BT_SDP_SERIAL_PORT_SVCLASS)
-			},
-			{
-				BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
-				BT_SDP_ARRAY_16(0x0102)
-			},
-			)
-		},
-		)
-	),
+	BT_SDP_LIST(BT_SDP_ATTR_SVCLASS_ID_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
+		    BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+					   BT_SDP_ARRAY_16(BT_SDP_SERIAL_PORT_SVCLASS)}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROTO_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 12),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 3),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_L2CAP)}, )},
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 5),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_PROTO_RFCOMM)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT8),
+						    BT_SDP_ARRAY_8(BT_RFCOMM_CHAN_SPP)}, )}, )),
+	BT_SDP_LIST(BT_SDP_ATTR_PROFILE_DESC_LIST, BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 8),
+		    BT_SDP_DATA_ELEM_LIST(
+			    {BT_SDP_TYPE_SIZE_VAR(BT_SDP_SEQ8, 6),
+			     BT_SDP_DATA_ELEM_LIST({BT_SDP_TYPE_SIZE(BT_SDP_UUID16),
+						    BT_SDP_ARRAY_16(BT_SDP_SERIAL_PORT_SVCLASS)},
+						   {BT_SDP_TYPE_SIZE(BT_SDP_UINT16),
+						    BT_SDP_ARRAY_16(0x0102)}, )}, )),
 	BT_SDP_SERVICE_NAME("Serial Port"),
 };
 
@@ -115,9 +78,9 @@ static void rfcomm_disconnected(struct bt_rfcomm_dlc *dlci)
 }
 
 static struct bt_rfcomm_dlc_ops rfcomm_ops = {
-	.recv		= rfcomm_recv,
-	.connected	= rfcomm_connected,
-	.disconnected	= rfcomm_disconnected,
+	.recv = rfcomm_recv,
+	.connected = rfcomm_connected,
+	.disconnected = rfcomm_disconnected,
 };
 
 static struct bt_rfcomm_dlc rfcomm_dlc = {
@@ -160,8 +123,7 @@ static int cmd_register(const struct shell *sh, size_t argc, char *argv[])
 		rfcomm_server.channel = 0U;
 		return -ENOEXEC;
 	} else {
-		shell_print(sh, "RFCOMM channel %u registered",
-			    rfcomm_server.channel);
+		shell_print(sh, "RFCOMM channel %u registered", rfcomm_server.channel);
 		bt_sdp_register_service(&spp_rec);
 	}
 
@@ -182,8 +144,7 @@ static int cmd_connect(const struct shell *sh, size_t argc, char *argv[])
 
 	err = bt_rfcomm_dlc_connect(default_conn, &rfcomm_dlc, channel);
 	if (err < 0) {
-		shell_error(sh, "Unable to connect to channel %d (err %u)",
-			    channel, err);
+		shell_error(sh, "Unable to connect to channel %d (err %u)", channel, err);
 	} else {
 		shell_print(sh, "RFCOMM connection pending");
 	}
@@ -193,7 +154,7 @@ static int cmd_connect(const struct shell *sh, size_t argc, char *argv[])
 
 static int cmd_send(const struct shell *sh, size_t argc, char *argv[])
 {
-	uint8_t buf_data[DATA_MTU] = { [0 ... (DATA_MTU - 1)] = 0xff };
+	uint8_t buf_data[DATA_MTU] = {[0 ...(DATA_MTU - 1)] = 0xff};
 	int ret, len, count = 1;
 	struct net_buf *buf;
 
@@ -230,16 +191,15 @@ static int cmd_disconnect(const struct shell *sh, size_t argc, char *argv[])
 	return err;
 }
 
-#define HELP_NONE "[none]"
+#define HELP_NONE    "[none]"
 #define HELP_ADDR_LE "<address: XX:XX:XX:XX:XX:XX> <type: (public|random)>"
 
 SHELL_STATIC_SUBCMD_SET_CREATE(rfcomm_cmds,
-	SHELL_CMD_ARG(register, NULL, HELP_NONE, cmd_register, 1, 0),
-	SHELL_CMD_ARG(connect, NULL, "<channel>", cmd_connect, 2, 0),
-	SHELL_CMD_ARG(disconnect, NULL, HELP_NONE, cmd_disconnect, 1, 0),
-	SHELL_CMD_ARG(send, NULL, "<number of packets>", cmd_send, 2, 0),
-	SHELL_SUBCMD_SET_END
-);
+			       SHELL_CMD_ARG(register, NULL, HELP_NONE, cmd_register, 1, 0),
+			       SHELL_CMD_ARG(connect, NULL, "<channel>", cmd_connect, 2, 0),
+			       SHELL_CMD_ARG(disconnect, NULL, HELP_NONE, cmd_disconnect, 1, 0),
+			       SHELL_CMD_ARG(send, NULL, "<number of packets>", cmd_send, 2, 0),
+			       SHELL_SUBCMD_SET_END);
 
 static int cmd_rfcomm(const struct shell *sh, size_t argc, char **argv)
 {
@@ -254,5 +214,4 @@ static int cmd_rfcomm(const struct shell *sh, size_t argc, char **argv)
 	return -ENOEXEC;
 }
 
-SHELL_CMD_ARG_REGISTER(rfcomm, &rfcomm_cmds, "Bluetooth RFCOMM shell commands",
-		       cmd_rfcomm, 1, 1);
+SHELL_CMD_ARG_REGISTER(rfcomm, &rfcomm_cmds, "Bluetooth RFCOMM shell commands", cmd_rfcomm, 1, 1);
diff --git a/subsys/bluetooth/host/classic/ssp.c b/subsys/bluetooth/host/classic/ssp.c
index 9ccf22d3632..43640a20952 100644
--- a/subsys/bluetooth/host/classic/ssp.c
+++ b/subsys/bluetooth/host/classic/ssp.c
@@ -25,19 +25,19 @@
 LOG_MODULE_REGISTER(bt_ssp);
 
 enum pairing_method {
-	LEGACY,			/* Legacy (pre-SSP) pairing */
-	JUST_WORKS,		/* JustWorks pairing */
-	PASSKEY_INPUT,		/* Passkey Entry input */
-	PASSKEY_DISPLAY,	/* Passkey Entry display */
-	PASSKEY_CONFIRM,	/* Passkey confirm */
+	LEGACY,          /* Legacy (pre-SSP) pairing */
+	JUST_WORKS,      /* JustWorks pairing */
+	PASSKEY_INPUT,   /* Passkey Entry input */
+	PASSKEY_DISPLAY, /* Passkey Entry display */
+	PASSKEY_CONFIRM, /* Passkey confirm */
 };
 
 /* based on table 5.7, Core Spec 4.2, Vol.3 Part C, 5.2.2.6 */
 static const uint8_t ssp_method[4 /* remote */][4 /* local */] = {
-	      { JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS },
-	      { JUST_WORKS, PASSKEY_CONFIRM, PASSKEY_INPUT, JUST_WORKS },
-	      { PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS },
-	      { JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS },
+	{JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS},
+	{JUST_WORKS, PASSKEY_CONFIRM, PASSKEY_INPUT, JUST_WORKS},
+	{PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS},
+	{JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS},
 };
 
 static int pin_code_neg_reply(const bt_addr_t *bdaddr)
@@ -207,8 +207,7 @@ static int ssp_confirm_neg_reply(struct bt_conn *conn)
 	cp = net_buf_add(buf, sizeof(*cp));
 	bt_addr_copy(&cp->bdaddr, &conn->br.dst);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_USER_CONFIRM_NEG_REPLY, buf,
-				    NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_USER_CONFIRM_NEG_REPLY, buf, NULL);
 }
 
 static void ssp_pairing_complete(struct bt_conn *conn, uint8_t status)
@@ -225,8 +224,7 @@ static void ssp_pairing_complete(struct bt_conn *conn, uint8_t status)
 		bool bond = !atomic_test_bit(conn->flags, BT_CONN_BR_NOBOND);
 		struct bt_conn_auth_info_cb *listener, *next;
 
-		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
-						  next, node) {
+		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 			if (listener->pairing_complete) {
 				listener->pairing_complete(conn, bond);
 			}
@@ -234,8 +232,7 @@ static void ssp_pairing_complete(struct bt_conn *conn, uint8_t status)
 	} else {
 		struct bt_conn_auth_info_cb *listener, *next;
 
-		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
-						  next, node) {
+		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 			if (listener->pairing_failed) {
 				listener->pairing_failed(conn, status);
 			}
@@ -251,8 +248,7 @@ static void ssp_auth(struct bt_conn *conn, uint32_t passkey)
 	 * If local required security is HIGH then MITM is mandatory.
 	 * MITM protection is no achievable when SSP 'justworks' is applied.
 	 */
-	if (conn->required_sec_level > BT_SECURITY_L2 &&
-	    conn->br.pairing_method == JUST_WORKS) {
+	if (conn->required_sec_level > BT_SECURITY_L2 && conn->br.pairing_method == JUST_WORKS) {
 		LOG_DBG("MITM protection infeasible for required security");
 		ssp_confirm_neg_reply(conn);
 		return;
@@ -278,8 +274,7 @@ static void ssp_auth(struct bt_conn *conn, uint32_t passkey)
 		 * [BT Core 4.2 table 5.7, Vol 3, Part C, 5.2.2.6]
 		 */
 		if (bt_auth && bt_auth->pairing_confirm &&
-		    !atomic_test_bit(conn->flags,
-				     BT_CONN_BR_PAIRING_INITIATOR)) {
+		    !atomic_test_bit(conn->flags, BT_CONN_BR_PAIRING_INITIATOR)) {
 			atomic_set_bit(conn->flags, BT_CONN_USER);
 			bt_auth->pairing_confirm(conn);
 			break;
@@ -325,8 +320,7 @@ static int ssp_passkey_neg_reply(struct bt_conn *conn)
 	cp = net_buf_add(buf, sizeof(*cp));
 	bt_addr_copy(&cp->bdaddr, &conn->br.dst);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_USER_PASSKEY_NEG_REPLY, buf,
-				    NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_USER_PASSKEY_NEG_REPLY, buf, NULL);
 }
 
 static int conn_auth(struct bt_conn *conn)
@@ -355,8 +349,7 @@ int bt_ssp_start_security(struct bt_conn *conn)
 		return -EBUSY;
 	}
 
-	if (get_io_capa() == BT_IO_NO_INPUT_OUTPUT &&
-	    conn->required_sec_level > BT_SECURITY_L2) {
+	if (get_io_capa() == BT_IO_NO_INPUT_OUTPUT && conn->required_sec_level > BT_SECURITY_L2) {
 		return -EINVAL;
 	}
 
@@ -406,8 +399,7 @@ int bt_ssp_auth_cancel(struct bt_conn *conn)
 	case PASSKEY_INPUT:
 		return ssp_passkey_neg_reply(conn);
 	case PASSKEY_DISPLAY:
-		return bt_conn_disconnect(conn,
-					  BT_HCI_ERR_AUTH_FAIL);
+		return bt_conn_disconnect(conn, BT_HCI_ERR_AUTH_FAIL);
 	case LEGACY:
 		return pin_code_neg_reply(&conn->br.dst);
 	default:
@@ -482,8 +474,7 @@ void bt_hci_link_key_notify(struct net_buf *buf)
 		 * Setting Combination Link Key as AUTHENTICATED means it was
 		 * successfully generated by 16 digits wide PIN code.
 		 */
-		if (atomic_test_and_clear_bit(conn->flags,
-					      BT_CONN_BR_LEGACY_SECURE)) {
+		if (atomic_test_and_clear_bit(conn->flags, BT_CONN_BR_LEGACY_SECURE)) {
 			conn->br.link_key->flags |= BT_LINK_KEY_AUTHENTICATED;
 		}
 		memcpy(conn->br.link_key->val, evt->link_key, 16);
@@ -504,13 +495,11 @@ void bt_hci_link_key_notify(struct net_buf *buf)
 		break;
 	default:
 		LOG_WRN("Unsupported Link Key type %u", evt->key_type);
-		(void)memset(conn->br.link_key->val, 0,
-			     sizeof(conn->br.link_key->val));
+		(void)memset(conn->br.link_key->val, 0, sizeof(conn->br.link_key->val));
 		break;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
-	    !atomic_test_bit(conn->flags, BT_CONN_BR_NOBOND)) {
+	if (IS_ENABLED(CONFIG_BT_SETTINGS) && !atomic_test_bit(conn->flags, BT_CONN_BR_NOBOND)) {
 		bt_keys_link_key_store(conn->br.link_key);
 	}
 
@@ -598,8 +587,7 @@ void io_capa_neg_reply(const bt_addr_t *bdaddr, const uint8_t reason)
 	struct bt_hci_cp_io_capability_neg_reply *cp;
 	struct net_buf *resp_buf;
 
-	resp_buf = bt_hci_cmd_create(BT_HCI_OP_IO_CAPABILITY_NEG_REPLY,
-				     sizeof(*cp));
+	resp_buf = bt_hci_cmd_create(BT_HCI_OP_IO_CAPABILITY_NEG_REPLY, sizeof(*cp));
 	if (!resp_buf) {
 		LOG_ERR("Out of command buffers");
 		return;
@@ -621,15 +609,13 @@ void bt_hci_io_capa_resp(struct net_buf *buf)
 
 	if (evt->authentication > BT_HCI_GENERAL_BONDING_MITM) {
 		LOG_ERR("Invalid remote authentication requirements");
-		io_capa_neg_reply(&evt->bdaddr,
-				  BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
+		io_capa_neg_reply(&evt->bdaddr, BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
 		return;
 	}
 
 	if (evt->capability > BT_IO_NO_INPUT_OUTPUT) {
 		LOG_ERR("Invalid remote io capability requirements");
-		io_capa_neg_reply(&evt->bdaddr,
-				  BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
+		io_capa_neg_reply(&evt->bdaddr, BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
 		return;
 	}
 
@@ -673,15 +659,13 @@ void bt_hci_io_capa_req(struct net_buf *buf)
 
 		err = bt_auth->pairing_accept(conn, NULL);
 		if (err != BT_SECURITY_ERR_SUCCESS) {
-			io_capa_neg_reply(&evt->bdaddr,
-					  BT_HCI_ERR_PAIRING_NOT_ALLOWED);
+			io_capa_neg_reply(&evt->bdaddr, BT_HCI_ERR_PAIRING_NOT_ALLOWED);
 			return;
 		}
 	}
 #endif
 
-	resp_buf = bt_hci_cmd_create(BT_HCI_OP_IO_CAPABILITY_REPLY,
-				     sizeof(*cp));
+	resp_buf = bt_hci_cmd_create(BT_HCI_OP_IO_CAPABILITY_REPLY, sizeof(*cp));
 	if (!resp_buf) {
 		LOG_ERR("Out of command buffers");
 		bt_conn_unref(conn);
@@ -843,8 +827,7 @@ void bt_hci_auth_complete(struct net_buf *buf)
 		 * Inform layers above HCI about non-zero authentication
 		 * status to make them able cleanup pending jobs.
 		 */
-		bt_conn_security_changed(conn, evt->status,
-					 bt_security_err_get(evt->status));
+		bt_conn_security_changed(conn, evt->status, bt_security_err_get(evt->status));
 	} else {
 		link_encr(handle);
 	}
diff --git a/subsys/bluetooth/host/conn.c b/subsys/bluetooth/host/conn.c
index f043e08b785..36ae1cbe68d 100644
--- a/subsys/bluetooth/host/conn.c
+++ b/subsys/bluetooth/host/conn.c
@@ -89,22 +89,21 @@ void bt_tx_irq_raise(void);
 /* Group Connected BT_CONN only in this */
 #if defined(CONFIG_BT_CONN)
 /* Peripheral timeout to initialize Connection Parameter Update procedure */
-#define CONN_UPDATE_TIMEOUT  K_MSEC(CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT)
+#define CONN_UPDATE_TIMEOUT K_MSEC(CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT)
 
 static void deferred_work(struct k_work *work);
 static void notify_connected(struct bt_conn *conn);
 
 static struct bt_conn acl_conns[CONFIG_BT_MAX_CONN];
 NET_BUF_POOL_DEFINE(acl_tx_pool, CONFIG_BT_L2CAP_TX_BUF_COUNT,
-		    BT_L2CAP_BUF_SIZE(CONFIG_BT_L2CAP_TX_MTU),
-		    CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);
+		    BT_L2CAP_BUF_SIZE(CONFIG_BT_L2CAP_TX_MTU), CONFIG_BT_CONN_TX_USER_DATA_SIZE,
+		    NULL);
 
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
 const struct bt_conn_auth_cb *bt_auth;
 sys_slist_t bt_auth_info_cbs = SYS_SLIST_STATIC_INIT(&bt_auth_info_cbs);
 #endif /* CONFIG_BT_SMP || CONFIG_BT_CLASSIC */
 
-
 static sys_slist_t conn_cbs = SYS_SLIST_STATIC_INIT(&conn_cbs);
 
 static struct bt_conn_tx conn_tx[CONFIG_BT_CONN_TX_MAX];
@@ -121,8 +120,8 @@ void frag_destroy(struct net_buf *buf);
 
 /* Storage for fragments (views) into the upper layers' PDUs. */
 /* TODO: remove user-data requirements */
-NET_BUF_POOL_FIXED_DEFINE(fragments, CONFIG_BT_CONN_FRAG_COUNT, 0,
-			  CONFIG_BT_CONN_TX_USER_DATA_SIZE, frag_destroy);
+NET_BUF_POOL_FIXED_DEFINE(fragments, CONFIG_BT_CONN_FRAG_COUNT, 0, CONFIG_BT_CONN_TX_USER_DATA_SIZE,
+			  frag_destroy);
 
 struct frag_md {
 	struct bt_buf_view_meta view_meta;
@@ -157,14 +156,13 @@ static struct net_buf *get_data_frag(struct net_buf *outside, size_t winsize)
 		return window;
 	}
 
-	window = bt_buf_make_view(window, outside,
-				  winsize, &get_frag_md(window)->view_meta);
+	window = bt_buf_make_view(window, outside, winsize, &get_frag_md(window)->view_meta);
 
 	LOG_DBG("get-acl-frag: outside %p window %p size %zu", outside, window, winsize);
 
 	return window;
 }
-#else /* !CONFIG_BT_CONN_TX */
+#else  /* !CONFIG_BT_CONN_TX */
 static struct net_buf *get_data_frag(struct net_buf *outside, size_t winsize)
 {
 	ARG_UNUSED(outside);
@@ -549,8 +547,7 @@ static enum bt_iso_timestamp contains_iso_timestamp(struct net_buf *buf)
 {
 	enum bt_iso_timestamp ts;
 
-	if (net_buf_headroom(buf) ==
-	    (BT_BUF_ISO_SIZE(0) - sizeof(struct bt_hci_iso_sdu_ts_hdr))) {
+	if (net_buf_headroom(buf) == (BT_BUF_ISO_SIZE(0) - sizeof(struct bt_hci_iso_sdu_ts_hdr))) {
 		ts = BT_ISO_TS_PRESENT;
 	} else {
 		ts = BT_ISO_TS_ABSENT;
@@ -625,14 +622,12 @@ static inline uint16_t conn_mtu(struct bt_conn *conn)
 
 static bool is_classic_conn(struct bt_conn *conn)
 {
-	return (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-		conn->type == BT_CONN_TYPE_BR);
+	return (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR);
 }
 
 static bool is_iso_tx_conn(struct bt_conn *conn)
 {
-	return IS_ENABLED(CONFIG_BT_ISO_TX) &&
-		conn->type == BT_CONN_TYPE_ISO;
+	return IS_ENABLED(CONFIG_BT_ISO_TX) && conn->type == BT_CONN_TYPE_ISO;
 }
 
 static bool is_le_conn(struct bt_conn *conn)
@@ -645,8 +640,7 @@ static bool is_acl_conn(struct bt_conn *conn)
 	return is_le_conn(conn) || is_classic_conn(conn);
 }
 
-static int send_buf(struct bt_conn *conn, struct net_buf *buf,
-		    size_t len, void *cb, void *ud)
+static int send_buf(struct bt_conn *conn, struct net_buf *buf, size_t len, void *cb, void *ud)
 {
 	struct net_buf *frag = NULL;
 	struct bt_conn_tx *tx = NULL;
@@ -665,8 +659,7 @@ static int send_buf(struct bt_conn *conn, struct net_buf *buf,
 		return -EIO;
 	}
 
-	LOG_DBG("conn %p buf %p len %zu buf->len %u cb %p ud %p",
-		conn, buf, len, buf->len, cb, ud);
+	LOG_DBG("conn %p buf %p len %zu buf->len %u cb %p ud %p", conn, buf, len, buf->len, cb, ud);
 
 	/* Acquire the right to send 1 packet to the controller */
 	if (k_sem_take(bt_conn_get_pkts(conn), K_NO_WAIT)) {
@@ -725,8 +718,7 @@ static int send_buf(struct bt_conn *conn, struct net_buf *buf,
 	/* At this point, the buffer is either a fragment or a full HCI packet.
 	 * The flags are also valid.
 	 */
-	LOG_DBG("conn %p buf %p len %u flags 0x%02x",
-		conn, frag, frag->len, flags);
+	LOG_DBG("conn %p buf %p len %u flags 0x%02x", conn, frag, frag->len, flags);
 
 	/* Keep track of sent buffers. We have to append _before_
 	 * sending, as we might get pre-empted if the HCI driver calls
@@ -744,7 +736,7 @@ static int send_buf(struct bt_conn *conn, struct net_buf *buf,
 	} else if (is_acl_conn(conn)) {
 		err = send_acl(conn, frag, flags);
 	} else {
-		err = -EINVAL;	/* Some animals disable asserts (╯°□°）╯︵ ┻━┻ */
+		err = -EINVAL; /* Some animals disable asserts (╯°□°）╯︵ ┻━┻ */
 		__ASSERT(false, "Invalid connection type %u", conn->type);
 	}
 
@@ -774,13 +766,11 @@ static int send_buf(struct bt_conn *conn, struct net_buf *buf,
 	return -EIO;
 }
 
-static struct k_poll_signal conn_change =
-		K_POLL_SIGNAL_INITIALIZER(conn_change);
+static struct k_poll_signal conn_change = K_POLL_SIGNAL_INITIALIZER(conn_change);
 
 static void conn_destroy(struct bt_conn *conn, void *data)
 {
-	if (conn->state == BT_CONN_CONNECTED ||
-	    conn->state == BT_CONN_DISCONNECTING) {
+	if (conn->state == BT_CONN_CONNECTED || conn->state == BT_CONN_DISCONNECTING) {
 		bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
 	}
 
@@ -800,7 +790,7 @@ static bool acl_has_data(struct bt_conn *conn)
 {
 	return sys_slist_peek_head(&conn->l2cap_data_ready) != NULL;
 }
-#endif	/* defined(CONFIG_BT_CONN) */
+#endif /* defined(CONFIG_BT_CONN) */
 
 /* Connection "Scheduler" of sorts:
  *
@@ -856,8 +846,7 @@ void bt_conn_data_ready(struct bt_conn *conn)
 		 * the list (in `get_conn_ready`).
 		 */
 		bt_conn_ref(conn);
-		sys_slist_append(&bt_dev.le.conn_ready,
-				 &conn->_conn_ready);
+		sys_slist_append(&bt_dev.le.conn_ready, &conn->_conn_ready);
 		LOG_DBG("raised");
 	} else {
 		LOG_DBG("already in list");
@@ -888,14 +877,13 @@ static bool dont_have_viewbufs(void)
 
 #else  /* !CONFIG_BT_CONN_TX */
 	return false;
-#endif	/* CONFIG_BT_CONN_TX */
+#endif /* CONFIG_BT_CONN_TX */
 }
 
 __maybe_unused static bool dont_have_methods(struct bt_conn *conn)
 {
-	return (conn->tx_data_pull == NULL) ||
-		(conn->get_and_clear_cb == NULL) ||
-		(conn->has_data == NULL);
+	return (conn->tx_data_pull == NULL) || (conn->get_and_clear_cb == NULL) ||
+	       (conn->has_data == NULL);
 }
 
 struct bt_conn *get_conn_ready(void)
@@ -903,7 +891,7 @@ struct bt_conn *get_conn_ready(void)
 	/* Here we only peek: we pop the conn (and insert it at the back if it
 	 * still has data) after the QoS function returns false.
 	 */
-	sys_snode_t *node  = sys_slist_peek_head(&bt_dev.le.conn_ready);
+	sys_snode_t *node = sys_slist_peek_head(&bt_dev.le.conn_ready);
 
 	if (node == NULL) {
 		return NULL;
@@ -938,8 +926,7 @@ struct bt_conn *get_conn_ready(void)
 	}
 
 	CHECKIF(dont_have_methods(conn)) {
-		LOG_DBG("conn %p (type %d) is missing mandatory methods",
-			conn, conn->type);
+		LOG_DBG("conn %p (type %d) is missing mandatory methods", conn, conn->type);
 
 		return NULL;
 	}
@@ -965,8 +952,8 @@ struct bt_conn *get_conn_ready(void)
 
 /* Crazy that this file is compiled even if this is not true, but here we are. */
 #if defined(CONFIG_BT_CONN)
-static void acl_get_and_clear_cb(struct bt_conn *conn, struct net_buf *buf,
-				 bt_conn_tx_cb_t *cb, void **ud)
+static void acl_get_and_clear_cb(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t *cb,
+				 void **ud)
 {
 	__ASSERT_NO_MSG(is_acl_conn(conn));
 
@@ -974,14 +961,12 @@ static void acl_get_and_clear_cb(struct bt_conn *conn, struct net_buf *buf,
 	*ud = closure_data(buf->user_data);
 	memset(buf->user_data, 0, buf->user_data_size);
 }
-#endif	/* defined(CONFIG_BT_CONN) */
+#endif /* defined(CONFIG_BT_CONN) */
 
 /* Acts as a "null-routed" bt_send(). This fn will decrease the refcount of
  * `buf` and call the user callback with an error code.
  */
-static void destroy_and_callback(struct bt_conn *conn,
-				 struct net_buf *buf,
-				 bt_conn_tx_cb_t cb,
+static void destroy_and_callback(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb,
 				 void *ud)
 {
 	if (!cb) {
@@ -1011,7 +996,7 @@ void bt_conn_suspend_tx(bool suspend)
 
 	bt_tx_irq_raise();
 }
-#endif	/* CONFIG_BT_TESTING */
+#endif /* CONFIG_BT_TESTING */
 
 void bt_conn_tx_processor(void)
 {
@@ -1080,8 +1065,7 @@ void bt_conn_tx_processor(void)
 		LOG_DBG("pop: cb %p userdata %p", cb, ud);
 	}
 
-	LOG_DBG("TX process: conn %p buf %p (%s)",
-		conn, buf, last_buf ? "last" : "frag");
+	LOG_DBG("TX process: conn %p buf %p (%s)", conn, buf, last_buf ? "last" : "frag");
 
 	int err = send_buf(conn, buf, buf_len, cb, ud);
 
@@ -1138,8 +1122,7 @@ static void process_unack_tx(struct bt_conn *conn)
 	}
 }
 
-struct bt_conn *conn_lookup_handle(struct bt_conn *conns, size_t size,
-				   uint16_t handle)
+struct bt_conn *conn_lookup_handle(struct bt_conn *conns, size_t size, uint16_t handle)
 {
 	int i;
 
@@ -1193,8 +1176,7 @@ void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
 		}
 		break;
 	case BT_CONN_INITIATING:
-		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-		    conn->type == BT_CONN_TYPE_LE) {
+		if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->type == BT_CONN_TYPE_LE) {
 			k_work_cancel_delayable(&conn->deferred_work);
 		}
 		break;
@@ -1213,8 +1195,7 @@ void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
 		}
 		k_poll_signal_raise(&conn_change, 0);
 
-		if (IS_ENABLED(CONFIG_BT_ISO) &&
-		    conn->type == BT_CONN_TYPE_ISO) {
+		if (IS_ENABLED(CONFIG_BT_ISO) && conn->type == BT_CONN_TYPE_ISO) {
 			bt_iso_connected(conn);
 			break;
 		}
@@ -1222,8 +1203,7 @@ void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
 #if defined(CONFIG_BT_CONN)
 		sys_slist_init(&conn->channels);
 
-		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-		    conn->role == BT_CONN_ROLE_PERIPHERAL) {
+		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->role == BT_CONN_ROLE_PERIPHERAL) {
 
 #if defined(CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS)
 			if (conn->type == BT_CONN_TYPE_LE) {
@@ -1232,8 +1212,7 @@ void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
 			}
 #endif /* CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS */
 
-			k_work_schedule(&conn->deferred_work,
-					CONN_UPDATE_TIMEOUT);
+			k_work_schedule(&conn->deferred_work, CONN_UPDATE_TIMEOUT);
 		}
 #endif /* CONFIG_BT_CONN */
 
@@ -1344,8 +1323,7 @@ void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
 		 * Timer is needed only for LE. For other link types controller
 		 * will handle connection timeout.
 		 */
-		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-		    conn->type == BT_CONN_TYPE_LE &&
+		if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->type == BT_CONN_TYPE_LE &&
 		    bt_dev.create_param.timeout != 0) {
 			k_work_schedule(&conn->deferred_work,
 					K_MSEC(10 * bt_dev.create_param.timeout));
@@ -1416,8 +1394,7 @@ struct bt_conn *bt_hci_conn_lookup_handle(uint16_t handle)
 	return bt_conn_lookup_handle(handle, BT_CONN_TYPE_ALL);
 }
 
-void bt_conn_foreach(enum bt_conn_type type,
-		     void (*func)(struct bt_conn *conn, void *data),
+void bt_conn_foreach(enum bt_conn_type type, void (*func)(struct bt_conn *conn, void *data),
 		     void *data)
 {
 	int i;
@@ -1554,22 +1531,19 @@ uint8_t bt_conn_index(const struct bt_conn *conn)
 #if defined(CONFIG_BT_ISO)
 	case BT_CONN_TYPE_ISO:
 		index = conn - iso_conns;
-		__ASSERT(index >= 0 && index < ARRAY_SIZE(iso_conns),
-			"Invalid bt_conn pointer");
+		__ASSERT(index >= 0 && index < ARRAY_SIZE(iso_conns), "Invalid bt_conn pointer");
 		break;
 #endif
 #if defined(CONFIG_BT_CLASSIC)
 	case BT_CONN_TYPE_SCO:
 		index = conn - sco_conns;
-		__ASSERT(index >= 0 && index < ARRAY_SIZE(sco_conns),
-			"Invalid bt_conn pointer");
+		__ASSERT(index >= 0 && index < ARRAY_SIZE(sco_conns), "Invalid bt_conn pointer");
 		break;
 #endif
 	default:
 #if defined(CONFIG_BT_CONN)
 		index = conn - acl_conns;
-		__ASSERT(index >= 0 && index < ARRAY_SIZE(acl_conns),
-			 "Invalid bt_conn pointer");
+		__ASSERT(index >= 0 && index < ARRAY_SIZE(acl_conns), "Invalid bt_conn pointer");
 #else
 		__ASSERT(false, "Invalid connection type %u", conn->type);
 #endif /* CONFIG_BT_CONN */
@@ -1579,15 +1553,12 @@ uint8_t bt_conn_index(const struct bt_conn *conn)
 	return (uint8_t)index;
 }
 
-
 #if defined(CONFIG_NET_BUF_LOG)
-struct net_buf *bt_conn_create_pdu_timeout_debug(struct net_buf_pool *pool,
-						 size_t reserve,
-						 k_timeout_t timeout,
-						 const char *func, int line)
+struct net_buf *bt_conn_create_pdu_timeout_debug(struct net_buf_pool *pool, size_t reserve,
+						 k_timeout_t timeout, const char *func, int line)
 #else
-struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool,
-					   size_t reserve, k_timeout_t timeout)
+struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool, size_t reserve,
+					   k_timeout_t timeout)
 #endif
 {
 	struct net_buf *buf;
@@ -1621,16 +1592,14 @@ struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool,
 		if (!buf) {
 			LOG_WRN("Unable to allocate buffer with K_NO_WAIT");
 #if defined(CONFIG_NET_BUF_LOG)
-			buf = net_buf_alloc_fixed_debug(pool, timeout, func,
-							line);
+			buf = net_buf_alloc_fixed_debug(pool, timeout, func, line);
 #else
 			buf = net_buf_alloc(pool, timeout);
 #endif
 		}
 	} else {
 #if defined(CONFIG_NET_BUF_LOG)
-		buf = net_buf_alloc_fixed_debug(pool, timeout, func,
-							line);
+		buf = net_buf_alloc_fixed_debug(pool, timeout, func, line);
 #else
 		buf = net_buf_alloc(pool, timeout);
 #endif
@@ -1685,7 +1654,7 @@ int bt_conn_disconnect(struct bt_conn *conn, uint8_t reason)
 
 	return 0;
 }
-#endif	/* !CONFIG_BT_CONN */
+#endif /* !CONFIG_BT_CONN */
 
 /* Group Connected BT_CONN only in this */
 #if defined(CONFIG_BT_CONN)
@@ -1973,16 +1942,14 @@ void notify_le_param_updated(struct bt_conn *conn)
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&conn_cbs, callback, _node) {
 		if (callback->le_param_updated) {
-			callback->le_param_updated(conn, conn->le.interval,
-						   conn->le.latency,
+			callback->le_param_updated(conn, conn->le.interval, conn->le.latency,
 						   conn->le.timeout);
 		}
 	}
 
 	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 		if (cb->le_param_updated) {
-			cb->le_param_updated(conn, conn->le.interval,
-					     conn->le.latency,
+			cb->le_param_updated(conn, conn->le.interval, conn->le.latency,
 					     conn->le.timeout);
 		}
 	}
@@ -2072,8 +2039,7 @@ bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param)
 	return true;
 }
 
-static int send_conn_le_param_update(struct bt_conn *conn,
-				const struct bt_le_conn_param *param)
+static int send_conn_le_param_update(struct bt_conn *conn, const struct bt_le_conn_param *param)
 {
 	LOG_DBG("conn %p features 0x%02x params (%d-%d %d %d)", conn, conn->le.features[0],
 		param->interval_min, param->interval_max, param->latency, param->timeout);
@@ -2089,7 +2055,7 @@ static int send_conn_le_param_update(struct bt_conn *conn,
 	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
 	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
 	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
-	     (conn->role == BT_HCI_ROLE_CENTRAL)) {
+	    (conn->role == BT_HCI_ROLE_CENTRAL)) {
 		int rc;
 
 		rc = bt_conn_le_conn_update(conn, param);
@@ -2187,8 +2153,7 @@ static void deferred_work(struct k_work *work)
 			struct bt_iso_chan *chan = iso->iso.chan;
 
 			if (chan != NULL) {
-				bt_iso_chan_set_state(chan,
-						      BT_ISO_STATE_DISCONNECTING);
+				bt_iso_chan_set_state(chan, BT_ISO_STATE_DISCONNECTING);
 			}
 
 			bt_iso_cleanup_acl(iso);
@@ -2209,8 +2174,7 @@ static void deferred_work(struct k_work *work)
 			struct bt_sco_chan *chan = sco->sco.chan;
 
 			if (chan != NULL) {
-				bt_sco_chan_set_state(chan,
-						      BT_SCO_STATE_DISCONNECTING);
+				bt_sco_chan_set_state(chan, BT_SCO_STATE_DISCONNECTING);
 			}
 
 			bt_sco_cleanup_acl(sco);
@@ -2233,8 +2197,7 @@ static void deferred_work(struct k_work *work)
 		return;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_CONN_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_CONN_ROLE_CENTRAL) {
 		/* we don't call bt_conn_disconnect as it would also clear
 		 * auto connect flag if it was set, instead just cancel
 		 * connection directly
@@ -2244,19 +2207,15 @@ static void deferred_work(struct k_work *work)
 	}
 
 	/* if application set own params use those, otherwise use defaults. */
-	if (atomic_test_and_clear_bit(conn->flags,
-				      BT_CONN_PERIPHERAL_PARAM_SET)) {
+	if (atomic_test_and_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET)) {
 		int err;
 
-		param = BT_LE_CONN_PARAM(conn->le.interval_min,
-					 conn->le.interval_max,
-					 conn->le.pending_latency,
-					 conn->le.pending_timeout);
+		param = BT_LE_CONN_PARAM(conn->le.interval_min, conn->le.interval_max,
+					 conn->le.pending_latency, conn->le.pending_timeout);
 
 		err = send_conn_le_param_update(conn, param);
 		if (!err) {
-			atomic_clear_bit(conn->flags,
-					 BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
+			atomic_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
 		} else {
 			LOG_WRN("Send LE param update failed (err %d)", err);
 		}
@@ -2265,18 +2224,14 @@ static void deferred_work(struct k_work *work)
 		int err;
 
 		param = BT_LE_CONN_PARAM(
-				CONFIG_BT_PERIPHERAL_PREF_MIN_INT,
-				CONFIG_BT_PERIPHERAL_PREF_MAX_INT,
-				CONFIG_BT_PERIPHERAL_PREF_LATENCY,
-				CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);
+			CONFIG_BT_PERIPHERAL_PREF_MIN_INT, CONFIG_BT_PERIPHERAL_PREF_MAX_INT,
+			CONFIG_BT_PERIPHERAL_PREF_LATENCY, CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);
 
 		err = send_conn_le_param_update(conn, param);
 		if (!err) {
-			atomic_set_bit(conn->flags,
-				       BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
+			atomic_set_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
 		} else {
-			LOG_WRN("Send auto LE param update failed (err %d)",
-				err);
+			LOG_WRN("Send auto LE param update failed (err %d)", err);
 		}
 #endif
 	}
@@ -2301,8 +2256,7 @@ static struct bt_conn *sco_conn_new(void)
 	return bt_conn_new(sco_conns, ARRAY_SIZE(sco_conns));
 }
 
-struct bt_conn *bt_conn_create_br(const bt_addr_t *peer,
-				  const struct bt_br_conn_param *param)
+struct bt_conn *bt_conn_create_br(const bt_addr_t *peer, const struct bt_br_conn_param *param)
 {
 	struct bt_hci_cp_connect *cp;
 	struct bt_conn *conn;
@@ -2337,7 +2291,7 @@ struct bt_conn *bt_conn_create_br(const bt_addr_t *peer,
 
 	memcpy(&cp->bdaddr, peer, sizeof(cp->bdaddr));
 	cp->packet_type = sys_cpu_to_le16(0xcc18); /* DM1 DH1 DM3 DH5 DM5 DH5 */
-	cp->pscan_rep_mode = 0x02; /* R2 */
+	cp->pscan_rep_mode = 0x02;                 /* R2 */
 	cp->allow_role_switch = param->allow_role_switch ? 0x01 : 0x00;
 	cp->clock_offset = 0x0000; /* TODO used cached clock offset */
 
@@ -2424,15 +2378,12 @@ struct bt_conn *bt_conn_add_sco(const bt_addr_t *peer, int link_type)
 
 	if (link_type == BT_HCI_SCO) {
 		if (BT_FEAT_LMP_ESCO_CAPABLE(bt_dev.features)) {
-			sco_conn->sco.pkt_type = (bt_dev.br.esco_pkt_type &
-						  ESCO_PKT_MASK);
+			sco_conn->sco.pkt_type = (bt_dev.br.esco_pkt_type & ESCO_PKT_MASK);
 		} else {
-			sco_conn->sco.pkt_type = (bt_dev.br.esco_pkt_type &
-						  SCO_PKT_MASK);
+			sco_conn->sco.pkt_type = (bt_dev.br.esco_pkt_type & SCO_PKT_MASK);
 		}
 	} else if (link_type == BT_HCI_ESCO) {
-		sco_conn->sco.pkt_type = (bt_dev.br.esco_pkt_type &
-					  ~EDR_ESCO_PKT_MASK);
+		sco_conn->sco.pkt_type = (bt_dev.br.esco_pkt_type & ~EDR_ESCO_PKT_MASK);
 	}
 
 	return sco_conn;
@@ -2516,7 +2467,6 @@ void bt_conn_identity_resolved(struct bt_conn *conn)
 		rpa = &conn->le.init_addr;
 	}
 
-
 	struct bt_conn_cb *callback;
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&conn_cbs, callback, _node) {
@@ -2532,8 +2482,8 @@ void bt_conn_identity_resolved(struct bt_conn *conn)
 	}
 }
 
-int bt_conn_le_start_encryption(struct bt_conn *conn, uint8_t rand[8],
-				uint8_t ediv[2], const uint8_t *ltk, size_t len)
+int bt_conn_le_start_encryption(struct bt_conn *conn, uint8_t rand[8], uint8_t ediv[2],
+				const uint8_t *ltk, size_t len)
 {
 	struct bt_hci_cp_le_start_encryption *cp;
 	struct net_buf *buf;
@@ -2568,16 +2518,14 @@ uint8_t bt_conn_enc_key_size(const struct bt_conn *conn)
 		return 0;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		struct bt_hci_cp_read_encryption_key_size *cp;
 		struct bt_hci_rp_read_encryption_key_size *rp;
 		struct net_buf *buf;
 		struct net_buf *rsp;
 		uint8_t key_size;
 
-		buf = bt_hci_cmd_create(BT_HCI_OP_READ_ENCRYPTION_KEY_SIZE,
-					sizeof(*cp));
+		buf = bt_hci_cmd_create(BT_HCI_OP_READ_ENCRYPTION_KEY_SIZE, sizeof(*cp));
 		if (!buf) {
 			return 0;
 		}
@@ -2585,8 +2533,7 @@ uint8_t bt_conn_enc_key_size(const struct bt_conn *conn)
 		cp = net_buf_add(buf, sizeof(*cp));
 		cp->handle = sys_cpu_to_le16(conn->handle);
 
-		if (bt_hci_cmd_send_sync(BT_HCI_OP_READ_ENCRYPTION_KEY_SIZE,
-					buf, &rsp)) {
+		if (bt_hci_cmd_send_sync(BT_HCI_OP_READ_ENCRYPTION_KEY_SIZE, buf, &rsp)) {
 			return 0;
 		}
 
@@ -2622,8 +2569,7 @@ static void reset_pairing(struct bt_conn *conn)
 	conn->required_sec_level = conn->sec_level;
 }
 
-void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err,
-			      enum bt_security_err err)
+void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err, enum bt_security_err err)
 {
 	reset_pairing(conn);
 	bt_l2cap_security_changed(conn, hci_err);
@@ -2656,7 +2602,6 @@ void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err,
 			bt_keys_link_key_update_usage(&conn->br.dst);
 		}
 #endif /* CONFIG_BT_CLASSIC */
-
 	}
 #endif
 }
@@ -2792,8 +2737,7 @@ struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer)
 	return conn;
 }
 
-bool bt_conn_is_peer_addr_le(const struct bt_conn *conn, uint8_t id,
-			     const bt_addr_le_t *peer)
+bool bt_conn_is_peer_addr_le(const struct bt_conn *conn, uint8_t id, const bt_addr_le_t *peer)
 {
 	if (id != conn->id) {
 		return false;
@@ -2967,8 +2911,7 @@ int bt_conn_get_info(const struct bt_conn *conn, struct bt_conn_info *info)
 	return -EINVAL;
 }
 
-int bt_conn_get_remote_info(struct bt_conn *conn,
-			    struct bt_conn_remote_info *remote_info)
+int bt_conn_get_remote_info(struct bt_conn *conn, struct bt_conn_remote_info *remote_info)
 {
 	if (!atomic_test_bit(conn->flags, BT_CONN_LE_FEATURES_EXCHANGED) ||
 	    (IS_ENABLED(CONFIG_BT_REMOTE_VERSION) &&
@@ -2995,7 +2938,7 @@ int bt_conn_get_remote_info(struct bt_conn *conn,
 #if defined(CONFIG_BT_CLASSIC)
 	case BT_CONN_TYPE_BR:
 		/* TODO: Make sure the HCI commands to read br features and
-		*  extended features has finished. */
+		 *  extended features has finished. */
 		return -ENOTSUP;
 #endif
 	default:
@@ -3004,8 +2947,7 @@ int bt_conn_get_remote_info(struct bt_conn *conn,
 }
 
 /* Read Transmit Power Level HCI command */
-static int bt_conn_get_tx_power_level(struct bt_conn *conn, uint8_t type,
-				      int8_t *tx_power_level)
+static int bt_conn_get_tx_power_level(struct bt_conn *conn, uint8_t type, int8_t *tx_power_level)
 {
 	int err;
 	struct bt_hci_rp_read_tx_power_level *rp;
@@ -3027,7 +2969,7 @@ static int bt_conn_get_tx_power_level(struct bt_conn *conn, uint8_t type,
 		return err;
 	}
 
-	rp = (void *) rsp->data;
+	rp = (void *)rsp->data;
 	*tx_power_level = rp->tx_power_level;
 	net_buf_unref(rsp);
 
@@ -3035,8 +2977,7 @@ static int bt_conn_get_tx_power_level(struct bt_conn *conn, uint8_t type,
 }
 
 #if defined(CONFIG_BT_TRANSMIT_POWER_CONTROL)
-void notify_tx_power_report(struct bt_conn *conn,
-			    struct bt_conn_le_tx_power_report report)
+void notify_tx_power_report(struct bt_conn *conn, struct bt_conn_le_tx_power_report report)
 {
 	struct bt_conn_cb *callback;
 
@@ -3046,8 +2987,7 @@ void notify_tx_power_report(struct bt_conn *conn,
 		}
 	}
 
-	STRUCT_SECTION_FOREACH(bt_conn_cb, cb)
-	{
+	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 		if (cb->tx_power_report) {
 			cb->tx_power_report(conn, &report);
 		}
@@ -3081,7 +3021,7 @@ int bt_conn_le_enhanced_get_tx_power_level(struct bt_conn *conn,
 		return err;
 	}
 
-	rp = (void *) rsp->data;
+	rp = (void *)rsp->data;
 	tx_power->phy = rp->phy;
 	tx_power->current_level = rp->current_tx_power_level;
 	tx_power->max_level = rp->max_tx_power_level;
@@ -3090,8 +3030,7 @@ int bt_conn_le_enhanced_get_tx_power_level(struct bt_conn *conn,
 	return 0;
 }
 
-int bt_conn_le_get_remote_tx_power_level(struct bt_conn *conn,
-					 enum bt_conn_le_tx_power_phy phy)
+int bt_conn_le_get_remote_tx_power_level(struct bt_conn *conn, enum bt_conn_le_tx_power_phy phy)
 {
 	struct bt_hci_cp_le_read_tx_power_level *cp;
 	struct net_buf *buf;
@@ -3112,8 +3051,7 @@ int bt_conn_le_get_remote_tx_power_level(struct bt_conn *conn,
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_REMOTE_TX_POWER_LEVEL, buf, NULL);
 }
 
-int bt_conn_le_set_tx_power_report_enable(struct bt_conn *conn,
-					  bool local_enable,
+int bt_conn_le_set_tx_power_report_enable(struct bt_conn *conn, bool local_enable,
 					  bool remote_enable)
 {
 	struct bt_hci_cp_le_set_tx_power_report_enable *cp;
@@ -3126,17 +3064,16 @@ int bt_conn_le_set_tx_power_report_enable(struct bt_conn *conn,
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	cp->handle = sys_cpu_to_le16(conn->handle);
-	cp->local_enable = local_enable ? BT_HCI_LE_TX_POWER_REPORT_ENABLE :
-		BT_HCI_LE_TX_POWER_REPORT_DISABLE;
-	cp->remote_enable = remote_enable ? BT_HCI_LE_TX_POWER_REPORT_ENABLE :
-		BT_HCI_LE_TX_POWER_REPORT_DISABLE;
+	cp->local_enable =
+		local_enable ? BT_HCI_LE_TX_POWER_REPORT_ENABLE : BT_HCI_LE_TX_POWER_REPORT_DISABLE;
+	cp->remote_enable = remote_enable ? BT_HCI_LE_TX_POWER_REPORT_ENABLE
+					  : BT_HCI_LE_TX_POWER_REPORT_DISABLE;
 
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_TX_POWER_REPORT_ENABLE, buf, NULL);
 }
 #endif /* CONFIG_BT_TRANSMIT_POWER_CONTROL */
 
-int bt_conn_le_get_tx_power_level(struct bt_conn *conn,
-				  struct bt_conn_le_tx_power *tx_power_level)
+int bt_conn_le_get_tx_power_level(struct bt_conn *conn, struct bt_conn_le_tx_power *tx_power_level)
 {
 	int err;
 
@@ -3154,8 +3091,7 @@ int bt_conn_le_get_tx_power_level(struct bt_conn *conn,
 		return err;
 	}
 
-	err = bt_conn_get_tx_power_level(conn, BT_TX_POWER_LEVEL_MAX,
-					 &tx_power_level->max_level);
+	err = bt_conn_get_tx_power_level(conn, BT_TX_POWER_LEVEL_MAX, &tx_power_level->max_level);
 	return err;
 }
 
@@ -3171,8 +3107,7 @@ void notify_path_loss_threshold_report(struct bt_conn *conn,
 		}
 	}
 
-	STRUCT_SECTION_FOREACH(bt_conn_cb, cb)
-	{
+	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 		if (cb->path_loss_threshold_report) {
 			cb->path_loss_threshold_report(conn, &report);
 		}
@@ -3213,16 +3148,15 @@ int bt_conn_le_set_path_loss_mon_enable(struct bt_conn *conn, bool reporting_ena
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	cp->handle = sys_cpu_to_le16(conn->handle);
-	cp->enable = reporting_enable ? BT_HCI_LE_PATH_LOSS_REPORTING_ENABLE :
-			BT_HCI_LE_PATH_LOSS_REPORTING_DISABLE;
+	cp->enable = reporting_enable ? BT_HCI_LE_PATH_LOSS_REPORTING_ENABLE
+				      : BT_HCI_LE_PATH_LOSS_REPORTING_DISABLE;
 
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PATH_LOSS_REPORTING_ENABLE, buf, NULL);
 }
 #endif /* CONFIG_BT_PATH_LOSS_MONITORING */
 
 #if defined(CONFIG_BT_SUBRATING)
-void notify_subrate_change(struct bt_conn *conn,
-			   const struct bt_conn_le_subrate_changed params)
+void notify_subrate_change(struct bt_conn *conn, const struct bt_conn_le_subrate_changed params)
 {
 	struct bt_conn_cb *callback;
 
@@ -3232,8 +3166,7 @@ void notify_subrate_change(struct bt_conn *conn,
 		}
 	}
 
-	STRUCT_SECTION_FOREACH(bt_conn_cb, cb)
-	{
+	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 		if (cb->subrate_changed) {
 			cb->subrate_changed(conn, &params);
 		}
@@ -3250,8 +3183,7 @@ static bool le_subrate_common_params_valid(const struct bt_conn_le_subrate_param
 		return false;
 	}
 
-	if (param->max_latency > 0x01F3 ||
-	    param->subrate_max * (param->max_latency + 1) > 500) {
+	if (param->max_latency > 0x01F3 || param->subrate_max * (param->max_latency + 1) > 500) {
 		return false;
 	}
 
@@ -3260,8 +3192,7 @@ static bool le_subrate_common_params_valid(const struct bt_conn_le_subrate_param
 		return false;
 	}
 
-	if (param->supervision_timeout < 0x000A ||
-	    param->supervision_timeout > 0xC80) {
+	if (param->supervision_timeout < 0x000A || param->supervision_timeout > 0xC80) {
 		return false;
 	}
 
@@ -3296,8 +3227,7 @@ int bt_conn_le_subrate_set_defaults(const struct bt_conn_le_subrate_param *param
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DEFAULT_SUBRATE, buf, NULL);
 }
 
-int bt_conn_le_subrate_request(struct bt_conn *conn,
-			       const struct bt_conn_le_subrate_param *params)
+int bt_conn_le_subrate_request(struct bt_conn *conn, const struct bt_conn_le_subrate_param *params)
 {
 	struct bt_hci_cp_le_subrate_request *cp;
 	struct net_buf *buf;
@@ -3445,14 +3375,12 @@ void notify_cs_subevent_result(struct bt_conn *conn, struct bt_conn_le_cs_subeve
 }
 #endif /* CONFIG_BT_CHANNEL_SOUNDING */
 
-int bt_conn_le_param_update(struct bt_conn *conn,
-			    const struct bt_le_conn_param *param)
+int bt_conn_le_param_update(struct bt_conn *conn, const struct bt_le_conn_param *param)
 {
 	LOG_DBG("conn %p features 0x%02x params (%d-%d %d %d)", conn, conn->le.features[0],
 		param->interval_min, param->interval_max, param->latency, param->timeout);
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_CONN_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_CONN_ROLE_CENTRAL) {
 		return send_conn_le_param_update(conn, param);
 	}
 
@@ -3474,8 +3402,7 @@ int bt_conn_le_param_update(struct bt_conn *conn,
 }
 
 #if defined(CONFIG_BT_USER_DATA_LEN_UPDATE)
-int bt_conn_le_data_len_update(struct bt_conn *conn,
-			       const struct bt_conn_le_data_len_param *param)
+int bt_conn_le_data_len_update(struct bt_conn *conn, const struct bt_conn_le_data_len_param *param)
 {
 	if (conn->le.data_len.tx_max_len == param->tx_max_len &&
 	    conn->le.data_len.tx_max_time == param->tx_max_time) {
@@ -3487,8 +3414,7 @@ int bt_conn_le_data_len_update(struct bt_conn *conn,
 #endif /* CONFIG_BT_USER_DATA_LEN_UPDATE */
 
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
-int bt_conn_le_phy_update(struct bt_conn *conn,
-			  const struct bt_conn_le_phy_param *param)
+int bt_conn_le_phy_update(struct bt_conn *conn, const struct bt_conn_le_phy_param *param)
 {
 	uint8_t phy_opts, all_phys;
 
@@ -3512,14 +3438,12 @@ int bt_conn_le_phy_update(struct bt_conn *conn,
 		all_phys |= BT_HCI_LE_PHY_RX_ANY;
 	}
 
-	return bt_le_set_phy(conn, all_phys, param->pref_tx_phy,
-			     param->pref_rx_phy, phy_opts);
+	return bt_le_set_phy(conn, all_phys, param->pref_tx_phy, param->pref_rx_phy, phy_opts);
 }
 #endif
 
 #if defined(CONFIG_BT_CENTRAL)
-static void bt_conn_set_param_le(struct bt_conn *conn,
-				 const struct bt_le_conn_param *param)
+static void bt_conn_set_param_le(struct bt_conn *conn, const struct bt_le_conn_param *param)
 {
 	conn->le.interval_min = param->interval_min;
 	conn->le.interval_max = param->interval_max;
@@ -3531,20 +3455,17 @@ static void create_param_setup(const struct bt_conn_le_create_param *param)
 {
 	bt_dev.create_param = *param;
 
-	bt_dev.create_param.timeout =
-		(bt_dev.create_param.timeout != 0) ?
-		bt_dev.create_param.timeout :
-		(MSEC_PER_SEC / 10) * CONFIG_BT_CREATE_CONN_TIMEOUT;
+	bt_dev.create_param.timeout = (bt_dev.create_param.timeout != 0)
+					      ? bt_dev.create_param.timeout
+					      : (MSEC_PER_SEC / 10) * CONFIG_BT_CREATE_CONN_TIMEOUT;
 
-	bt_dev.create_param.interval_coded =
-		(bt_dev.create_param.interval_coded != 0) ?
-		bt_dev.create_param.interval_coded :
-		bt_dev.create_param.interval;
+	bt_dev.create_param.interval_coded = (bt_dev.create_param.interval_coded != 0)
+						     ? bt_dev.create_param.interval_coded
+						     : bt_dev.create_param.interval;
 
-	bt_dev.create_param.window_coded =
-		(bt_dev.create_param.window_coded != 0) ?
-		bt_dev.create_param.window_coded :
-		bt_dev.create_param.window;
+	bt_dev.create_param.window_coded = (bt_dev.create_param.window_coded != 0)
+						   ? bt_dev.create_param.window_coded
+						   : bt_dev.create_param.window;
 }
 
 #if defined(CONFIG_BT_FILTER_ACCEPT_LIST)
@@ -3682,7 +3603,7 @@ static int conn_le_create_common_checks(const bt_addr_le_t *peer,
 }
 
 static struct bt_conn *conn_le_create_helper(const bt_addr_le_t *peer,
-				     const struct bt_le_conn_param *conn_param)
+					     const struct bt_le_conn_param *conn_param)
 {
 	bt_addr_le_t dst;
 	struct bt_conn *conn;
@@ -3737,8 +3658,7 @@ int bt_conn_le_create(const bt_addr_le_t *peer, const struct bt_conn_le_create_p
 		return -ENOMEM;
 	}
 
-	if (BT_LE_STATES_SCAN_INIT(bt_dev.le.states) &&
-	    bt_le_explicit_scanner_running() &&
+	if (BT_LE_STATES_SCAN_INIT(bt_dev.le.states) && bt_le_explicit_scanner_running() &&
 	    !bt_le_explicit_scanner_uses_same_params(create_param)) {
 		LOG_WRN("Use same scan and connection create params to obtain best performance");
 	}
@@ -3853,8 +3773,7 @@ int bt_conn_le_create_synced(const struct bt_le_ext_adv *adv,
 }
 
 #if !defined(CONFIG_BT_FILTER_ACCEPT_LIST)
-int bt_le_set_auto_conn(const bt_addr_le_t *addr,
-			const struct bt_le_conn_param *param)
+int bt_le_set_auto_conn(const bt_addr_le_t *addr, const struct bt_le_conn_param *param)
 {
 	struct bt_conn *conn;
 
@@ -3882,13 +3801,11 @@ int bt_le_set_auto_conn(const bt_addr_le_t *addr,
 	if (param) {
 		bt_conn_set_param_le(conn, param);
 
-		if (!atomic_test_and_set_bit(conn->flags,
-					     BT_CONN_AUTO_CONNECT)) {
+		if (!atomic_test_and_set_bit(conn->flags, BT_CONN_AUTO_CONNECT)) {
 			bt_conn_ref(conn);
 		}
 	} else {
-		if (atomic_test_and_clear_bit(conn->flags,
-					      BT_CONN_AUTO_CONNECT)) {
+		if (atomic_test_and_clear_bit(conn->flags, BT_CONN_AUTO_CONNECT)) {
 			bt_conn_unref(conn);
 			if (conn->state == BT_CONN_SCAN_BEFORE_INITIATING) {
 				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
@@ -3897,8 +3814,7 @@ int bt_le_set_auto_conn(const bt_addr_le_t *addr,
 	}
 
 	int err = 0;
-	if (conn->state == BT_CONN_DISCONNECTED &&
-	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
+	if (conn->state == BT_CONN_DISCONNECTED && atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 		if (param) {
 			bt_conn_set_state(conn, BT_CONN_SCAN_BEFORE_INITIATING);
 			err = bt_le_scan_user_add(BT_LE_SCAN_USER_CONN);
@@ -3912,14 +3828,12 @@ int bt_le_set_auto_conn(const bt_addr_le_t *addr,
 #endif /* !defined(CONFIG_BT_FILTER_ACCEPT_LIST) */
 #endif /* CONFIG_BT_CENTRAL */
 
-int bt_conn_le_conn_update(struct bt_conn *conn,
-			   const struct bt_le_conn_param *param)
+int bt_conn_le_conn_update(struct bt_conn *conn, const struct bt_le_conn_param *param)
 {
 	struct hci_cp_le_conn_update *conn_update;
 	struct net_buf *buf;
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
-				sizeof(*conn_update));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE, sizeof(*conn_update));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -3950,12 +3864,11 @@ int bt_conn_auth_cb_register(const struct bt_conn_auth_cb *cb)
 	/* The cancel callback must always be provided if the app provides
 	 * interactive callbacks.
 	 */
-	if (!cb->cancel &&
-	    (cb->passkey_display || cb->passkey_entry || cb->passkey_confirm ||
+	if (!cb->cancel && (cb->passkey_display || cb->passkey_entry || cb->passkey_confirm ||
 #if defined(CONFIG_BT_CLASSIC)
-	     cb->pincode_entry ||
+			    cb->pincode_entry ||
 #endif
-	     cb->pairing_confirm)) {
+			    cb->pairing_confirm)) {
 		return -EINVAL;
 	}
 
@@ -4033,8 +3946,7 @@ int bt_conn_auth_passkey_entry(struct bt_conn *conn, unsigned int passkey)
 }
 
 #if defined(CONFIG_BT_PASSKEY_KEYPRESS)
-int bt_conn_auth_keypress_notify(struct bt_conn *conn,
-				 enum bt_conn_auth_keypress type)
+int bt_conn_auth_keypress_notify(struct bt_conn *conn, enum bt_conn_auth_keypress type)
 {
 	if (IS_ENABLED(CONFIG_BT_SMP) && conn->type == BT_CONN_TYPE_LE) {
 		return bt_smp_auth_keypress_notify(conn, type);
@@ -4134,12 +4046,10 @@ int bt_conn_init(void)
 			}
 
 #if !defined(CONFIG_BT_FILTER_ACCEPT_LIST)
-			if (atomic_test_bit(conn->flags,
-					    BT_CONN_AUTO_CONNECT)) {
+			if (atomic_test_bit(conn->flags, BT_CONN_AUTO_CONNECT)) {
 				/* Only the default identity is supported */
 				conn->id = BT_ID_DEFAULT;
-				bt_conn_set_state(conn,
-						  BT_CONN_SCAN_BEFORE_INITIATING);
+				bt_conn_set_state(conn, BT_CONN_SCAN_BEFORE_INITIATING);
 			}
 #endif /* !defined(CONFIG_BT_FILTER_ACCEPT_LIST) */
 
@@ -4183,8 +4093,7 @@ void bt_hci_le_df_connection_iq_report_common(uint8_t event, struct net_buf *buf
 		}
 	}
 
-	STRUCT_SECTION_FOREACH(bt_conn_cb, cb)
-	{
+	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 		if (cb->cte_report_cb) {
 			cb->cte_report_cb(conn, &iq_report);
 		}
@@ -4227,8 +4136,7 @@ void bt_hci_le_df_cte_req_failed(struct net_buf *buf)
 		}
 	}
 
-	STRUCT_SECTION_FOREACH(bt_conn_cb, cb)
-	{
+	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
 		if (cb->cte_report_cb) {
 			cb->cte_report_cb(conn, &iq_report);
 		}
diff --git a/subsys/bluetooth/host/conn_internal.h b/subsys/bluetooth/host/conn_internal.h
index cd4eb2b8045..d36eeca879d 100644
--- a/subsys/bluetooth/host/conn_internal.h
+++ b/subsys/bluetooth/host/conn_internal.h
@@ -12,10 +12,10 @@
 #include <zephyr/bluetooth/iso.h>
 
 typedef enum __packed {
-	BT_CONN_DISCONNECTED,         /* Disconnected, conn is completely down */
-	BT_CONN_DISCONNECT_COMPLETE,  /* Received disconn comp event, transition to DISCONNECTED */
+	BT_CONN_DISCONNECTED,        /* Disconnected, conn is completely down */
+	BT_CONN_DISCONNECT_COMPLETE, /* Received disconn comp event, transition to DISCONNECTED */
 
-	BT_CONN_INITIATING,           /* Central connection establishment */
+	BT_CONN_INITIATING, /* Central connection establishment */
 	/** Central scans for a device preceding establishing a connection to it.
 	 *
 	 * This can happen when:
@@ -39,10 +39,10 @@ typedef enum __packed {
 	 */
 	BT_CONN_INITIATING_FILTER_LIST,
 
-	BT_CONN_ADV_CONNECTABLE,       /* Peripheral connectable advertising */
-	BT_CONN_ADV_DIR_CONNECTABLE,   /* Peripheral directed advertising */
-	BT_CONN_CONNECTED,            /* Peripheral or Central connected */
-	BT_CONN_DISCONNECTING,        /* Peripheral or Central issued disconnection command */
+	BT_CONN_ADV_CONNECTABLE,     /* Peripheral connectable advertising */
+	BT_CONN_ADV_DIR_CONNECTABLE, /* Peripheral directed advertising */
+	BT_CONN_CONNECTED,           /* Peripheral or Central connected */
+	BT_CONN_DISCONNECTING,       /* Peripheral or Central issued disconnection command */
 } bt_conn_state_t;
 
 /* bt_conn flags: the flags defined here represent connection parameters */
@@ -72,17 +72,17 @@ enum {
 	BT_CONN_PERIPHERAL_PARAM_L2CAP,       /* If should force L2CAP for CPUP */
 	BT_CONN_FORCE_PAIR,                   /* Pairing even with existing keys. */
 #if defined(CONFIG_BT_GATT_CLIENT)
-	BT_CONN_ATT_MTU_EXCHANGED,            /* If ATT MTU has been exchanged. */
-#endif /* CONFIG_BT_GATT_CLIENT */
+	BT_CONN_ATT_MTU_EXCHANGED, /* If ATT MTU has been exchanged. */
+#endif                             /* CONFIG_BT_GATT_CLIENT */
 
-	BT_CONN_LE_FEATURES_EXCHANGED,        /* bt_conn.le.features is valid */
-	BT_CONN_AUTO_VERSION_INFO,            /* Auto-initiated LE version done */
+	BT_CONN_LE_FEATURES_EXCHANGED, /* bt_conn.le.features is valid */
+	BT_CONN_AUTO_VERSION_INFO,     /* Auto-initiated LE version done */
 
-	BT_CONN_CTE_RX_ENABLED,               /* CTE receive and sampling is enabled */
-	BT_CONN_CTE_RX_PARAMS_SET,            /* CTE parameters are set */
-	BT_CONN_CTE_TX_PARAMS_SET,            /* CTE transmission parameters are set */
-	BT_CONN_CTE_REQ_ENABLED,              /* CTE request procedure is enabled */
-	BT_CONN_CTE_RSP_ENABLED,              /* CTE response procedure is enabled */
+	BT_CONN_CTE_RX_ENABLED,    /* CTE receive and sampling is enabled */
+	BT_CONN_CTE_RX_PARAMS_SET, /* CTE parameters are set */
+	BT_CONN_CTE_TX_PARAMS_SET, /* CTE transmission parameters are set */
+	BT_CONN_CTE_REQ_ENABLED,   /* CTE request procedure is enabled */
+	BT_CONN_CTE_RSP_ENABLED,   /* CTE response procedure is enabled */
 
 	/* Total number of flags - must be at the end of the enum */
 	BT_CONN_NUM_FLAGS,
@@ -104,7 +104,7 @@ struct bt_conn_le {
 	uint16_t pending_timeout;
 
 #if defined(CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS)
-	uint8_t  conn_param_retry_countdown;
+	uint8_t conn_param_retry_countdown;
 #endif
 
 	/** @brief Remote LE features
@@ -134,56 +134,56 @@ struct bt_conn_le {
 #define LMP_MAX_PAGES 2
 
 struct bt_conn_br {
-	bt_addr_t		dst;
-	uint8_t			remote_io_capa;
-	uint8_t			remote_auth;
-	uint8_t			pairing_method;
+	bt_addr_t dst;
+	uint8_t remote_io_capa;
+	uint8_t remote_auth;
+	uint8_t pairing_method;
 	/* remote LMP features pages per 8 bytes each */
-	uint8_t			features[LMP_MAX_PAGES][8];
+	uint8_t features[LMP_MAX_PAGES][8];
 
-	struct bt_keys_link_key	*link_key;
+	struct bt_keys_link_key *link_key;
 };
 
 struct bt_conn_sco {
 	/* Reference to ACL Connection */
-	struct bt_conn          *acl;
+	struct bt_conn *acl;
 
 	/* Reference to the struct bt_sco_chan */
-	struct bt_sco_chan      *chan;
+	struct bt_sco_chan *chan;
 
-	uint16_t                pkt_type;
-	uint8_t                 dev_class[3];
-	uint8_t                 link_type;
+	uint16_t pkt_type;
+	uint8_t dev_class[3];
+	uint8_t link_type;
 };
 #endif
 
 struct bt_conn_iso {
 	/* Reference to ACL Connection */
-	struct bt_conn          *acl;
+	struct bt_conn *acl;
 
 	/* Reference to the struct bt_iso_chan */
-	struct bt_iso_chan      *chan;
+	struct bt_iso_chan *chan;
 
 	union {
 		/* CIG ID */
-		uint8_t			cig_id;
+		uint8_t cig_id;
 		/* BIG handle */
-		uint8_t			big_handle;
+		uint8_t big_handle;
 	};
 
 	union {
 		/* CIS ID within the CIG */
-		uint8_t			cis_id;
+		uint8_t cis_id;
 
 		/* BIS ID within the BIG*/
-		uint8_t			bis_id;
+		uint8_t bis_id;
 	};
 
 	/** Stored information about the ISO stream */
 	struct bt_iso_info info;
 
 	/** Queue from which conn will pull data */
-	struct k_fifo                   txq;
+	struct k_fifo txq;
 };
 
 typedef void (*bt_conn_tx_cb_t)(struct bt_conn *conn, void *user_data, int err);
@@ -212,19 +212,19 @@ struct acl_data {
 };
 
 struct bt_conn {
-	uint16_t			handle;
-	enum bt_conn_type	type;
-	uint8_t			role;
+	uint16_t handle;
+	enum bt_conn_type type;
+	uint8_t role;
 
 	ATOMIC_DEFINE(flags, BT_CONN_NUM_FLAGS);
 
 	/* Which local identity address this connection uses */
-	uint8_t                    id;
+	uint8_t id;
 
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
-	bt_security_t		sec_level;
-	bt_security_t		required_sec_level;
-	uint8_t			encrypt;
+	bt_security_t sec_level;
+	bt_security_t required_sec_level;
+	uint8_t encrypt;
 #endif /* CONFIG_BT_SMP || CONFIG_BT_CLASSIC */
 
 #if defined(CONFIG_BT_DF_CONNECTION_CTE_RX)
@@ -237,45 +237,45 @@ struct bt_conn {
 #endif /* CONFIG_BT_DF_CONNECTION_CTE_RX */
 
 	/* Connection error or reason for disconnect */
-	uint8_t			err;
+	uint8_t err;
 
-	bt_conn_state_t		state;
+	bt_conn_state_t state;
 	uint16_t rx_len;
-	struct net_buf		*rx;
+	struct net_buf *rx;
 
 	/* Pending TX that are awaiting the NCP event. len(tx_pending) == in_ll */
-	sys_slist_t		tx_pending;
+	sys_slist_t tx_pending;
 
 	/* Completed TX for which we need to call the callback */
-	sys_slist_t		tx_complete;
+	sys_slist_t tx_complete;
 #if defined(CONFIG_BT_CONN_TX)
-	struct k_work           tx_complete_work;
+	struct k_work tx_complete_work;
 #endif /* CONFIG_BT_CONN_TX */
 
 	/* Active L2CAP channels */
-	sys_slist_t		channels;
+	sys_slist_t channels;
 
 	/* Delayed work deferred tasks:
 	 * - Peripheral delayed connection update.
 	 * - Initiator connect create cancel.
 	 * - Connection cleanup.
 	 */
-	struct k_work_delayable	deferred_work;
+	struct k_work_delayable deferred_work;
 
 	union {
-		struct bt_conn_le	le;
+		struct bt_conn_le le;
 #if defined(CONFIG_BT_CLASSIC)
-		struct bt_conn_br	br;
-		struct bt_conn_sco	sco;
+		struct bt_conn_br br;
+		struct bt_conn_sco sco;
 #endif
 #if defined(CONFIG_BT_ISO)
-		struct bt_conn_iso	iso;
+		struct bt_conn_iso iso;
 #endif
 	};
 
 #if defined(CONFIG_BT_REMOTE_VERSION)
 	struct bt_conn_rv {
-		uint8_t  version;
+		uint8_t version;
 		uint16_t manufacturer;
 		uint16_t subversion;
 	} rv;
@@ -287,13 +287,11 @@ struct bt_conn {
 	 * Scheduling from which channel to pull (e.g. for L2CAP) is done at the
 	 * upper layer's discretion.
 	 */
-	struct net_buf * (*tx_data_pull)(struct bt_conn *conn,
-					 size_t amount,
-					 size_t *length);
+	struct net_buf *(*tx_data_pull)(struct bt_conn *conn, size_t amount, size_t *length);
 
 	/* Get (and clears for ACL conns) callback and user-data for `buf`. */
-	void (*get_and_clear_cb)(struct bt_conn *conn, struct net_buf *buf,
-				 bt_conn_tx_cb_t *cb, void **ud);
+	void (*get_and_clear_cb)(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t *cb,
+				 void **ud);
 
 	/* Return true if upper layer has data to send over HCI */
 	bool (*has_data)(struct bt_conn *conn);
@@ -302,13 +300,13 @@ struct bt_conn {
 	 * pulling HCI fragments. Channels are only ever removed from this list
 	 * when a whole PDU (ie all its frags) have been sent.
 	 */
-	sys_slist_t		l2cap_data_ready;
+	sys_slist_t l2cap_data_ready;
 
 	/* Node for putting this connection in a data-ready mode for the bt_dev.
 	 * This will be used by the TX processor to then fetch HCI frags from it.
 	 */
-	sys_snode_t		_conn_ready;
-	atomic_t		_conn_ready_lock;
+	sys_snode_t _conn_ready;
+	atomic_t _conn_ready_lock;
 
 	/* Holds the number of packets that have been sent to the controller but
 	 * not yet ACKd (by receiving an Number of Completed Packets). This
@@ -316,15 +314,15 @@ struct bt_conn {
 	 * to maximize throughput/latency.
 	 * It's an optimization so we don't chase `tx_pending` all the time.
 	 */
-	atomic_t		in_ll;
+	atomic_t in_ll;
 
 	/* Next buffer should be an ACL/ISO HCI fragment */
-	bool			next_is_frag;
+	bool next_is_frag;
 
 	/* Must be at the end so that everything else in the structure can be
 	 * memset to zero without affecting the ref.
 	 */
-	atomic_t		ref;
+	atomic_t ref;
 };
 
 /* Holds the callback and a user-data field for the upper layer. This callback
@@ -375,8 +373,7 @@ void bt_conn_recv(struct bt_conn *conn, struct net_buf *buf, uint8_t flags);
  * Calling this from RX thread is assumed to never fail so the return can be
  * ignored.
  */
-int bt_conn_send_cb(struct bt_conn *conn, struct net_buf *buf,
-		    bt_conn_tx_cb_t cb, void *user_data);
+int bt_conn_send_cb(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb, void *user_data);
 
 /* Thin wrapper over `bt_conn_send_cb`
  *
@@ -384,8 +381,7 @@ int bt_conn_send_cb(struct bt_conn *conn, struct net_buf *buf,
  *
  * Return values & buf ownership same as parent.
  */
-int bt_conn_send_iso_cb(struct bt_conn *conn, struct net_buf *buf,
-			bt_conn_tx_cb_t cb, bool has_ts);
+int bt_conn_send_iso_cb(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb, bool has_ts);
 
 /* Check if a connection object with the peer already exists */
 bool bt_conn_exists_le(uint8_t id, const bt_addr_le_t *peer);
@@ -395,10 +391,10 @@ struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer);
 
 /** Connection parameters for ISO connections */
 struct bt_iso_create_param {
-	uint8_t			id;
-	uint8_t			num_conns;
-	struct bt_conn		**conns;
-	struct bt_iso_chan	**chans;
+	uint8_t id;
+	uint8_t num_conns;
+	struct bt_conn **conns;
+	struct bt_iso_chan **chans;
 };
 
 int bt_conn_iso_init(void);
@@ -443,19 +439,17 @@ static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
 		return true;
 	case BT_CONN_INITIATING:
 		/* ISO connection handle assigned at connect state */
-		if (IS_ENABLED(CONFIG_BT_ISO) &&
-		    conn->type == BT_CONN_TYPE_ISO) {
+		if (IS_ENABLED(CONFIG_BT_ISO) && conn->type == BT_CONN_TYPE_ISO) {
 			return true;
 		}
-	__fallthrough;
+		__fallthrough;
 	default:
 		return false;
 	}
 }
 
 /* Check if the connection is with the given peer. */
-bool bt_conn_is_peer_addr_le(const struct bt_conn *conn, uint8_t id,
-			     const bt_addr_le_t *peer);
+bool bt_conn_is_peer_addr_le(const struct bt_conn *conn, uint8_t id, const bt_addr_le_t *peer);
 
 /* Helpers for identifying & looking up connections based on the index to
  * the connection list. This is useful for O(1) lookups, but can't be used
@@ -475,8 +469,7 @@ void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state);
 
 void bt_conn_connected(struct bt_conn *conn);
 
-int bt_conn_le_conn_update(struct bt_conn *conn,
-			   const struct bt_le_conn_param *param);
+int bt_conn_le_conn_update(struct bt_conn *conn, const struct bt_le_conn_param *param);
 
 void notify_remote_info(struct bt_conn *conn);
 
@@ -488,20 +481,16 @@ void notify_le_phy_updated(struct bt_conn *conn);
 
 bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param);
 
-void notify_tx_power_report(struct bt_conn *conn,
-			    struct bt_conn_le_tx_power_report report);
+void notify_tx_power_report(struct bt_conn *conn, struct bt_conn_le_tx_power_report report);
 
 void notify_path_loss_threshold_report(struct bt_conn *conn,
 				       struct bt_conn_le_path_loss_threshold_report report);
 
-void notify_subrate_change(struct bt_conn *conn,
-			   struct bt_conn_le_subrate_changed params);
+void notify_subrate_change(struct bt_conn *conn, struct bt_conn_le_subrate_changed params);
 
-void notify_remote_cs_capabilities(struct bt_conn *conn,
-			   struct bt_conn_le_cs_capabilities params);
+void notify_remote_cs_capabilities(struct bt_conn *conn, struct bt_conn_le_cs_capabilities params);
 
-void notify_remote_cs_fae_table(struct bt_conn *conn,
-			   struct bt_conn_le_cs_fae_table params);
+void notify_remote_cs_fae_table(struct bt_conn *conn, struct bt_conn_le_cs_fae_table params);
 
 void notify_cs_config_created(struct bt_conn *conn, struct bt_conn_le_cs_config *params);
 
@@ -519,8 +508,8 @@ void notify_cs_procedure_enable_available(struct bt_conn *conn,
 bool bt_conn_ltk_present(const struct bt_conn *conn);
 
 /* rand and ediv should be in BT order */
-int bt_conn_le_start_encryption(struct bt_conn *conn, uint8_t rand[8],
-				uint8_t ediv[2], const uint8_t *ltk, size_t len);
+int bt_conn_le_start_encryption(struct bt_conn *conn, uint8_t rand[8], uint8_t ediv[2],
+				const uint8_t *ltk, size_t len);
 
 /* Notify higher layers that RPA was resolved */
 void bt_conn_identity_resolved(struct bt_conn *conn);
@@ -528,50 +517,39 @@ void bt_conn_identity_resolved(struct bt_conn *conn);
 
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
 /* Notify higher layers that connection security changed */
-void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err,
-			      enum bt_security_err err);
+void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err, enum bt_security_err err);
 #endif /* CONFIG_BT_SMP || CONFIG_BT_CLASSIC */
 
 /* Prepare a PDU to be sent over a connection */
 #if defined(CONFIG_NET_BUF_LOG)
-struct net_buf *bt_conn_create_pdu_timeout_debug(struct net_buf_pool *pool,
-						 size_t reserve,
-						 k_timeout_t timeout,
-						 const char *func, int line);
-#define bt_conn_create_pdu_timeout(_pool, _reserve, _timeout) \
-	bt_conn_create_pdu_timeout_debug(_pool, _reserve, _timeout, \
-					 __func__, __LINE__)
-
-#define bt_conn_create_pdu(_pool, _reserve) \
-	bt_conn_create_pdu_timeout_debug(_pool, _reserve, K_FOREVER, \
-					 __func__, __LINE__)
+struct net_buf *bt_conn_create_pdu_timeout_debug(struct net_buf_pool *pool, size_t reserve,
+						 k_timeout_t timeout, const char *func, int line);
+#define bt_conn_create_pdu_timeout(_pool, _reserve, _timeout)                                      \
+	bt_conn_create_pdu_timeout_debug(_pool, _reserve, _timeout, __func__, __LINE__)
+
+#define bt_conn_create_pdu(_pool, _reserve)                                                        \
+	bt_conn_create_pdu_timeout_debug(_pool, _reserve, K_FOREVER, __func__, __LINE__)
 #else
-struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool,
-					   size_t reserve, k_timeout_t timeout);
+struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool, size_t reserve,
+					   k_timeout_t timeout);
 
-#define bt_conn_create_pdu(_pool, _reserve) \
-	bt_conn_create_pdu_timeout(_pool, _reserve, K_FOREVER)
+#define bt_conn_create_pdu(_pool, _reserve) bt_conn_create_pdu_timeout(_pool, _reserve, K_FOREVER)
 #endif
 
 /* Prepare a PDU to be sent over a connection */
 #if defined(CONFIG_NET_BUF_LOG)
-struct net_buf *bt_conn_create_frag_timeout_debug(size_t reserve,
-						  k_timeout_t timeout,
+struct net_buf *bt_conn_create_frag_timeout_debug(size_t reserve, k_timeout_t timeout,
 						  const char *func, int line);
 
-#define bt_conn_create_frag_timeout(_reserve, _timeout) \
-	bt_conn_create_frag_timeout_debug(_reserve, _timeout, \
-					  __func__, __LINE__)
+#define bt_conn_create_frag_timeout(_reserve, _timeout)                                            \
+	bt_conn_create_frag_timeout_debug(_reserve, _timeout, __func__, __LINE__)
 
-#define bt_conn_create_frag(_reserve) \
-	bt_conn_create_frag_timeout_debug(_reserve, K_FOREVER, \
-					  __func__, __LINE__)
+#define bt_conn_create_frag(_reserve)                                                              \
+	bt_conn_create_frag_timeout_debug(_reserve, K_FOREVER, __func__, __LINE__)
 #else
-struct net_buf *bt_conn_create_frag_timeout(size_t reserve,
-					    k_timeout_t timeout);
+struct net_buf *bt_conn_create_frag_timeout(size_t reserve, k_timeout_t timeout);
 
-#define bt_conn_create_frag(_reserve) \
-	bt_conn_create_frag_timeout(_reserve, K_FOREVER)
+#define bt_conn_create_frag(_reserve) bt_conn_create_frag_timeout(_reserve, K_FOREVER)
 #endif
 
 /* Initialize connection management */
diff --git a/subsys/bluetooth/host/crypto_psa.c b/subsys/bluetooth/host/crypto_psa.c
index d3f2de3b886..774cfb8b6c1 100644
--- a/subsys/bluetooth/host/crypto_psa.c
+++ b/subsys/bluetooth/host/crypto_psa.c
@@ -46,7 +46,7 @@ int bt_rand(void *buf, size_t len)
 	LOG_ERR("psa_generate_random() failed");
 	return -EIO;
 }
-#else /* !CONFIG_BT_HOST_CRYPTO_PRNG */
+#else  /* !CONFIG_BT_HOST_CRYPTO_PRNG */
 int bt_rand(void *buf, size_t len)
 {
 	CHECKIF(buf == NULL || len == 0) {
@@ -57,8 +57,7 @@ int bt_rand(void *buf, size_t len)
 }
 #endif /* CONFIG_BT_HOST_CRYPTO_PRNG */
 
-int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
-		  uint8_t enc_data[16])
+int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16], uint8_t enc_data[16])
 {
 	psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
 	psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
@@ -86,8 +85,8 @@ int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
 
 	sys_memcpy_swap(tmp, plaintext, 16);
 
-	status = psa_cipher_encrypt(key_id, PSA_ALG_ECB_NO_PADDING, tmp, 16,
-					enc_data, 16, &out_len);
+	status =
+		psa_cipher_encrypt(key_id, PSA_ALG_ECB_NO_PADDING, tmp, 16, enc_data, 16, &out_len);
 	if (status != PSA_SUCCESS) {
 		LOG_ERR("AES encryption failed");
 	}
@@ -108,8 +107,7 @@ int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
 	return 0;
 }
 
-int bt_encrypt_be(const uint8_t key[16], const uint8_t plaintext[16],
-		  uint8_t enc_data[16])
+int bt_encrypt_be(const uint8_t key[16], const uint8_t plaintext[16], uint8_t enc_data[16])
 {
 	psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
 	psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
@@ -132,8 +130,8 @@ int bt_encrypt_be(const uint8_t key[16], const uint8_t plaintext[16],
 		return -EINVAL;
 	}
 
-	status = psa_cipher_encrypt(key_id, PSA_ALG_ECB_NO_PADDING,
-				plaintext, 16, enc_data, 16, &out_len);
+	status = psa_cipher_encrypt(key_id, PSA_ALG_ECB_NO_PADDING, plaintext, 16, enc_data, 16,
+				    &out_len);
 	if (status != PSA_SUCCESS) {
 		LOG_ERR("AES encryption failed");
 	}
diff --git a/subsys/bluetooth/host/data.c b/subsys/bluetooth/host/data.c
index 4afd9aad0a7..ef48dddc386 100644
--- a/subsys/bluetooth/host/data.c
+++ b/subsys/bluetooth/host/data.c
@@ -13,8 +13,7 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(bt_data);
 
-void bt_data_parse(struct net_buf_simple *ad,
-		   bool (*func)(struct bt_data *data, void *user_data),
+void bt_data_parse(struct net_buf_simple *ad, bool (*func)(struct bt_data *data, void *user_data),
 		   void *user_data)
 {
 	while (ad->len > 1) {
@@ -28,8 +27,7 @@ void bt_data_parse(struct net_buf_simple *ad,
 		}
 
 		if (len > ad->len) {
-			LOG_WRN("malformed advertising data %u / %u",
-				len, ad->len);
+			LOG_WRN("malformed advertising data %u / %u", len, ad->len);
 			return;
 		}
 
diff --git a/subsys/bluetooth/host/direction.c b/subsys/bluetooth/host/direction.c
index a2dee2561ce..1f06bbb09f6 100644
--- a/subsys/bluetooth/host/direction.c
+++ b/subsys/bluetooth/host/direction.c
@@ -38,12 +38,12 @@ struct bt_le_df_ant_info {
 
 static struct bt_le_df_ant_info df_ant_info;
 #if defined(CONFIG_BT_DF_CONNECTIONLESS_CTE_RX) || defined(CONFIG_BT_DF_CONNECTION_CTE_RX)
-const static uint8_t df_dummy_switch_pattern[BT_HCI_LE_SWITCH_PATTERN_LEN_MIN] = { 0, 0 };
+const static uint8_t df_dummy_switch_pattern[BT_HCI_LE_SWITCH_PATTERN_LEN_MIN] = {0, 0};
 #endif /* CONFIG_BT_DF_CONNECTIONLESS_CTE_RX || CONFIG_BT_DF_CONNECTION_CTE_RX */
 
-#define DF_AOD_TX_1US_SUPPORT(supp)             (supp & BT_HCI_LE_1US_AOD_TX)
-#define DF_AOD_RX_1US_SUPPORT(supp)             (supp & BT_HCI_LE_1US_AOD_RX)
-#define DF_AOA_RX_1US_SUPPORT(supp)             (supp & BT_HCI_LE_1US_AOA_RX)
+#define DF_AOD_TX_1US_SUPPORT(supp) (supp & BT_HCI_LE_1US_AOD_TX)
+#define DF_AOD_RX_1US_SUPPORT(supp) (supp & BT_HCI_LE_1US_AOD_RX)
+#define DF_AOA_RX_1US_SUPPORT(supp) (supp & BT_HCI_LE_1US_AOA_RX)
 
 #define DF_SAMPLING_ANTENNA_NUMBER_MIN 0x2
 
@@ -54,10 +54,10 @@ static bool valid_cte_rx_common_params(uint8_t cte_types, uint8_t slot_durations
 
 #if defined(CONFIG_BT_DF_CONNECTIONLESS_CTE_RX)
 static bool valid_cl_cte_rx_params(const struct bt_df_per_adv_sync_cte_rx_param *params);
-static int
-prepare_cl_cte_rx_enable_cmd_params(struct net_buf **buf, struct bt_le_per_adv_sync *sync,
-				    const struct bt_df_per_adv_sync_cte_rx_param *params,
-				    bool enable);
+static int prepare_cl_cte_rx_enable_cmd_params(struct net_buf **buf,
+					       struct bt_le_per_adv_sync *sync,
+					       const struct bt_df_per_adv_sync_cte_rx_param *params,
+					       bool enable);
 static int hci_df_set_cl_cte_rx_enable(struct bt_le_per_adv_sync *sync, bool enable,
 				       const struct bt_df_per_adv_sync_cte_rx_param *params);
 #endif /* CONFIG_BT_DF_CONNECTIONLESS_CTE_RX */
@@ -86,7 +86,7 @@ static uint8_t get_hci_cte_type(enum bt_df_cte_type type)
 }
 
 static int hci_df_set_cl_cte_tx_params(const struct bt_le_ext_adv *adv,
-				    const struct bt_df_adv_cte_tx_param *params)
+				       const struct bt_df_adv_cte_tx_param *params)
 {
 	struct bt_hci_cp_le_set_cl_cte_tx_params *cp;
 	struct net_buf *buf;
@@ -106,16 +106,14 @@ static int hci_df_set_cl_cte_tx_params(const struct bt_le_ext_adv *adv,
 		}
 
 		if (params->num_ant_ids < BT_HCI_LE_SWITCH_PATTERN_LEN_MIN ||
-		    params->num_ant_ids > BT_HCI_LE_SWITCH_PATTERN_LEN_MAX ||
-		    !params->ant_ids) {
+		    params->num_ant_ids > BT_HCI_LE_SWITCH_PATTERN_LEN_MAX || !params->ant_ids) {
 			return -EINVAL;
 		}
 	} else if (params->cte_type != BT_DF_CTE_TYPE_AOA) {
 		return -EINVAL;
 	}
 
-	if (params->cte_len < BT_HCI_LE_CTE_LEN_MIN ||
-	    params->cte_len > BT_HCI_LE_CTE_LEN_MAX) {
+	if (params->cte_len < BT_HCI_LE_CTE_LEN_MIN || params->cte_len > BT_HCI_LE_CTE_LEN_MAX) {
 		return -EINVAL;
 	}
 
@@ -145,8 +143,7 @@ static int hci_df_set_cl_cte_tx_params(const struct bt_le_ext_adv *adv,
 		cp->switch_pattern_len = 0;
 	}
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_CL_CTE_TX_PARAMS,
-				    buf, NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_CL_CTE_TX_PARAMS, buf, NULL);
 }
 
 /* @brief Function provides information about DF antennae number and
@@ -160,10 +157,8 @@ static int hci_df_set_cl_cte_tx_params(const struct bt_le_ext_adv *adv,
  *
  * @return Zero in case of success, other value in case of failure.
  */
-static int hci_df_read_ant_info(uint8_t *switch_sample_rates,
-				uint8_t *num_ant,
-				uint8_t *max_switch_pattern_len,
-				uint8_t *max_cte_len)
+static int hci_df_read_ant_info(uint8_t *switch_sample_rates, uint8_t *num_ant,
+				uint8_t *max_switch_pattern_len, uint8_t *max_cte_len)
 {
 	__ASSERT_NO_MSG(switch_sample_rates);
 	__ASSERT_NO_MSG(num_ant);
@@ -183,8 +178,8 @@ static int hci_df_read_ant_info(uint8_t *switch_sample_rates,
 	rp = (void *)rsp->data;
 
 	LOG_DBG("DF: sw. sampl rates: %x ant num: %u , max sw. pattern len: %u,"
-	       "max CTE len %d", rp->switch_sample_rates, rp->num_ant,
-	       rp->max_switch_pattern_len, rp->max_cte_len);
+		"max CTE len %d",
+		rp->switch_sample_rates, rp->num_ant, rp->max_switch_pattern_len, rp->max_cte_len);
 
 	*switch_sample_rates = rp->switch_sample_rates;
 	*num_ant = rp->num_ant;
@@ -204,8 +199,7 @@ static int hci_df_read_ant_info(uint8_t *switch_sample_rates,
  *
  * @return Zero in case of success, other value in case of failure.
  */
-static int hci_df_set_adv_cte_tx_enable(struct bt_le_ext_adv *adv,
-					bool enable)
+static int hci_df_set_adv_cte_tx_enable(struct bt_le_ext_adv *adv, bool enable)
 {
 	struct bt_hci_cp_le_set_cl_cte_tx_enable *cp;
 	struct bt_hci_cmd_state_set state;
@@ -222,11 +216,9 @@ static int hci_df_set_adv_cte_tx_enable(struct bt_le_ext_adv *adv,
 	cp->handle = adv->handle;
 	cp->cte_enable = enable ? 1 : 0;
 
-	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_PER_ADV_CTE_ENABLED,
-				  enable);
+	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_PER_ADV_CTE_ENABLED, enable);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_CL_CTE_TX_ENABLE,
-				   buf, NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_CL_CTE_TX_ENABLE, buf, NULL);
 }
 
 #if defined(CONFIG_BT_DF_CONNECTIONLESS_CTE_RX) || defined(CONFIG_BT_DF_CONNECTION_CTE_RX)
@@ -274,10 +266,10 @@ static bool valid_cl_cte_rx_params(const struct bt_df_per_adv_sync_cte_rx_param
 	return true;
 }
 
-static int
-prepare_cl_cte_rx_enable_cmd_params(struct net_buf **buf, struct bt_le_per_adv_sync *sync,
-				    const struct bt_df_per_adv_sync_cte_rx_param *params,
-				    bool enable)
+static int prepare_cl_cte_rx_enable_cmd_params(struct net_buf **buf,
+					       struct bt_le_per_adv_sync *sync,
+					       const struct bt_df_per_adv_sync_cte_rx_param *params,
+					       bool enable)
 {
 	struct bt_hci_cp_le_set_cl_cte_sampling_enable *cp;
 	uint8_t switch_pattern_len;
@@ -293,7 +285,7 @@ prepare_cl_cte_rx_enable_cmd_params(struct net_buf **buf, struct bt_le_per_adv_s
 	 */
 	*buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_CL_CTE_SAMPLING_ENABLE,
 				 (sizeof(struct bt_hci_cp_le_set_cl_cte_sampling_enable) +
-				 (enable ? switch_pattern_len : 0)));
+				  (enable ? switch_pattern_len : 0)));
 	if (!(*buf)) {
 		return -ENOBUFS;
 	}
@@ -533,8 +525,9 @@ static int hci_df_set_conn_cte_tx_param(struct bt_conn *conn,
 		return -EINVAL;
 	}
 
-	num_ant_ids = ((params->cte_types & (BT_DF_CTE_TYPE_AOD_1US | BT_DF_CTE_TYPE_AOD_2US)) ?
-				params->num_ant_ids : 0);
+	num_ant_ids = ((params->cte_types & (BT_DF_CTE_TYPE_AOD_1US | BT_DF_CTE_TYPE_AOD_2US))
+			       ? params->num_ant_ids
+			       : 0);
 
 	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_CONN_CTE_TX_PARAMS,
 				sizeof(struct bt_hci_cp_le_set_conn_cte_tx_params) + num_ant_ids);
@@ -584,7 +577,7 @@ static int prepare_conn_cte_rx_enable_cmd_params(struct net_buf **buf, struct bt
 	 */
 	*buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_CONN_CTE_RX_PARAMS,
 				 (sizeof(struct bt_hci_cp_le_set_conn_cte_rx_params) +
-				 (enable ? switch_pattern_len : 0)));
+				  (enable ? switch_pattern_len : 0)));
 	if (!(*buf)) {
 		return -ENOBUFS;
 	}
@@ -667,8 +660,8 @@ static int hci_df_set_conn_cte_rx_enable(struct bt_conn *conn, bool enable,
 }
 
 int hci_df_prepare_connection_iq_report(struct net_buf *buf,
-					 struct bt_df_conn_iq_samples_report *report,
-					 struct bt_conn **conn_to_report)
+					struct bt_df_conn_iq_samples_report *report,
+					struct bt_conn **conn_to_report)
 {
 	struct bt_hci_evt_le_connection_iq_report *evt;
 	struct bt_conn *conn;
@@ -773,8 +766,7 @@ int hci_df_vs_prepare_connection_iq_report(struct net_buf *buf,
 #endif /* CONFIG_BT_DF_CONNECTION_CTE_RX */
 
 #if defined(CONFIG_BT_DF_CONNECTION_CTE_REQ)
-static bool valid_cte_req_params(const struct bt_conn *conn, uint8_t cte_type,
-				    uint8_t cte_length)
+static bool valid_cte_req_params(const struct bt_conn *conn, uint8_t cte_type, uint8_t cte_length)
 {
 	if (!(conn->cte_types & cte_type)) {
 		return false;
@@ -942,8 +934,8 @@ int le_df_init(void)
 	uint8_t num_ant;
 	int err;
 
-	err = hci_df_read_ant_info(&switch_sample_rates, &num_ant,
-			     &max_switch_pattern_len, &max_cte_len);
+	err = hci_df_read_ant_info(&switch_sample_rates, &num_ant, &max_switch_pattern_len,
+				   &max_cte_len);
 	if (err) {
 		return err;
 	}
@@ -958,7 +950,7 @@ int le_df_init(void)
 }
 
 int bt_df_set_adv_cte_tx_param(struct bt_le_ext_adv *adv,
-				const struct bt_df_adv_cte_tx_param *params)
+			       const struct bt_df_adv_cte_tx_param *params)
 {
 	__ASSERT_NO_MSG(adv);
 	__ASSERT_NO_MSG(params);
@@ -1032,8 +1024,7 @@ bt_df_set_per_adv_sync_cte_rx_enable(struct bt_le_per_adv_sync *sync, bool enabl
 		return -EINVAL;
 	}
 
-	if (!enable &&
-	    !atomic_test_bit(sync->flags, BT_PER_ADV_SYNC_CTE_ENABLED)) {
+	if (!enable && !atomic_test_bit(sync->flags, BT_PER_ADV_SYNC_CTE_ENABLED)) {
 		return -EALREADY;
 	}
 
diff --git a/subsys/bluetooth/host/ecc.c b/subsys/bluetooth/host/ecc.c
index a77922d7a6b..b19b7150dec 100644
--- a/subsys/bluetooth/host/ecc.c
+++ b/subsys/bluetooth/host/ecc.c
@@ -26,16 +26,13 @@ static bt_dh_key_cb_t dh_key_cb;
 
 static const uint8_t debug_public_key[BT_PUB_KEY_LEN] = {
 	/* X */
-	0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,
-	0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,
-	0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,
-	0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20,
+	0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc, 0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4,
+	0xef, 0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e, 0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03,
+	0xb0, 0x20,
 	/* Y */
-	0x8b, 0xd2, 0x89, 0x15, 0xd0, 0x8e, 0x1c, 0x74,
-	0x24, 0x30, 0xed, 0x8f, 0xc2, 0x45, 0x63, 0x76,
-	0x5c, 0x15, 0x52, 0x5a, 0xbf, 0x9a, 0x32, 0x63,
-	0x6d, 0xeb, 0x2a, 0x65, 0x49, 0x9c, 0x80, 0xdc
-};
+	0x8b, 0xd2, 0x89, 0x15, 0xd0, 0x8e, 0x1c, 0x74, 0x24, 0x30, 0xed, 0x8f, 0xc2, 0x45, 0x63,
+	0x76, 0x5c, 0x15, 0x52, 0x5a, 0xbf, 0x9a, 0x32, 0x63, 0x6d, 0xeb, 0x2a, 0x65, 0x49, 0x9c,
+	0x80, 0xdc};
 
 bool bt_pub_key_is_debug(uint8_t *cmp_pub_key)
 {
@@ -154,8 +151,7 @@ void bt_pub_key_hci_disrupted(void)
 
 const uint8_t *bt_pub_key_get(void)
 {
-	if (IS_ENABLED(CONFIG_BT_USE_DEBUG_KEYS) &&
-	    BT_CMD_TEST(bt_dev.supported_commands, 41, 2)) {
+	if (IS_ENABLED(CONFIG_BT_USE_DEBUG_KEYS) && BT_CMD_TEST(bt_dev.supported_commands, 41, 2)) {
 		return debug_public_key;
 	}
 
@@ -217,10 +213,8 @@ int bt_dh_key_gen(const uint8_t remote_pk[BT_PUB_KEY_LEN], bt_dh_key_cb_t cb)
 
 	dh_key_cb = cb;
 
-	if (IS_ENABLED(CONFIG_BT_USE_DEBUG_KEYS) &&
-	    BT_CMD_TEST(bt_dev.supported_commands, 41, 2)) {
-		err = hci_generate_dhkey_v2(remote_pk,
-					    BT_HCI_LE_KEY_TYPE_DEBUG);
+	if (IS_ENABLED(CONFIG_BT_USE_DEBUG_KEYS) && BT_CMD_TEST(bt_dev.supported_commands, 41, 2)) {
+		err = hci_generate_dhkey_v2(remote_pk, BT_HCI_LE_KEY_TYPE_DEBUG);
 	} else {
 		err = hci_generate_dhkey_v1(remote_pk);
 	}
diff --git a/subsys/bluetooth/host/ecc.h b/subsys/bluetooth/host/ecc.h
index a5866097847..f426b815dd8 100644
--- a/subsys/bluetooth/host/ecc.h
+++ b/subsys/bluetooth/host/ecc.h
@@ -7,15 +7,15 @@
  */
 
 /** Key size used in Bluetooth's ECC domain. */
-#define BT_ECC_KEY_SIZE            32
+#define BT_ECC_KEY_SIZE      32
 /** Length of a Bluetooth ECC public key coordinate. */
-#define BT_PUB_KEY_COORD_LEN       (BT_ECC_KEY_SIZE)
+#define BT_PUB_KEY_COORD_LEN (BT_ECC_KEY_SIZE)
 /** Length of a Bluetooth ECC public key. */
-#define BT_PUB_KEY_LEN             (2 * (BT_PUB_KEY_COORD_LEN))
+#define BT_PUB_KEY_LEN       (2 * (BT_PUB_KEY_COORD_LEN))
 /** Length of a Bluetooth ECC private key. */
-#define BT_PRIV_KEY_LEN            (BT_ECC_KEY_SIZE)
+#define BT_PRIV_KEY_LEN      (BT_ECC_KEY_SIZE)
 /** Length of a Bluetooth Diffie-Hellman key. */
-#define BT_DH_KEY_LEN              (BT_ECC_KEY_SIZE)
+#define BT_DH_KEY_LEN        (BT_ECC_KEY_SIZE)
 
 /*  @brief Container for public key callback */
 struct bt_pub_key_cb {
diff --git a/subsys/bluetooth/host/gatt.c b/subsys/bluetooth/host/gatt.c
index 86ed719b29b..ff667d599a6 100644
--- a/subsys/bluetooth/host/gatt.c
+++ b/subsys/bluetooth/host/gatt.c
@@ -46,8 +46,8 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(bt_gatt);
 
-#define SC_TIMEOUT	K_MSEC(10)
-#define DB_HASH_TIMEOUT	K_MSEC(10)
+#define SC_TIMEOUT      K_MSEC(10)
+#define DB_HASH_TIMEOUT K_MSEC(10)
 
 static uint16_t last_static_handle;
 
@@ -90,20 +90,18 @@ enum gatt_global_flags {
 
 static ATOMIC_DEFINE(gatt_flags, GATT_NUM_FLAGS);
 
-static ssize_t read_name(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			 void *buf, uint16_t len, uint16_t offset)
+static ssize_t read_name(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+			 uint16_t len, uint16_t offset)
 {
 	const char *name = bt_get_name();
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
-				 strlen(name));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, name, strlen(name));
 }
 
 #if defined(CONFIG_BT_DEVICE_NAME_GATT_WRITABLE)
 
-static ssize_t write_name(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			 const void *buf, uint16_t len, uint16_t offset,
-			 uint8_t flags)
+static ssize_t write_name(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
+			  uint16_t len, uint16_t offset, uint8_t flags)
 {
 	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
 
@@ -124,23 +122,20 @@ static ssize_t write_name(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 
 #endif /* CONFIG_BT_DEVICE_NAME_GATT_WRITABLE */
 
-static ssize_t read_appearance(struct bt_conn *conn,
-			       const struct bt_gatt_attr *attr, void *buf,
+static ssize_t read_appearance(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			       uint16_t len, uint16_t offset)
 {
 	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
-				 sizeof(appearance));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance, sizeof(appearance));
 }
 
 #if defined(CONFIG_BT_DEVICE_APPEARANCE_GATT_WRITABLE)
 static ssize_t write_appearance(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			 const void *buf, uint16_t len, uint16_t offset,
-			 uint8_t flags)
+				const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
 {
 	uint16_t appearance_le = sys_cpu_to_le16(bt_get_appearance());
-	char * const appearance_le_bytes = (char *)&appearance_le;
+	char *const appearance_le_bytes = (char *)&appearance_le;
 	uint16_t appearance;
 	int err;
 
@@ -166,38 +161,36 @@ static ssize_t write_appearance(struct bt_conn *conn, const struct bt_gatt_attr
 #endif /* CONFIG_BT_DEVICE_APPEARANCE_GATT_WRITABLE */
 
 #if defined(CONFIG_BT_DEVICE_APPEARANCE_GATT_WRITABLE)
-	#define GAP_APPEARANCE_PROPS (BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE)
+#define GAP_APPEARANCE_PROPS (BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE)
 #if defined(CONFIG_DEVICE_APPEARANCE_GATT_WRITABLE_AUTHEN)
-	#define GAP_APPEARANCE_PERMS (BT_GATT_PERM_READ | BT_GATT_PERM_WRITE_AUTHEN)
+#define GAP_APPEARANCE_PERMS (BT_GATT_PERM_READ | BT_GATT_PERM_WRITE_AUTHEN)
 #elif defined(CONFIG_BT_DEVICE_APPEARANCE_GATT_WRITABLE_ENCRYPT)
-	#define GAP_APPEARANCE_PERMS (BT_GATT_PERM_READ | BT_GATT_PERM_WRITE_ENCRYPT)
+#define GAP_APPEARANCE_PERMS (BT_GATT_PERM_READ | BT_GATT_PERM_WRITE_ENCRYPT)
 #else
-	#define GAP_APPEARANCE_PERMS (BT_GATT_PERM_READ | BT_GATT_PERM_WRITE)
+#define GAP_APPEARANCE_PERMS (BT_GATT_PERM_READ | BT_GATT_PERM_WRITE)
 #endif
-	#define GAP_APPEARANCE_WRITE_HANDLER write_appearance
+#define GAP_APPEARANCE_WRITE_HANDLER write_appearance
 #else
-	#define GAP_APPEARANCE_PROPS BT_GATT_CHRC_READ
-	#define GAP_APPEARANCE_PERMS BT_GATT_PERM_READ
-	#define GAP_APPEARANCE_WRITE_HANDLER NULL
+#define GAP_APPEARANCE_PROPS         BT_GATT_CHRC_READ
+#define GAP_APPEARANCE_PERMS         BT_GATT_PERM_READ
+#define GAP_APPEARANCE_WRITE_HANDLER NULL
 #endif
 
-#if defined (CONFIG_BT_GAP_PERIPHERAL_PREF_PARAMS)
+#if defined(CONFIG_BT_GAP_PERIPHERAL_PREF_PARAMS)
 /* This checks if the range entered is valid */
 BUILD_ASSERT(!(CONFIG_BT_PERIPHERAL_PREF_MIN_INT > 3200 &&
-	     CONFIG_BT_PERIPHERAL_PREF_MIN_INT < 0xffff));
+	       CONFIG_BT_PERIPHERAL_PREF_MIN_INT < 0xffff));
 BUILD_ASSERT(!(CONFIG_BT_PERIPHERAL_PREF_MAX_INT > 3200 &&
-	     CONFIG_BT_PERIPHERAL_PREF_MAX_INT < 0xffff));
+	       CONFIG_BT_PERIPHERAL_PREF_MAX_INT < 0xffff));
 BUILD_ASSERT(!(CONFIG_BT_PERIPHERAL_PREF_TIMEOUT > 3200 &&
-	     CONFIG_BT_PERIPHERAL_PREF_TIMEOUT < 0xffff));
+	       CONFIG_BT_PERIPHERAL_PREF_TIMEOUT < 0xffff));
 BUILD_ASSERT((CONFIG_BT_PERIPHERAL_PREF_MIN_INT == 0xffff) ||
-	     (CONFIG_BT_PERIPHERAL_PREF_MIN_INT <=
-	     CONFIG_BT_PERIPHERAL_PREF_MAX_INT));
+	     (CONFIG_BT_PERIPHERAL_PREF_MIN_INT <= CONFIG_BT_PERIPHERAL_PREF_MAX_INT));
 BUILD_ASSERT((CONFIG_BT_PERIPHERAL_PREF_TIMEOUT * 4U) >
-	     ((1U + CONFIG_BT_PERIPHERAL_PREF_LATENCY) *
-	      CONFIG_BT_PERIPHERAL_PREF_MAX_INT));
+	     ((1U + CONFIG_BT_PERIPHERAL_PREF_LATENCY) * CONFIG_BT_PERIPHERAL_PREF_MAX_INT));
 
-static ssize_t read_ppcp(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			 void *buf, uint16_t len, uint16_t offset)
+static ssize_t read_ppcp(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+			 uint16_t len, uint16_t offset)
 {
 	struct __packed {
 		uint16_t min_int;
@@ -211,53 +204,49 @@ static ssize_t read_ppcp(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
 	ppcp.timeout = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
-				 sizeof(ppcp));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp, sizeof(ppcp));
 }
 #endif
 
 #if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_PRIVACY)
-static ssize_t read_central_addr_res(struct bt_conn *conn,
-				     const struct bt_gatt_attr *attr, void *buf,
-				     uint16_t len, uint16_t offset)
+static ssize_t read_central_addr_res(struct bt_conn *conn, const struct bt_gatt_attr *attr,
+				     void *buf, uint16_t len, uint16_t offset)
 {
 	uint8_t central_addr_res = BT_GATT_CENTRAL_ADDR_RES_SUPP;
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset,
-				 &central_addr_res, sizeof(central_addr_res));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &central_addr_res,
+				 sizeof(central_addr_res));
 }
 #endif /* CONFIG_BT_CENTRAL && CONFIG_BT_PRIVACY */
 
-BT_GATT_SERVICE_DEFINE(_2_gap_svc,
-	BT_GATT_PRIMARY_SERVICE(BT_UUID_GAP),
+BT_GATT_SERVICE_DEFINE(_2_gap_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_GAP),
 #if defined(CONFIG_BT_DEVICE_NAME_GATT_WRITABLE)
-	/* Require pairing for writes to device name */
-	BT_GATT_CHARACTERISTIC(BT_UUID_GAP_DEVICE_NAME,
-			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
-			       BT_GATT_PERM_READ |
+		       /* Require pairing for writes to device name */
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GAP_DEVICE_NAME,
+					      BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
+					      BT_GATT_PERM_READ |
 #if defined(CONFIG_DEVICE_NAME_GATT_WRITABLE_AUTHEN)
-			       BT_GATT_PERM_WRITE_AUTHEN,
+						      BT_GATT_PERM_WRITE_AUTHEN,
 #elif defined(CONFIG_DEVICE_NAME_GATT_WRITABLE_ENCRYPT)
-			       BT_GATT_PERM_WRITE_ENCRYPT,
+						      BT_GATT_PERM_WRITE_ENCRYPT,
 #else
-			       BT_GATT_PERM_WRITE,
+						      BT_GATT_PERM_WRITE,
 #endif
-			       read_name, write_name, bt_dev.name),
+					      read_name, write_name, bt_dev.name),
 #else
-	BT_GATT_CHARACTERISTIC(BT_UUID_GAP_DEVICE_NAME, BT_GATT_CHRC_READ,
-			       BT_GATT_PERM_READ, read_name, NULL, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GAP_DEVICE_NAME, BT_GATT_CHRC_READ,
+					      BT_GATT_PERM_READ, read_name, NULL, NULL),
 #endif /* CONFIG_BT_DEVICE_NAME_GATT_WRITABLE */
-	BT_GATT_CHARACTERISTIC(BT_UUID_GAP_APPEARANCE, GAP_APPEARANCE_PROPS,
-			       GAP_APPEARANCE_PERMS, read_appearance,
-			       GAP_APPEARANCE_WRITE_HANDLER, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GAP_APPEARANCE, GAP_APPEARANCE_PROPS,
+					      GAP_APPEARANCE_PERMS, read_appearance,
+					      GAP_APPEARANCE_WRITE_HANDLER, NULL),
 #if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_PRIVACY)
-	BT_GATT_CHARACTERISTIC(BT_UUID_CENTRAL_ADDR_RES,
-			       BT_GATT_CHRC_READ, BT_GATT_PERM_READ,
-			       read_central_addr_res, NULL, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_CENTRAL_ADDR_RES, BT_GATT_CHRC_READ,
+					      BT_GATT_PERM_READ, read_central_addr_res, NULL, NULL),
 #endif /* CONFIG_BT_CENTRAL && CONFIG_BT_PRIVACY */
 #if defined(CONFIG_BT_GAP_PERIPHERAL_PREF_PARAMS)
-	BT_GATT_CHARACTERISTIC(BT_UUID_GAP_PPCP, BT_GATT_CHRC_READ,
-			       BT_GATT_PERM_READ, read_ppcp, NULL, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GAP_PPCP, BT_GATT_CHRC_READ,
+					      BT_GATT_PERM_READ, read_ppcp, NULL, NULL),
 #endif
 );
 
@@ -267,11 +256,11 @@ struct sc_data {
 } __packed;
 
 struct gatt_sc_cfg {
-	uint8_t		id;
-	bt_addr_le_t	peer;
+	uint8_t id;
+	bt_addr_le_t peer;
 	struct {
-		uint16_t		start;
-		uint16_t		end;
+		uint16_t start;
+		uint16_t end;
 	} data;
 };
 
@@ -286,11 +275,11 @@ BUILD_ASSERT(sizeof(struct sc_data) == sizeof(sc_cfg[0].data));
 enum {
 	SC_RANGE_CHANGED,    /* SC range changed */
 	SC_INDICATE_PENDING, /* SC indicate pending */
-	SC_LOAD,	     /* SC has been loaded from settings */
+	SC_LOAD,             /* SC has been loaded from settings */
 
-	DB_HASH_VALID,       /* Database hash needs to be calculated */
-	DB_HASH_LOAD,        /* Database hash loaded from settings. */
-	DB_HASH_LOAD_PROC,   /* DB hash loaded from settings has been processed. */
+	DB_HASH_VALID,     /* Database hash needs to be calculated */
+	DB_HASH_LOAD,      /* Database hash loaded from settings. */
+	DB_HASH_LOAD_PROC, /* DB hash loaded from settings has been processed. */
 
 	/* Total number of flags - must be at the end of the enum */
 	SC_NUM_FLAGS,
@@ -311,7 +300,7 @@ static struct gatt_sc {
 static struct db_hash {
 	uint8_t hash[16];
 #if defined(CONFIG_BT_SETTINGS)
-	 uint8_t stored_hash[16];
+	uint8_t stored_hash[16];
 #endif
 	struct k_work_delayable work;
 	struct k_work_sync sync;
@@ -323,8 +312,7 @@ static struct gatt_sc_cfg *find_sc_cfg(uint8_t id, const bt_addr_le_t *addr)
 	LOG_DBG("id: %u, addr: %s", id, bt_addr_le_str(addr));
 
 	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
-		if (id == sc_cfg[i].id &&
-		    bt_addr_le_eq(&sc_cfg[i].peer, addr)) {
+		if (id == sc_cfg[i].id && bt_addr_le_eq(&sc_cfg[i].peer, addr)) {
 			return &sc_cfg[i];
 		}
 	}
@@ -407,8 +395,7 @@ static void sc_reset(struct gatt_sc_cfg *cfg)
 	}
 }
 
-static bool update_range(uint16_t *start, uint16_t *end, uint16_t new_start,
-			 uint16_t new_end)
+static bool update_range(uint16_t *start, uint16_t *end, uint16_t new_start, uint16_t new_end)
 {
 	LOG_DBG("start 0x%04x end 0x%04x new_start 0x%04x new_end 0x%04x", *start, *end, new_start,
 		new_end);
@@ -461,14 +448,14 @@ static void sc_save(uint8_t id, bt_addr_le_t *peer, uint16_t start, uint16_t end
 	modified = update_range(&cfg->data.start, &cfg->data.end, start, end);
 
 done:
-	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
-	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
+	if (IS_ENABLED(CONFIG_BT_SETTINGS) && modified &&
+	    bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
 		sc_store(cfg);
 	}
 }
 
-static ssize_t sc_ccc_cfg_write(struct bt_conn *conn,
-				const struct bt_gatt_attr *attr, uint16_t value)
+static ssize_t sc_ccc_cfg_write(struct bt_conn *conn, const struct bt_gatt_attr *attr,
+				uint16_t value)
 {
 	LOG_DBG("value 0x%04x", value);
 
@@ -482,38 +469,36 @@ static ssize_t sc_ccc_cfg_write(struct bt_conn *conn,
 	return sizeof(value);
 }
 
-static struct _bt_gatt_ccc sc_ccc = BT_GATT_CCC_INITIALIZER(NULL,
-							    sc_ccc_cfg_write,
-							    NULL);
+static struct _bt_gatt_ccc sc_ccc = BT_GATT_CCC_INITIALIZER(NULL, sc_ccc_cfg_write, NULL);
 
 /* Do not shuffle the values in this enum, they are used as bit offsets when
  * saving the CF flags to NVS (i.e. NVS persists between FW upgrades).
  */
 enum {
-	CF_CHANGE_AWARE,	/* Client is changed aware */
-	CF_DB_HASH_READ,	/* The client has read the database hash */
+	CF_CHANGE_AWARE, /* Client is changed aware */
+	CF_DB_HASH_READ, /* The client has read the database hash */
 
 	/* Total number of flags - must be at the end of the enum */
 	CF_NUM_FLAGS,
 };
 
-#define CF_BIT_ROBUST_CACHING	0
-#define CF_BIT_EATT		1
-#define CF_BIT_NOTIFY_MULTI	2
-#define CF_BIT_LAST		CF_BIT_NOTIFY_MULTI
+#define CF_BIT_ROBUST_CACHING 0
+#define CF_BIT_EATT           1
+#define CF_BIT_NOTIFY_MULTI   2
+#define CF_BIT_LAST           CF_BIT_NOTIFY_MULTI
 
-#define CF_NUM_BITS		(CF_BIT_LAST + 1)
-#define CF_NUM_BYTES		((CF_BIT_LAST / 8) + 1)
-#define CF_FLAGS_STORE_LEN	1
+#define CF_NUM_BITS        (CF_BIT_LAST + 1)
+#define CF_NUM_BYTES       ((CF_BIT_LAST / 8) + 1)
+#define CF_FLAGS_STORE_LEN 1
 
 #define CF_ROBUST_CACHING(_cfg) (_cfg->data[0] & BIT(CF_BIT_ROBUST_CACHING))
-#define CF_EATT(_cfg) (_cfg->data[0] & BIT(CF_BIT_EATT))
-#define CF_NOTIFY_MULTI(_cfg) (_cfg->data[0] & BIT(CF_BIT_NOTIFY_MULTI))
+#define CF_EATT(_cfg)           (_cfg->data[0] & BIT(CF_BIT_EATT))
+#define CF_NOTIFY_MULTI(_cfg)   (_cfg->data[0] & BIT(CF_BIT_NOTIFY_MULTI))
 
 struct gatt_cf_cfg {
-	uint8_t			id;
-	bt_addr_le_t		peer;
-	uint8_t			data[CF_NUM_BYTES];
+	uint8_t id;
+	bt_addr_le_t peer;
+	uint8_t data[CF_NUM_BYTES];
 	ATOMIC_DEFINE(flags, CF_NUM_FLAGS);
 };
 
@@ -593,7 +578,7 @@ static void set_all_change_unaware(void)
 			bt_gatt_store_cf(cfg->id, &cfg->peer);
 		}
 	}
-#endif	/* CONFIG_BT_SETTINGS */
+#endif /* CONFIG_BT_SETTINGS */
 }
 
 static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
@@ -615,8 +600,8 @@ static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
 	return NULL;
 }
 
-static ssize_t cf_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-		       void *buf, uint16_t len, uint16_t offset)
+static ssize_t cf_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+		       uint16_t len, uint16_t offset)
 {
 	struct gatt_cf_cfg *cfg;
 	uint8_t data[1] = {};
@@ -626,8 +611,7 @@ static ssize_t cf_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 		memcpy(data, cfg->data, sizeof(data));
 	}
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
-				 sizeof(data));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, data, sizeof(data));
 }
 
 static bool cf_set_value(struct gatt_cf_cfg *cfg, const uint8_t *value, uint16_t len)
@@ -636,8 +620,7 @@ static bool cf_set_value(struct gatt_cf_cfg *cfg, const uint8_t *value, uint16_t
 
 	/* Validate the bits */
 	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
-		if ((cfg->data[i / 8] & BIT(i % 8)) &&
-		    !(value[i / 8] & BIT(i % 8))) {
+		if ((cfg->data[i / 8] & BIT(i % 8)) && !(value[i / 8] & BIT(i % 8))) {
 			/* A client shall never clear a bit it has set */
 			return false;
 		}
@@ -657,8 +640,8 @@ static bool cf_set_value(struct gatt_cf_cfg *cfg, const uint8_t *value, uint16_t
 	return true;
 }
 
-static ssize_t cf_write(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
+static ssize_t cf_write(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
+			uint16_t len, uint16_t offset, uint8_t flags)
 {
 	struct gatt_cf_cfg *cfg;
 	const uint8_t *value = buf;
@@ -714,8 +697,7 @@ static int db_hash_setup(struct gen_hash_state *state, uint8_t *key)
 		return -EIO;
 	}
 	state->operation = psa_mac_operation_init();
-	if (psa_mac_sign_setup(&(state->operation), state->key,
-			       PSA_ALG_CMAC) != PSA_SUCCESS) {
+	if (psa_mac_sign_setup(&(state->operation), state->key, PSA_ALG_CMAC) != PSA_SUCCESS) {
 		LOG_ERR("CMAC operation init failed");
 		return -EIO;
 	}
@@ -735,8 +717,8 @@ static int db_hash_finish(struct gen_hash_state *state)
 {
 	size_t mac_length;
 
-	if (psa_mac_sign_finish(&(state->operation), db_hash.hash, 16,
-				&mac_length) != PSA_SUCCESS) {
+	if (psa_mac_sign_finish(&(state->operation), db_hash.hash, 16, &mac_length) !=
+	    PSA_SUCCESS) {
 		LOG_ERR("CMAC finish failed");
 		return -EIO;
 	}
@@ -749,7 +731,7 @@ union hash_attr_value {
 	 */
 	union {
 		uint16_t uuid16;
-		uint8_t  uuid128[BT_UUID_SIZE_128];
+		uint8_t uuid128[BT_UUID_SIZE_128];
 	} __packed service;
 	/* Bluetooth Core Specification Version 5.3 | Vol 3, Part G
 	 * Table 3.2: Include declaration
@@ -767,7 +749,7 @@ union hash_attr_value {
 		uint16_t value_handle;
 		union {
 			uint16_t uuid16;
-			uint8_t  uuid128[BT_UUID_SIZE_128];
+			uint8_t uuid128[BT_UUID_SIZE_128];
 		} __packed;
 	} __packed chrc;
 	/* Bluetooth Core Specification Version 5.3 | Vol 3, Part G
@@ -778,8 +760,7 @@ union hash_attr_value {
 	} __packed cep;
 } __packed;
 
-static uint8_t gen_hash_m(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t gen_hash_m(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct gen_hash_state *state = user_data;
 	struct bt_uuid_16 *u16;
@@ -801,15 +782,13 @@ static uint8_t gen_hash_m(const struct bt_gatt_attr *attr, uint16_t handle,
 	case BT_UUID_GATT_CHRC_VAL:
 	case BT_UUID_GATT_CEP_VAL:
 		value = sys_cpu_to_le16(handle);
-		if (db_hash_update(state, (uint8_t *)&value,
-				   sizeof(handle)) != 0) {
+		if (db_hash_update(state, (uint8_t *)&value, sizeof(handle)) != 0) {
 			state->err = -EINVAL;
 			return BT_GATT_ITER_STOP;
 		}
 
 		value = sys_cpu_to_le16(u16->val);
-		if (db_hash_update(state, (uint8_t *)&value,
-				   sizeof(u16->val)) != 0) {
+		if (db_hash_update(state, (uint8_t *)&value, sizeof(u16->val)) != 0) {
 			state->err = -EINVAL;
 			return BT_GATT_ITER_STOP;
 		}
@@ -833,15 +812,13 @@ static uint8_t gen_hash_m(const struct bt_gatt_attr *attr, uint16_t handle,
 	case BT_UUID_GATT_CPF_VAL:
 	case BT_UUID_GATT_CAF_VAL:
 		value = sys_cpu_to_le16(handle);
-		if (db_hash_update(state, (uint8_t *)&value,
-				   sizeof(handle)) != 0) {
+		if (db_hash_update(state, (uint8_t *)&value, sizeof(handle)) != 0) {
 			state->err = -EINVAL;
 			return BT_GATT_ITER_STOP;
 		}
 
 		value = sys_cpu_to_le16(u16->val);
-		if (db_hash_update(state, (uint8_t *)&value,
-				   sizeof(u16->val)) != 0) {
+		if (db_hash_update(state, (uint8_t *)&value, sizeof(u16->val)) != 0) {
 			state->err = -EINVAL;
 			return BT_GATT_ITER_STOP;
 		}
@@ -865,7 +842,7 @@ static void db_hash_store(void)
 	}
 
 	LOG_DBG("Database Hash stored");
-#endif	/* CONFIG_BT_SETTINGS */
+#endif /* CONFIG_BT_SETTINGS */
 }
 
 static void db_hash_gen(void)
@@ -908,10 +885,8 @@ static void do_db_hash(void)
 	}
 
 #if defined(CONFIG_BT_SETTINGS)
-	bool hash_loaded_from_settings =
-		atomic_test_bit(gatt_sc.flags, DB_HASH_LOAD);
-	bool already_processed =
-		atomic_test_bit(gatt_sc.flags, DB_HASH_LOAD_PROC);
+	bool hash_loaded_from_settings = atomic_test_bit(gatt_sc.flags, DB_HASH_LOAD);
+	bool already_processed = atomic_test_bit(gatt_sc.flags, DB_HASH_LOAD_PROC);
 
 	if (!hash_loaded_from_settings) {
 		/* we want to generate the hash, but not overwrite the hash
@@ -936,8 +911,7 @@ static void do_db_hash(void)
 		atomic_set_bit(gatt_sc.flags, DB_HASH_LOAD_PROC);
 
 		/* Check if hash matches then skip SC update */
-		if (!memcmp(db_hash.stored_hash, db_hash.hash,
-			    sizeof(db_hash.stored_hash))) {
+		if (!memcmp(db_hash.stored_hash, db_hash.hash, sizeof(db_hash.stored_hash))) {
 			LOG_DBG("Database Hash matches");
 			k_work_cancel_delayable(&gatt_sc.work);
 			atomic_clear_bit(gatt_sc.flags, SC_RANGE_CHANGED);
@@ -970,9 +944,8 @@ static void db_hash_process(struct k_work *work)
 	do_db_hash();
 }
 
-static ssize_t db_hash_read(struct bt_conn *conn,
-			    const struct bt_gatt_attr *attr,
-			    void *buf, uint16_t len, uint16_t offset)
+static ssize_t db_hash_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+			    uint16_t len, uint16_t offset)
 {
 	struct gatt_cf_cfg *cfg;
 
@@ -995,14 +968,11 @@ static ssize_t db_hash_read(struct bt_conn *conn,
 	 * receives another ATT request from the client.
 	 */
 	cfg = find_cf_cfg(conn);
-	if (cfg &&
-	    CF_ROBUST_CACHING(cfg) &&
-	    !atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
+	if (cfg && CF_ROBUST_CACHING(cfg) && !atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
 		atomic_set_bit(cfg->flags, CF_DB_HASH_READ);
 	}
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash,
-				 sizeof(db_hash.hash));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash, sizeof(db_hash.hash));
 }
 
 static void remove_cf_cfg(struct bt_conn *conn)
@@ -1029,22 +999,20 @@ static void remove_cf_cfg(struct bt_conn *conn)
 }
 
 #if defined(CONFIG_BT_EATT)
-#define SF_BIT_EATT	0
-#define SF_BIT_LAST	SF_BIT_EATT
+#define SF_BIT_EATT 0
+#define SF_BIT_LAST SF_BIT_EATT
 
-static ssize_t sf_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-		       void *buf, uint16_t len, uint16_t offset)
+static ssize_t sf_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+		       uint16_t len, uint16_t offset)
 {
 	uint8_t value = BIT(SF_BIT_EATT);
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
-				 sizeof(value));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value, sizeof(value));
 }
 #endif /* CONFIG_BT_EATT */
 #endif /* CONFIG_BT_GATT_CACHING */
 
-static struct gatt_cf_cfg *find_cf_cfg_by_addr(uint8_t id,
-					       const bt_addr_le_t *addr);
+static struct gatt_cf_cfg *find_cf_cfg_by_addr(uint8_t id, const bt_addr_le_t *addr);
 
 static int bt_gatt_store_cf(uint8_t id, const bt_addr_le_t *peer)
 {
@@ -1088,7 +1056,6 @@ static int bt_gatt_store_cf(uint8_t id, const bt_addr_le_t *peer)
 	LOG_HEXDUMP_DBG(str, len, "Saved data");
 #endif /* CONFIG_BT_GATT_CACHING */
 	return 0;
-
 }
 
 static bool is_host_managed_ccc(const struct bt_gatt_attr *attr)
@@ -1106,8 +1073,8 @@ struct addr_match {
 	const bt_addr_le_t *id_addr;
 };
 
-static uint8_t convert_to_id_on_match(const struct bt_gatt_attr *attr,
-				      uint16_t handle, void *user_data)
+static uint8_t convert_to_id_on_match(const struct bt_gatt_attr *attr, uint16_t handle,
+				      void *user_data)
 {
 	struct _bt_gatt_ccc *ccc;
 	struct addr_match *match = user_data;
@@ -1134,10 +1101,7 @@ static void bt_gatt_identity_resolved(struct bt_conn *conn, const bt_addr_le_t *
 				      const bt_addr_le_t *id_addr)
 {
 	/* Update the ccc cfg addresses */
-	struct addr_match user_data = {
-		.private_addr = private_addr,
-		.id_addr      = id_addr
-	};
+	struct addr_match user_data = {.private_addr = private_addr, .id_addr = id_addr};
 	bool is_bonded = bt_addr_le_is_bonded(conn->id, &conn->le.dst);
 
 	bt_gatt_foreach_attr(0x0001, 0xffff, convert_to_id_on_match, &user_data);
@@ -1168,37 +1132,33 @@ static void bt_gatt_pairing_complete(struct bt_conn *conn, bool bonded)
 }
 #endif /* CONFIG_BT_SETTINGS && CONFIG_BT_SMP */
 
-BT_GATT_SERVICE_DEFINE(_1_gatt_svc,
-	BT_GATT_PRIMARY_SERVICE(BT_UUID_GATT),
+BT_GATT_SERVICE_DEFINE(_1_gatt_svc, BT_GATT_PRIMARY_SERVICE(BT_UUID_GATT),
 #if defined(CONFIG_BT_GATT_SERVICE_CHANGED)
-	/* Bluetooth 5.0, Vol3 Part G:
-	 * The Service Changed characteristic Attribute Handle on the server
-	 * shall not change if the server has a trusted relationship with any
-	 * client.
-	 */
-	BT_GATT_CHARACTERISTIC(BT_UUID_GATT_SC, BT_GATT_CHRC_INDICATE,
-			       BT_GATT_PERM_NONE, NULL, NULL, NULL),
-	BT_GATT_CCC_MANAGED(&sc_ccc, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
+		       /* Bluetooth 5.0, Vol3 Part G:
+			* The Service Changed characteristic Attribute Handle on the server
+			* shall not change if the server has a trusted relationship with any
+			* client.
+			*/
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GATT_SC, BT_GATT_CHRC_INDICATE,
+					      BT_GATT_PERM_NONE, NULL, NULL, NULL),
+		       BT_GATT_CCC_MANAGED(&sc_ccc, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
 #if defined(CONFIG_BT_GATT_CACHING)
-	BT_GATT_CHARACTERISTIC(BT_UUID_GATT_CLIENT_FEATURES,
-			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
-			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE,
-			       cf_read, cf_write, NULL),
-	BT_GATT_CHARACTERISTIC(BT_UUID_GATT_DB_HASH,
-			       BT_GATT_CHRC_READ, BT_GATT_PERM_READ,
-			       db_hash_read, NULL, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GATT_CLIENT_FEATURES,
+					      BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
+					      BT_GATT_PERM_READ | BT_GATT_PERM_WRITE, cf_read,
+					      cf_write, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GATT_DB_HASH, BT_GATT_CHRC_READ,
+					      BT_GATT_PERM_READ, db_hash_read, NULL, NULL),
 #if defined(CONFIG_BT_EATT)
-	BT_GATT_CHARACTERISTIC(BT_UUID_GATT_SERVER_FEATURES,
-			       BT_GATT_CHRC_READ, BT_GATT_PERM_READ,
-			       sf_read, NULL, NULL),
+		       BT_GATT_CHARACTERISTIC(BT_UUID_GATT_SERVER_FEATURES, BT_GATT_CHRC_READ,
+					      BT_GATT_PERM_READ, sf_read, NULL, NULL),
 #endif /* CONFIG_BT_EATT */
 #endif /* CONFIG_BT_GATT_CACHING */
 #endif /* CONFIG_BT_GATT_SERVICE_CHANGED */
 );
 
 #if defined(CONFIG_BT_GATT_DYNAMIC_DB)
-static uint8_t found_attr(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t found_attr(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	const struct bt_gatt_attr **found = user_data;
 
@@ -1292,8 +1252,8 @@ static inline void sc_work_submit(k_timeout_t timeout)
 }
 
 #if defined(CONFIG_BT_GATT_SERVICE_CHANGED)
-static void sc_indicate_rsp(struct bt_conn *conn,
-			    struct bt_gatt_indicate_params *params, uint8_t err)
+static void sc_indicate_rsp(struct bt_conn *conn, struct bt_gatt_indicate_params *params,
+			    uint8_t err)
 {
 #if defined(CONFIG_BT_GATT_CACHING)
 	struct gatt_cf_cfg *cfg;
@@ -1332,8 +1292,7 @@ static void sc_process(struct k_work *work)
 	struct gatt_sc *sc = CONTAINER_OF(dwork, struct gatt_sc, work);
 	uint16_t sc_range[2];
 
-	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
-		 "Indicate already pending");
+	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING), "Indicate already pending");
 
 	LOG_DBG("start 0x%04x end 0x%04x", sc->start, sc->end);
 
@@ -1384,8 +1343,7 @@ static struct gatt_delayed_store {
 } gatt_delayed_store;
 ))
 
-static struct ds_peer *gatt_delayed_store_find(uint8_t id,
-					       const bt_addr_le_t *peer_addr)
+static struct ds_peer *gatt_delayed_store_find(uint8_t id, const bt_addr_le_t *peer_addr)
 {
 	IF_ENABLED(CONFIG_BT_SETTINGS_DELAYED_STORE, ({
 		struct ds_peer *el;
@@ -1412,8 +1370,7 @@ static void gatt_delayed_store_free(struct ds_peer *el)
 }
 
 #if defined(CONFIG_BT_SETTINGS_DELAYED_STORE)
-static struct ds_peer *gatt_delayed_store_alloc(uint8_t id,
-						const bt_addr_le_t *peer_addr)
+static struct ds_peer *gatt_delayed_store_alloc(uint8_t id, const bt_addr_le_t *peer_addr)
 {
 	struct ds_peer *el;
 
@@ -1458,8 +1415,7 @@ static void delayed_store(struct k_work *work)
 {
 	struct ds_peer *el;
 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
-	struct gatt_delayed_store *store =
-		CONTAINER_OF(dwork, struct gatt_delayed_store, work);
+	struct gatt_delayed_store *store = CONTAINER_OF(dwork, struct gatt_delayed_store, work);
 
 	for (size_t i = 0; i < ARRAY_SIZE(gatt_delayed_store.peer_list); i++) {
 		el = &store->peer_list[i];
@@ -1467,7 +1423,7 @@ static void delayed_store(struct k_work *work)
 		gatt_store_ccc_cf(el->id, &el->peer);
 	}
 }
-#endif	/* CONFIG_BT_SETTINGS_DELAYED_STORE */
+#endif /* CONFIG_BT_SETTINGS_DELAYED_STORE */
 
 static void gatt_store_ccc_cf(uint8_t id, const bt_addr_le_t *peer_addr)
 {
@@ -1650,8 +1606,7 @@ static void gatt_unregister_ccc(struct _bt_gatt_ccc *ccc)
 			if (conn) {
 				if (conn->state == BT_CONN_CONNECTED) {
 #if defined(CONFIG_BT_SETTINGS_CCC_STORE_ON_WRITE)
-					gatt_delayed_store_enqueue(conn->id,
-								   &conn->le.dst,
+					gatt_delayed_store_enqueue(conn->id, &conn->le.dst,
 								   DELAYED_STORE_CCC);
 #endif
 					store = false;
@@ -1701,8 +1656,7 @@ int bt_gatt_service_register(struct bt_gatt_service *svc)
 	__ASSERT(svc->attrs, "invalid parameters\n");
 	__ASSERT(svc->attr_count, "invalid parameters\n");
 
-	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
-	    atomic_test_bit(gatt_flags, GATT_INITIALIZED) &&
+	if (IS_ENABLED(CONFIG_BT_SETTINGS) && atomic_test_bit(gatt_flags, GATT_INITIALIZED) &&
 	    !atomic_test_bit(gatt_sc.flags, SC_LOAD)) {
 		LOG_ERR("Can't register service after init and before settings are loaded.");
 		return -EINVAL;
@@ -1731,8 +1685,7 @@ int bt_gatt_service_register(struct bt_gatt_service *svc)
 		return 0;
 	}
 
-	sc_indicate(svc->attrs[0].handle,
-		    svc->attrs[svc->attr_count - 1].handle);
+	sc_indicate(svc->attrs[0].handle, svc->attrs[svc->attr_count - 1].handle);
 
 	db_changed();
 
@@ -1797,9 +1750,8 @@ bool bt_gatt_service_is_registered(const struct bt_gatt_service *svc)
 }
 #endif /* CONFIG_BT_GATT_DYNAMIC_DB */
 
-ssize_t bt_gatt_attr_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			  void *buf, uint16_t buf_len, uint16_t offset,
-			  const void *value, uint16_t value_len)
+ssize_t bt_gatt_attr_read(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+			  uint16_t buf_len, uint16_t offset, const void *value, uint16_t value_len)
 {
 	uint16_t len;
 
@@ -1825,21 +1777,18 @@ ssize_t bt_gatt_attr_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 	return len;
 }
 
-ssize_t bt_gatt_attr_read_service(struct bt_conn *conn,
-				  const struct bt_gatt_attr *attr,
-				  void *buf, uint16_t len, uint16_t offset)
+ssize_t bt_gatt_attr_read_service(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+				  uint16_t len, uint16_t offset)
 {
 	const struct bt_uuid *uuid = attr->user_data;
 
 	if (uuid->type == BT_UUID_TYPE_16) {
 		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
 
-		return bt_gatt_attr_read(conn, attr, buf, len, offset,
-					 &uuid16, 2);
+		return bt_gatt_attr_read(conn, attr, buf, len, offset, &uuid16, 2);
 	}
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset,
-				 BT_UUID_128(uuid)->val, 16);
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, BT_UUID_128(uuid)->val, 16);
 }
 
 struct gatt_incl {
@@ -1848,8 +1797,8 @@ struct gatt_incl {
 	uint16_t uuid16;
 } __packed;
 
-static uint8_t get_service_handles(const struct bt_gatt_attr *attr,
-				   uint16_t handle, void *user_data)
+static uint8_t get_service_handles(const struct bt_gatt_attr *attr, uint16_t handle,
+				   void *user_data)
 {
 	struct gatt_incl *include = user_data;
 
@@ -1894,9 +1843,8 @@ uint16_t bt_gatt_attr_get_handle(const struct bt_gatt_attr *attr)
 	return 0;
 }
 
-ssize_t bt_gatt_attr_read_included(struct bt_conn *conn,
-				   const struct bt_gatt_attr *attr,
-				   void *buf, uint16_t len, uint16_t offset)
+ssize_t bt_gatt_attr_read_included(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+				   uint16_t len, uint16_t offset)
 {
 	struct bt_gatt_attr *incl = attr->user_data;
 	uint16_t handle = bt_gatt_attr_get_handle(incl);
@@ -1929,7 +1877,7 @@ struct gatt_chrc {
 	uint16_t value_handle;
 	union {
 		uint16_t uuid16;
-		uint8_t  uuid[16];
+		uint8_t uuid[16];
 	} __packed;
 } __packed;
 
@@ -1950,8 +1898,7 @@ uint16_t bt_gatt_attr_value_handle(const struct bt_gatt_attr *attr)
 	return handle;
 }
 
-ssize_t bt_gatt_attr_read_chrc(struct bt_conn *conn,
-			       const struct bt_gatt_attr *attr, void *buf,
+ssize_t bt_gatt_attr_read_chrc(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			       uint16_t len, uint16_t offset)
 {
 	struct bt_gatt_chrc *chrc = attr->user_data;
@@ -1981,12 +1928,10 @@ ssize_t bt_gatt_attr_read_chrc(struct bt_conn *conn,
 	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
 }
 
-static uint8_t gatt_foreach_iter(const struct bt_gatt_attr *attr,
-				 uint16_t handle, uint16_t start_handle,
-				 uint16_t end_handle,
-				 const struct bt_uuid *uuid,
-				 const void *attr_data, uint16_t *num_matches,
-				 bt_gatt_attr_func_t func, void *user_data)
+static uint8_t gatt_foreach_iter(const struct bt_gatt_attr *attr, uint16_t handle,
+				 uint16_t start_handle, uint16_t end_handle,
+				 const struct bt_uuid *uuid, const void *attr_data,
+				 uint16_t *num_matches, bt_gatt_attr_func_t func, void *user_data)
 {
 	uint8_t result;
 
@@ -2022,9 +1967,8 @@ static uint8_t gatt_foreach_iter(const struct bt_gatt_attr *attr,
 }
 
 static void foreach_attr_type_dyndb(uint16_t start_handle, uint16_t end_handle,
-				    const struct bt_uuid *uuid,
-				    const void *attr_data, uint16_t num_matches,
-				    bt_gatt_attr_func_t func, void *user_data)
+				    const struct bt_uuid *uuid, const void *attr_data,
+				    uint16_t num_matches, bt_gatt_attr_func_t func, void *user_data)
 {
 #if defined(CONFIG_BT_GATT_DYNAMIC_DB)
 	size_t i;
@@ -2044,13 +1988,9 @@ static void foreach_attr_type_dyndb(uint16_t start_handle, uint16_t end_handle,
 		for (i = 0; i < svc->attr_count; i++) {
 			struct bt_gatt_attr *attr = &svc->attrs[i];
 
-			if (gatt_foreach_iter(attr, attr->handle,
-					      start_handle,
-					      end_handle,
-					      uuid, attr_data,
-					      &num_matches,
-					      func, user_data) ==
-			    BT_GATT_ITER_STOP) {
+			if (gatt_foreach_iter(attr, attr->handle, start_handle, end_handle, uuid,
+					      attr_data, &num_matches, func,
+					      user_data) == BT_GATT_ITER_STOP) {
 				return;
 			}
 		}
@@ -2059,9 +1999,8 @@ static void foreach_attr_type_dyndb(uint16_t start_handle, uint16_t end_handle,
 }
 
 void bt_gatt_foreach_attr_type(uint16_t start_handle, uint16_t end_handle,
-			       const struct bt_uuid *uuid,
-			       const void *attr_data, uint16_t num_matches,
-			       bt_gatt_attr_func_t func, void *user_data)
+			       const struct bt_uuid *uuid, const void *attr_data,
+			       uint16_t num_matches, bt_gatt_attr_func_t func, void *user_data)
 {
 	size_t i;
 
@@ -2080,12 +2019,9 @@ void bt_gatt_foreach_attr_type(uint16_t start_handle, uint16_t end_handle,
 			}
 
 			for (i = 0; i < static_svc->attr_count; i++, handle++) {
-				if (gatt_foreach_iter(&static_svc->attrs[i],
-						      handle, start_handle,
-						      end_handle, uuid,
-						      attr_data, &num_matches,
-						      func, user_data) ==
-				    BT_GATT_ITER_STOP) {
+				if (gatt_foreach_iter(&static_svc->attrs[i], handle, start_handle,
+						      end_handle, uuid, attr_data, &num_matches,
+						      func, user_data) == BT_GATT_ITER_STOP) {
 					return;
 				}
 			}
@@ -2093,12 +2029,11 @@ void bt_gatt_foreach_attr_type(uint16_t start_handle, uint16_t end_handle,
 	}
 
 	/* Iterate over dynamic db */
-	foreach_attr_type_dyndb(start_handle, end_handle, uuid, attr_data,
-				num_matches, func, user_data);
+	foreach_attr_type_dyndb(start_handle, end_handle, uuid, attr_data, num_matches, func,
+				user_data);
 }
 
-static uint8_t find_next(const struct bt_gatt_attr *attr, uint16_t handle,
-			 void *user_data)
+static uint8_t find_next(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct bt_gatt_attr **next = user_data;
 
@@ -2117,15 +2052,13 @@ struct bt_gatt_attr *bt_gatt_attr_next(const struct bt_gatt_attr *attr)
 	return next;
 }
 
-static struct bt_gatt_ccc_cfg *find_ccc_cfg(const struct bt_conn *conn,
-					    struct _bt_gatt_ccc *ccc)
+static struct bt_gatt_ccc_cfg *find_ccc_cfg(const struct bt_conn *conn, struct _bt_gatt_ccc *ccc)
 {
 	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
 		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
 
 		if (conn) {
-			if (bt_conn_is_peer_addr_le(conn, cfg->id,
-						    &cfg->peer)) {
+			if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
 				return cfg;
 			}
 		} else if (bt_addr_le_eq(&cfg->peer, BT_ADDR_LE_ANY)) {
@@ -2136,8 +2069,7 @@ static struct bt_gatt_ccc_cfg *find_ccc_cfg(const struct bt_conn *conn,
 	return NULL;
 }
 
-ssize_t bt_gatt_attr_read_ccc(struct bt_conn *conn,
-			      const struct bt_gatt_attr *attr, void *buf,
+ssize_t bt_gatt_attr_read_ccc(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			      uint16_t len, uint16_t offset)
 {
 	struct _bt_gatt_ccc *ccc = attr->user_data;
@@ -2152,12 +2084,10 @@ ssize_t bt_gatt_attr_read_ccc(struct bt_conn *conn,
 		value = 0x0000;
 	}
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
-				 sizeof(value));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value, sizeof(value));
 }
 
-static void gatt_ccc_changed(const struct bt_gatt_attr *attr,
-			     struct _bt_gatt_ccc *ccc)
+static void gatt_ccc_changed(const struct bt_gatt_attr *attr, struct _bt_gatt_ccc *ccc)
 {
 	int i;
 	uint16_t value = 0x0000;
@@ -2187,9 +2117,8 @@ static void gatt_ccc_changed(const struct bt_gatt_attr *attr,
 	}
 }
 
-ssize_t bt_gatt_attr_write_ccc(struct bt_conn *conn,
-			       const struct bt_gatt_attr *attr, const void *buf,
-			       uint16_t len, uint16_t offset, uint8_t flags)
+ssize_t bt_gatt_attr_write_ccc(struct bt_conn *conn, const struct bt_gatt_attr *attr,
+			       const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
 {
 	struct _bt_gatt_ccc *ccc = attr->user_data;
 	struct bt_gatt_ccc_cfg *cfg;
@@ -2269,37 +2198,32 @@ ssize_t bt_gatt_attr_write_ccc(struct bt_conn *conn,
 	return len;
 }
 
-ssize_t bt_gatt_attr_read_cep(struct bt_conn *conn,
-			      const struct bt_gatt_attr *attr, void *buf,
+ssize_t bt_gatt_attr_read_cep(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			      uint16_t len, uint16_t offset)
 {
 	const struct bt_gatt_cep *value = attr->user_data;
 	uint16_t props = sys_cpu_to_le16(value->properties);
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, &props,
-				 sizeof(props));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &props, sizeof(props));
 }
 
-ssize_t bt_gatt_attr_read_cud(struct bt_conn *conn,
-			      const struct bt_gatt_attr *attr, void *buf,
+ssize_t bt_gatt_attr_read_cud(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			      uint16_t len, uint16_t offset)
 {
 	const char *value = attr->user_data;
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
-				 strlen(value));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, value, strlen(value));
 }
 
 struct gatt_cpf {
-	uint8_t  format;
-	int8_t   exponent;
+	uint8_t format;
+	int8_t exponent;
 	uint16_t unit;
-	uint8_t  name_space;
+	uint8_t name_space;
 	uint16_t description;
 } __packed;
 
-ssize_t bt_gatt_attr_read_cpf(struct bt_conn *conn,
-			      const struct bt_gatt_attr *attr, void *buf,
+ssize_t bt_gatt_attr_read_cpf(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			      uint16_t len, uint16_t offset)
 {
 	const struct bt_gatt_cpf *cpf = attr->user_data;
@@ -2311,8 +2235,7 @@ ssize_t bt_gatt_attr_read_cpf(struct bt_conn *conn,
 	value.name_space = cpf->name_space;
 	value.description = sys_cpu_to_le16(cpf->description);
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
-				 sizeof(value));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value, sizeof(value));
 }
 
 struct notify_data {
@@ -2338,8 +2261,7 @@ static int gatt_notify_mult_send(struct bt_conn *conn, struct net_buf *buf)
 	uint16_t first_attr_len = sys_get_le16(&pdu[3]);
 
 	/* Convert to ATT_HANDLE_VALUE_NTF if containing a single handle. */
-	if (buf->len ==
-	    (1 + sizeof(struct bt_att_notify_mult) + first_attr_len)) {
+	if (buf->len == (1 + sizeof(struct bt_att_notify_mult) + first_attr_len)) {
 		/* Store attr handle */
 		uint16_t handle = sys_get_le16(&pdu[1]);
 
@@ -2418,8 +2340,7 @@ static void cleanup_notify(struct bt_conn *conn)
 	}
 }
 
-static void gatt_add_nfy_to_buf(struct net_buf *buf,
-				uint16_t handle,
+static void gatt_add_nfy_to_buf(struct net_buf *buf, uint16_t handle,
 				struct bt_gatt_notify_params *params)
 {
 	struct bt_att_notify_mult *nfy;
@@ -2440,8 +2361,8 @@ static int gatt_notify_mult(struct bt_conn *conn, uint16_t handle,
 	 * the existing buffer and proceed to create a new one
 	 */
 	if (*buf && ((net_buf_tailroom(*buf) < sizeof(struct bt_att_notify_mult) + params->len) ||
-	    !bt_att_tx_meta_data_match(*buf, params->func, params->user_data,
-				       BT_ATT_CHAN_OPT(params)))) {
+		     !bt_att_tx_meta_data_match(*buf, params->func, params->user_data,
+						BT_ATT_CHAN_OPT(params)))) {
 		int ret;
 
 		ret = gatt_notify_mult_send(conn, *buf);
@@ -2473,16 +2394,14 @@ static int gatt_notify_mult(struct bt_conn *conn, uint16_t handle,
 	/* Use `k_work_schedule` to keep the original deadline, instead of
 	 * re-setting the timeout whenever a new notification is appended.
 	 */
-	k_work_schedule(&nfy_mult_work,
-			K_MSEC(CONFIG_BT_GATT_NOTIFY_MULTIPLE_FLUSH_MS));
+	k_work_schedule(&nfy_mult_work, K_MSEC(CONFIG_BT_GATT_NOTIFY_MULTIPLE_FLUSH_MS));
 
 	return 0;
 }
 #endif /* CONFIG_BT_GATT_NOTIFY_MULTIPLE_FLUSH_MS != 0 */
 #endif /* CONFIG_BT_GATT_NOTIFY_MULTIPLE */
 
-static int gatt_notify(struct bt_conn *conn, uint16_t handle,
-		       struct bt_gatt_notify_params *params)
+static int gatt_notify(struct bt_conn *conn, uint16_t handle, struct bt_gatt_notify_params *params)
 {
 	struct net_buf *buf;
 	struct bt_att_notify *nfy;
@@ -2517,8 +2436,7 @@ static int gatt_notify(struct bt_conn *conn, uint16_t handle,
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_EATT) &&
-	    !bt_att_chan_opt_valid(conn, BT_ATT_CHAN_OPT(params))) {
+	if (IS_ENABLED(CONFIG_BT_EATT) && !bt_att_chan_opt_valid(conn, BT_ATT_CHAN_OPT(params))) {
 		return -EINVAL;
 	}
 
@@ -2528,8 +2446,7 @@ static int gatt_notify(struct bt_conn *conn, uint16_t handle,
 	}
 #endif /* CONFIG_BT_GATT_NOTIFY_MULTIPLE */
 
-	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
-				sizeof(*nfy) + params->len);
+	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY, sizeof(*nfy) + params->len);
 	if (!buf) {
 		LOG_WRN("No buffer available to send notification");
 		return -ENOMEM;
@@ -2558,8 +2475,8 @@ static uint8_t att_err_from_int(int err)
 	return err;
 }
 
-static void gatt_indicate_rsp(struct bt_conn *conn, int err,
-			      const void *pdu, uint16_t length, void *user_data)
+static void gatt_indicate_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
+			      void *user_data)
 {
 	struct bt_gatt_indicate_params *params = user_data;
 
@@ -2573,10 +2490,8 @@ static void gatt_indicate_rsp(struct bt_conn *conn, int err,
 	}
 }
 
-static struct bt_att_req *gatt_req_alloc(bt_att_func_t func, void *params,
-					 bt_att_encode_t encode,
-					 uint8_t op,
-					 size_t len)
+static struct bt_att_req *gatt_req_alloc(bt_att_func_t func, void *params, bt_att_encode_t encode,
+					 uint8_t op, size_t len)
 {
 	struct bt_att_req *req;
 
@@ -2607,8 +2522,7 @@ static int gatt_req_send(struct bt_conn *conn, bt_att_func_t func, void *params,
 	struct net_buf *buf;
 	int err;
 
-	if (IS_ENABLED(CONFIG_BT_EATT) &&
-	    !bt_att_chan_opt_valid(conn, chan_opt)) {
+	if (IS_ENABLED(CONFIG_BT_EATT) && !bt_att_chan_opt_valid(conn, chan_opt)) {
 		return -EINVAL;
 	}
 
@@ -2657,8 +2571,8 @@ static int gatt_indicate(struct bt_conn *conn, uint16_t handle,
 	 * notifications and indications to such a client until it becomes
 	 * change-aware.
 	 */
-	if (!(params->func && (params->func == sc_indicate_rsp ||
-	    params->func == sc_restore_rsp)) &&
+	if (!(params->func &&
+	      (params->func == sc_indicate_rsp || params->func == sc_restore_rsp)) &&
 	    !bt_gatt_change_aware(conn, false)) {
 		return -EAGAIN;
 	}
@@ -2681,15 +2595,13 @@ static int gatt_indicate(struct bt_conn *conn, uint16_t handle,
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_EATT) &&
-	    !bt_att_chan_opt_valid(conn, BT_ATT_CHAN_OPT(params))) {
+	if (IS_ENABLED(CONFIG_BT_EATT) && !bt_att_chan_opt_valid(conn, BT_ATT_CHAN_OPT(params))) {
 		return -EINVAL;
 	}
 
 	len = sizeof(*ind) + params->len;
 
-	req = gatt_req_alloc(gatt_indicate_rsp, params, NULL,
-			     BT_ATT_OP_INDICATE, len);
+	req = gatt_req_alloc(gatt_indicate_rsp, params, NULL, BT_ATT_OP_INDICATE, len);
 	if (!req) {
 		return -ENOMEM;
 	}
@@ -2719,8 +2631,7 @@ static int gatt_indicate(struct bt_conn *conn, uint16_t handle,
 	return err;
 }
 
-static uint8_t notify_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			 void *user_data)
+static uint8_t notify_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct notify_data *data = user_data;
 	struct _bt_gatt_ccc *ccc;
@@ -2742,14 +2653,12 @@ static uint8_t notify_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 				continue;
 			}
 
-			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
-						       BT_CONN_CONNECTED);
+			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer, BT_CONN_CONNECTED);
 			if (!conn) {
 				struct sc_data *sc;
 
 				sc = (struct sc_data *)data->ind_params->data;
-				sc_save(cfg->id, &cfg->peer,
-					sys_le16_to_cpu(sc->start),
+				sc_save(cfg->id, &cfg->peer, sys_le16_to_cpu(sc->start),
 					sys_le16_to_cpu(sc->end));
 				continue;
 			}
@@ -2800,8 +2709,7 @@ static uint8_t notify_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 		 * the Characteristic Value.
 		 * Only notify or indicate devices which are subscribed.
 		 */
-		if ((data->type == BT_GATT_CCC_INDICATE) &&
-		    (cfg->value & BT_GATT_CCC_INDICATE)) {
+		if ((data->type == BT_GATT_CCC_INDICATE) && (cfg->value & BT_GATT_CCC_INDICATE)) {
 			err = gatt_indicate(conn, data->handle, data->ind_params);
 			if (err == 0) {
 				data->ind_params->_ref++;
@@ -2825,8 +2733,7 @@ static uint8_t notify_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	return BT_GATT_ITER_CONTINUE;
 }
 
-static uint8_t match_uuid(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t match_uuid(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct notify_data *data = user_data;
 
@@ -2836,34 +2743,28 @@ static uint8_t match_uuid(const struct bt_gatt_attr *attr, uint16_t handle,
 	return BT_GATT_ITER_STOP;
 }
 
-static bool gatt_find_by_uuid(struct notify_data *found,
-			      const struct bt_uuid *uuid)
+static bool gatt_find_by_uuid(struct notify_data *found, const struct bt_uuid *uuid)
 {
 	found->attr = NULL;
 
-	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
-				  match_uuid, found);
+	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1, match_uuid, found);
 
 	return found->attr ? true : false;
 }
 
-struct bt_gatt_attr *bt_gatt_find_by_uuid(const struct bt_gatt_attr *attr,
-					  uint16_t attr_count,
+struct bt_gatt_attr *bt_gatt_find_by_uuid(const struct bt_gatt_attr *attr, uint16_t attr_count,
 					  const struct bt_uuid *uuid)
 {
 	struct bt_gatt_attr *found = NULL;
 	uint16_t start_handle = bt_gatt_attr_value_handle(attr);
-	uint16_t end_handle = start_handle && attr_count ?
-			      start_handle + attr_count : 0xffff;
+	uint16_t end_handle = start_handle && attr_count ? start_handle + attr_count : 0xffff;
 
-	bt_gatt_foreach_attr_type(start_handle, end_handle, uuid, NULL, 1,
-				  find_next, &found);
+	bt_gatt_foreach_attr_type(start_handle, end_handle, uuid, NULL, 1, find_next, &found);
 
 	return found;
 }
 
-int bt_gatt_notify_cb(struct bt_conn *conn,
-		      struct bt_gatt_notify_params *params)
+int bt_gatt_notify_cb(struct bt_conn *conn, struct bt_gatt_notify_params *params)
 {
 	struct notify_data data;
 
@@ -2913,8 +2814,7 @@ int bt_gatt_notify_cb(struct bt_conn *conn,
 	data.type = BT_GATT_CCC_NOTIFY;
 	data.nfy_params = params;
 
-	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
-				  1, notify_cb, &data);
+	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1, notify_cb, &data);
 
 	return data.err;
 }
@@ -2971,8 +2871,8 @@ static int gatt_notify_multiple_verify_args(struct bt_conn *conn,
 }
 
 static int gatt_notify_multiple_verify_params(struct bt_conn *conn,
-					     struct bt_gatt_notify_params params[],
-					     uint16_t num_params, size_t *total_len)
+					      struct bt_gatt_notify_params params[],
+					      uint16_t num_params, size_t *total_len)
 {
 	for (uint16_t i = 0; i < num_params; i++) {
 		/* Compute the total data length. */
@@ -2980,8 +2880,7 @@ static int gatt_notify_multiple_verify_params(struct bt_conn *conn,
 
 		/* Confirm that the connection has the correct level of security. */
 		if (bt_gatt_check_perm(conn, params[i].attr,
-				       BT_GATT_PERM_READ_ENCRYPT |
-				       BT_GATT_PERM_READ_AUTHEN)) {
+				       BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_READ_AUTHEN)) {
 			LOG_WRN("Link is not encrypted");
 			return -EPERM;
 		}
@@ -3006,8 +2905,7 @@ static int gatt_notify_multiple_verify_params(struct bt_conn *conn,
 
 		/* Check if the characteristic is subscribed. */
 		if (IS_ENABLED(CONFIG_BT_GATT_ENFORCE_SUBSCRIPTION) &&
-		    !bt_gatt_is_subscribed(conn, params[i].attr,
-					   BT_GATT_CCC_NOTIFY)) {
+		    !bt_gatt_is_subscribed(conn, params[i].attr, BT_GATT_CCC_NOTIFY)) {
 			LOG_WRN("Device is not subscribed to characteristic");
 			return -EINVAL;
 		}
@@ -3019,16 +2917,14 @@ static int gatt_notify_multiple_verify_params(struct bt_conn *conn,
 	}
 
 	/* Check there is a bearer with a high enough MTU. */
-	if (bt_att_get_mtu(conn) <
-	    (sizeof(struct bt_att_notify_mult) + *total_len)) {
+	if (bt_att_get_mtu(conn) < (sizeof(struct bt_att_notify_mult) + *total_len)) {
 		return -ERANGE;
 	}
 
 	return 0;
 }
 
-int bt_gatt_notify_multiple(struct bt_conn *conn,
-			    uint16_t num_params,
+int bt_gatt_notify_multiple(struct bt_conn *conn, uint16_t num_params,
 			    struct bt_gatt_notify_params params[])
 {
 	int err;
@@ -3087,8 +2983,7 @@ int bt_gatt_notify_multiple(struct bt_conn *conn,
 }
 #endif /* CONFIG_BT_GATT_NOTIFY_MULTIPLE */
 
-int bt_gatt_indicate(struct bt_conn *conn,
-		     struct bt_gatt_indicate_params *params)
+int bt_gatt_indicate(struct bt_conn *conn, struct bt_gatt_indicate_params *params)
 {
 	struct notify_data data;
 
@@ -3140,8 +3035,7 @@ int bt_gatt_indicate(struct bt_conn *conn,
 	data.ind_params = params;
 
 	params->_ref = 0;
-	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
-				  1, notify_cb, &data);
+	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1, notify_cb, &data);
 
 	return data.err;
 }
@@ -3156,11 +3050,9 @@ uint16_t bt_gatt_get_uatt_mtu(struct bt_conn *conn)
 	return bt_att_get_uatt_mtu(conn);
 }
 
-uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			uint16_t mask)
+uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr *attr, uint16_t mask)
 {
-	if ((mask & BT_GATT_PERM_READ) &&
-	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
+	if ((mask & BT_GATT_PERM_READ) && (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
 		return BT_ATT_ERR_READ_NOT_PERMITTED;
 	}
 
@@ -3223,8 +3115,8 @@ uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr *attr
 	return 0;
 }
 
-static void sc_restore_rsp(struct bt_conn *conn,
-			   struct bt_gatt_indicate_params *params, uint8_t err)
+static void sc_restore_rsp(struct bt_conn *conn, struct bt_gatt_indicate_params *params,
+			   uint8_t err)
 {
 #if defined(CONFIG_BT_GATT_CACHING)
 	struct gatt_cf_cfg *cfg;
@@ -3299,8 +3191,7 @@ struct conn_data {
 	bt_security_t sec;
 };
 
-static uint8_t update_ccc(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t update_ccc(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct conn_data *data = user_data;
 	struct bt_conn *conn = data->conn;
@@ -3318,8 +3209,7 @@ static uint8_t update_ccc(const struct bt_gatt_attr *attr, uint16_t handle,
 		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
 
 		/* Ignore configuration for different peer or not active */
-		if (!cfg->value ||
-		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
+		if (!cfg->value || !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
 			continue;
 		}
 
@@ -3340,8 +3230,7 @@ static uint8_t update_ccc(const struct bt_gatt_attr *attr, uint16_t handle,
 			}
 
 			/* Check if current security is enough */
-			if (IS_ENABLED(CONFIG_BT_SMP) &&
-			    bt_conn_get_security(conn) < sec) {
+			if (IS_ENABLED(CONFIG_BT_SMP) && bt_conn_get_security(conn) < sec) {
 				if (data->sec < sec) {
 					data->sec = sec;
 				}
@@ -3351,8 +3240,7 @@ static uint8_t update_ccc(const struct bt_gatt_attr *attr, uint16_t handle,
 
 		gatt_ccc_changed(attr, ccc);
 
-		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
-		    ccc == &sc_ccc) {
+		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
 			sc_restore(conn);
 		}
 
@@ -3362,8 +3250,7 @@ static uint8_t update_ccc(const struct bt_gatt_attr *attr, uint16_t handle,
 	return BT_GATT_ITER_CONTINUE;
 }
 
-static uint8_t disconnected_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-			       void *user_data)
+static uint8_t disconnected_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct bt_conn *conn = user_data;
 	struct _bt_gatt_ccc *ccc;
@@ -3432,8 +3319,7 @@ static uint8_t disconnected_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	return BT_GATT_ITER_CONTINUE;
 }
 
-bool bt_gatt_is_subscribed(struct bt_conn *conn,
-			   const struct bt_gatt_attr *attr, uint16_t ccc_type)
+bool bt_gatt_is_subscribed(struct bt_conn *conn, const struct bt_gatt_attr *attr, uint16_t ccc_type)
 {
 	uint16_t ccc_bits;
 	uint8_t ccc_bits_encoded[sizeof(ccc_bits)];
@@ -3532,8 +3418,7 @@ static void gatt_sub_free(struct gatt_sub *sub)
 	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
 }
 
-static void gatt_sub_remove(struct bt_conn *conn, struct gatt_sub *sub,
-			    sys_snode_t *prev,
+static void gatt_sub_remove(struct bt_conn *conn, struct gatt_sub *sub, sys_snode_t *prev,
 			    struct bt_gatt_subscribe_params *params)
 {
 	if (params) {
@@ -3582,8 +3467,7 @@ static struct gatt_sub *gatt_sub_add(struct bt_conn *conn)
 	return sub;
 }
 
-static struct gatt_sub *gatt_sub_find_by_addr(uint8_t id,
-					      const bt_addr_le_t *addr)
+static struct gatt_sub *gatt_sub_find_by_addr(uint8_t id, const bt_addr_le_t *addr)
 {
 	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
 		struct gatt_sub *sub = &subscriptions[i];
@@ -3596,8 +3480,7 @@ static struct gatt_sub *gatt_sub_find_by_addr(uint8_t id,
 	return NULL;
 }
 
-static struct gatt_sub *gatt_sub_add_by_addr(uint8_t id,
-					     const bt_addr_le_t *addr)
+static struct gatt_sub *gatt_sub_add_by_addr(uint8_t id, const bt_addr_le_t *addr)
 {
 	struct gatt_sub *sub;
 
@@ -3644,8 +3527,7 @@ static void call_notify_cb_and_maybe_unsubscribe(struct bt_conn *conn, struct ga
 	}
 }
 
-void bt_gatt_notification(struct bt_conn *conn, uint16_t handle,
-			  const void *data, uint16_t length)
+void bt_gatt_notification(struct bt_conn *conn, uint16_t handle, const void *data, uint16_t length)
 {
 	struct gatt_sub *sub;
 
@@ -3659,8 +3541,7 @@ void bt_gatt_notification(struct bt_conn *conn, uint16_t handle,
 	call_notify_cb_and_maybe_unsubscribe(conn, sub, handle, data, length);
 }
 
-void bt_gatt_mult_notification(struct bt_conn *conn, const void *data,
-			       uint16_t length)
+void bt_gatt_mult_notification(struct bt_conn *conn, const void *data, uint16_t length)
 {
 	const struct bt_att_notify_mult *nfy;
 	struct net_buf_simple buf;
@@ -3723,8 +3604,7 @@ static void remove_subscriptions(struct bt_conn *conn)
 		atomic_clear_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_SENT);
 
 		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
-		    (atomic_test_bit(params->flags,
-				     BT_GATT_SUBSCRIBE_FLAG_VOLATILE))) {
+		    (atomic_test_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_VOLATILE))) {
 			/* Remove subscription */
 			params->value = 0U;
 			gatt_sub_remove(conn, sub, prev, params);
@@ -3735,16 +3615,15 @@ static void remove_subscriptions(struct bt_conn *conn)
 	}
 }
 
-static void gatt_mtu_rsp(struct bt_conn *conn, int err, const void *pdu,
-			 uint16_t length, void *user_data)
+static void gatt_mtu_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
+			 void *user_data)
 {
 	struct bt_gatt_exchange_params *params = user_data;
 
 	params->func(conn, att_err_from_int(err), params);
 }
 
-static int gatt_exchange_mtu_encode(struct net_buf *buf, size_t len,
-				    void *user_data)
+static int gatt_exchange_mtu_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_att_exchange_mtu_req *req;
 	uint16_t mtu;
@@ -3759,8 +3638,7 @@ static int gatt_exchange_mtu_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-int bt_gatt_exchange_mtu(struct bt_conn *conn,
-			 struct bt_gatt_exchange_params *params)
+int bt_gatt_exchange_mtu(struct bt_conn *conn, struct bt_gatt_exchange_params *params)
 {
 	int err;
 
@@ -3776,8 +3654,7 @@ int bt_gatt_exchange_mtu(struct bt_conn *conn,
 		return -EALREADY;
 	}
 
-	err = gatt_req_send(conn, gatt_mtu_rsp, params,
-			    gatt_exchange_mtu_encode, BT_ATT_OP_MTU_REQ,
+	err = gatt_req_send(conn, gatt_mtu_rsp, params, gatt_exchange_mtu_encode, BT_ATT_OP_MTU_REQ,
 			    sizeof(struct bt_att_exchange_mtu_req),
 			    BT_ATT_CHAN_OPT_UNENHANCED_ONLY);
 	if (err) {
@@ -3818,8 +3695,7 @@ done:
 	params->func(conn, NULL, params);
 }
 
-static void gatt_find_type_rsp(struct bt_conn *conn, int err,
-			       const void *pdu, uint16_t length,
+static void gatt_find_type_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 			       void *user_data)
 {
 	const struct bt_att_handle_group *rsp = pdu;
@@ -3856,7 +3732,7 @@ static void gatt_find_type_rsp(struct bt_conn *conn, int err,
 		value.end_handle = end_handle;
 		value.uuid = params->uuid;
 
-		attr = (struct bt_gatt_attr) {
+		attr = (struct bt_gatt_attr){
 			.uuid = &uuid_svc.uuid,
 			.user_data = &value,
 			.handle = start_handle,
@@ -3874,8 +3750,7 @@ done:
 	params->func(conn, NULL, params);
 }
 
-static int gatt_find_type_encode(struct net_buf *buf, size_t len,
-				 void *user_data)
+static int gatt_find_type_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
 	struct bt_att_find_type_req *req;
@@ -3908,8 +3783,7 @@ static int gatt_find_type_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_find_type(struct bt_conn *conn,
-			  struct bt_gatt_discover_params *params)
+static int gatt_find_type(struct bt_conn *conn, struct bt_gatt_discover_params *params)
 {
 	size_t len;
 
@@ -3927,13 +3801,11 @@ static int gatt_find_type(struct bt_conn *conn,
 		return -EINVAL;
 	}
 
-	return gatt_req_send(conn, gatt_find_type_rsp, params,
-			     gatt_find_type_encode, BT_ATT_OP_FIND_TYPE_REQ,
-			     len, BT_ATT_CHAN_OPT(params));
+	return gatt_req_send(conn, gatt_find_type_rsp, params, gatt_find_type_encode,
+			     BT_ATT_OP_FIND_TYPE_REQ, len, BT_ATT_CHAN_OPT(params));
 }
 
-static void read_included_uuid_cb(struct bt_conn *conn, int err,
-				  const void *pdu, uint16_t length,
+static void read_included_uuid_cb(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 				  void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
@@ -3959,15 +3831,16 @@ static void read_included_uuid_cb(struct bt_conn *conn, int err,
 	memcpy(u.u128.val, pdu, length);
 
 	LOG_DBG("handle 0x%04x uuid %s start_handle 0x%04x "
-	       "end_handle 0x%04x\n", params->_included.attr_handle,
-	       bt_uuid_str(&u.uuid), value.start_handle, value.end_handle);
+		"end_handle 0x%04x\n",
+		params->_included.attr_handle, bt_uuid_str(&u.uuid), value.start_handle,
+		value.end_handle);
 
 	/* Skip if UUID is set but doesn't match */
 	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
 		goto next;
 	}
 
-	attr = (struct bt_gatt_attr) {
+	attr = (struct bt_gatt_attr){
 		.uuid = BT_UUID_GATT_INCLUDE,
 		.user_data = &value,
 		.handle = handle,
@@ -3982,8 +3855,7 @@ next:
 	return;
 }
 
-static int read_included_uuid_encode(struct net_buf *buf, size_t len,
-				     void *user_data)
+static int read_included_uuid_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
 	struct bt_att_read_req *req;
@@ -3994,19 +3866,17 @@ static int read_included_uuid_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int read_included_uuid(struct bt_conn *conn,
-			      struct bt_gatt_discover_params *params)
+static int read_included_uuid(struct bt_conn *conn, struct bt_gatt_discover_params *params)
 {
 	LOG_DBG("handle 0x%04x", params->_included.start_handle);
 
-	return gatt_req_send(conn, read_included_uuid_cb, params,
-			     read_included_uuid_encode, BT_ATT_OP_READ_REQ,
-			     sizeof(struct bt_att_read_req), BT_ATT_CHAN_OPT(params));
+	return gatt_req_send(conn, read_included_uuid_cb, params, read_included_uuid_encode,
+			     BT_ATT_OP_READ_REQ, sizeof(struct bt_att_read_req),
+			     BT_ATT_CHAN_OPT(params));
 }
 
 static uint16_t parse_include(struct bt_conn *conn, const void *pdu,
-			   struct bt_gatt_discover_params *params,
-			   uint16_t length)
+			      struct bt_gatt_discover_params *params, uint16_t length)
 {
 	const struct bt_att_read_type_rsp *rsp;
 	uint16_t handle = 0U;
@@ -4075,15 +3945,15 @@ static uint16_t parse_include(struct bt_conn *conn, const void *pdu,
 		}
 
 		LOG_DBG("handle 0x%04x uuid %s start_handle 0x%04x "
-		       "end_handle 0x%04x\n", handle, bt_uuid_str(&u.uuid),
-		       value.start_handle, value.end_handle);
+			"end_handle 0x%04x\n",
+			handle, bt_uuid_str(&u.uuid), value.start_handle, value.end_handle);
 
 		/* Skip if UUID is set but doesn't match */
 		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
 			continue;
 		}
 
-		attr = (struct bt_gatt_attr) {
+		attr = (struct bt_gatt_attr){
 			.uuid = BT_UUID_GATT_INCLUDE,
 			.user_data = &value,
 			.handle = handle,
@@ -4105,8 +3975,7 @@ done:
 }
 
 static uint16_t parse_characteristic(struct bt_conn *conn, const void *pdu,
-				  struct bt_gatt_discover_params *params,
-				  uint16_t length)
+				     struct bt_gatt_discover_params *params, uint16_t length)
 {
 	const struct bt_att_read_type_rsp *rsp;
 	uint16_t handle = 0U;
@@ -4168,10 +4037,9 @@ static uint16_t parse_characteristic(struct bt_conn *conn, const void *pdu,
 		}
 
 		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
-			&u.uuid, sys_le16_to_cpu(chrc->value_handle),
-			chrc->properties);
+			&u.uuid, sys_le16_to_cpu(chrc->value_handle), chrc->properties);
 
-		attr = (struct bt_gatt_attr) {
+		attr = (struct bt_gatt_attr){
 			.uuid = BT_UUID_GATT_CHRC,
 			.user_data = &value,
 			.handle = handle,
@@ -4193,8 +4061,7 @@ done:
 }
 
 static uint16_t parse_read_std_char_desc(struct bt_conn *conn, const void *pdu,
-					 struct bt_gatt_discover_params *params,
-					 uint16_t length)
+					 struct bt_gatt_discover_params *params, uint16_t length)
 {
 	const struct bt_att_read_type_rsp *rsp;
 	uint16_t handle = 0U;
@@ -4263,8 +4130,7 @@ static uint16_t parse_read_std_char_desc(struct bt_conn *conn, const void *pdu,
 
 			value.scc.flags = sys_get_le16(data->value);
 			break;
-		case BT_UUID_GATT_CPF_VAL:
-		{
+		case BT_UUID_GATT_CPF_VAL: {
 			struct gatt_cpf *cpf;
 
 			if (length < sizeof(*data) + sizeof(*cpf)) {
@@ -4285,7 +4151,7 @@ static uint16_t parse_read_std_char_desc(struct bt_conn *conn, const void *pdu,
 			goto done;
 		}
 
-		attr = (struct bt_gatt_attr) {
+		attr = (struct bt_gatt_attr){
 			.uuid = params->uuid,
 			.user_data = &value,
 			.handle = handle,
@@ -4306,8 +4172,7 @@ done:
 	return 0;
 }
 
-static void gatt_read_type_rsp(struct bt_conn *conn, int err,
-			       const void *pdu, uint16_t length,
+static void gatt_read_type_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 			       void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
@@ -4335,8 +4200,7 @@ static void gatt_read_type_rsp(struct bt_conn *conn, int err,
 	gatt_discover_next(conn, handle, params);
 }
 
-static int gatt_read_type_encode(struct net_buf *buf, size_t len,
-				 void *user_data)
+static int gatt_read_type_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
 	struct bt_att_read_type_req *req;
@@ -4361,19 +4225,17 @@ static int gatt_read_type_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_read_type(struct bt_conn *conn,
-			  struct bt_gatt_discover_params *params)
+static int gatt_read_type(struct bt_conn *conn, struct bt_gatt_discover_params *params)
 {
 	LOG_DBG("start_handle 0x%04x end_handle 0x%04x", params->start_handle, params->end_handle);
 
-	return gatt_req_send(conn, gatt_read_type_rsp, params,
-			     gatt_read_type_encode, BT_ATT_OP_READ_TYPE_REQ,
-			     sizeof(struct bt_att_read_type_req), BT_ATT_CHAN_OPT(params));
+	return gatt_req_send(conn, gatt_read_type_rsp, params, gatt_read_type_encode,
+			     BT_ATT_OP_READ_TYPE_REQ, sizeof(struct bt_att_read_type_req),
+			     BT_ATT_CHAN_OPT(params));
 }
 
 static uint16_t parse_service(struct bt_conn *conn, const void *pdu,
-				  struct bt_gatt_discover_params *params,
-				  uint16_t length)
+			      struct bt_gatt_discover_params *params, uint16_t length)
 {
 	const struct bt_att_read_group_rsp *rsp;
 	uint16_t start_handle, end_handle = 0U;
@@ -4463,8 +4325,7 @@ done:
 	return 0;
 }
 
-static void gatt_read_group_rsp(struct bt_conn *conn, int err,
-				const void *pdu, uint16_t length,
+static void gatt_read_group_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 				void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
@@ -4485,8 +4346,7 @@ static void gatt_read_group_rsp(struct bt_conn *conn, int err,
 	gatt_discover_next(conn, handle, params);
 }
 
-static int gatt_read_group_encode(struct net_buf *buf, size_t len,
-				  void *user_data)
+static int gatt_read_group_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
 	struct bt_att_read_group_req *req;
@@ -4504,20 +4364,16 @@ static int gatt_read_group_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_read_group(struct bt_conn *conn,
-			   struct bt_gatt_discover_params *params)
+static int gatt_read_group(struct bt_conn *conn, struct bt_gatt_discover_params *params)
 {
 	LOG_DBG("start_handle 0x%04x end_handle 0x%04x", params->start_handle, params->end_handle);
 
-	return gatt_req_send(conn, gatt_read_group_rsp, params,
-			     gatt_read_group_encode,
-			     BT_ATT_OP_READ_GROUP_REQ,
-			     sizeof(struct bt_att_read_group_req),
+	return gatt_req_send(conn, gatt_read_group_rsp, params, gatt_read_group_encode,
+			     BT_ATT_OP_READ_GROUP_REQ, sizeof(struct bt_att_read_group_req),
 			     BT_ATT_CHAN_OPT(params));
 }
 
-static void gatt_find_info_rsp(struct bt_conn *conn, int err,
-			       const void *pdu, uint16_t length,
+static void gatt_find_info_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 			       void *user_data)
 {
 	const struct bt_att_find_info_rsp *rsp;
@@ -4572,8 +4428,7 @@ static void gatt_find_info_rsp(struct bt_conn *conn, int err,
 	}
 
 	/* Parse descriptors found */
-	for (i = length / len, pdu = rsp->info; i != 0;
-	     i--, pdu = (const uint8_t *)pdu + len) {
+	for (i = length / len, pdu = rsp->info; i != 0; i--, pdu = (const uint8_t *)pdu + len) {
 		struct bt_gatt_attr attr;
 
 		info.i16 = pdu;
@@ -4620,7 +4475,7 @@ static void gatt_find_info_rsp(struct bt_conn *conn, int err,
 		}
 
 		/* No user_data in this case */
-		attr = (struct bt_gatt_attr) {
+		attr = (struct bt_gatt_attr){
 			.uuid = &u.uuid,
 			.handle = handle,
 		};
@@ -4638,8 +4493,7 @@ done:
 	params->func(conn, NULL, params);
 }
 
-static int gatt_find_info_encode(struct net_buf *buf, size_t len,
-				 void *user_data)
+static int gatt_find_info_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_discover_params *params = user_data;
 	struct bt_att_find_info_req *req;
@@ -4651,26 +4505,21 @@ static int gatt_find_info_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_find_info(struct bt_conn *conn,
-			  struct bt_gatt_discover_params *params)
+static int gatt_find_info(struct bt_conn *conn, struct bt_gatt_discover_params *params)
 {
 	LOG_DBG("start_handle 0x%04x end_handle 0x%04x", params->start_handle, params->end_handle);
 
-	return gatt_req_send(conn, gatt_find_info_rsp, params,
-			     gatt_find_info_encode, BT_ATT_OP_FIND_INFO_REQ,
-			     sizeof(struct bt_att_find_info_req),
+	return gatt_req_send(conn, gatt_find_info_rsp, params, gatt_find_info_encode,
+			     BT_ATT_OP_FIND_INFO_REQ, sizeof(struct bt_att_find_info_req),
 			     BT_ATT_CHAN_OPT(params));
 }
 
-int bt_gatt_discover(struct bt_conn *conn,
-		     struct bt_gatt_discover_params *params)
+int bt_gatt_discover(struct bt_conn *conn, struct bt_gatt_discover_params *params)
 {
 	__ASSERT(conn, "invalid parameters\n");
 	__ASSERT(params && params->func, "invalid parameters\n");
-	__ASSERT((params->start_handle && params->end_handle),
-		 "invalid parameters\n");
-	__ASSERT((params->start_handle <= params->end_handle),
-		 "invalid parameters\n");
+	__ASSERT((params->start_handle && params->end_handle), "invalid parameters\n");
+	__ASSERT((params->start_handle <= params->end_handle), "invalid parameters\n");
 
 	if (conn->state != BT_CONN_CONNECTED) {
 		return -ENOTCONN;
@@ -4698,11 +4547,10 @@ int bt_gatt_discover(struct bt_conn *conn,
 		return gatt_read_type(conn, params);
 	case BT_GATT_DISCOVER_DESCRIPTOR:
 		/* Only descriptors can be filtered */
-		if (params->uuid &&
-		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
-		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
-		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
-		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
+		if (params->uuid && (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
+				     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
+				     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
+				     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
 			return -EINVAL;
 		}
 		__fallthrough;
@@ -4715,8 +4563,7 @@ int bt_gatt_discover(struct bt_conn *conn,
 	return -EINVAL;
 }
 
-static void parse_read_by_uuid(struct bt_conn *conn,
-			       struct bt_gatt_read_params *params,
+static void parse_read_by_uuid(struct bt_conn *conn, struct bt_gatt_read_params *params,
 			       const void *pdu, uint16_t length)
 {
 	const struct bt_att_read_type_rsp *rsp = pdu;
@@ -4755,8 +4602,7 @@ static void parse_read_by_uuid(struct bt_conn *conn,
 		/* Update start_handle */
 		params->by_uuid.start_handle = handle;
 
-		if (params->func(conn, 0, params, data->value, len) ==
-		    BT_GATT_ITER_STOP) {
+		if (params->func(conn, 0, params, data->value, len) == BT_GATT_ITER_STOP) {
 			return;
 		}
 
@@ -4780,8 +4626,8 @@ static void parse_read_by_uuid(struct bt_conn *conn,
 	}
 }
 
-static void gatt_read_rsp(struct bt_conn *conn, int err, const void *pdu,
-			  uint16_t length, void *user_data)
+static void gatt_read_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
+			  void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
 
@@ -4823,8 +4669,7 @@ static void gatt_read_rsp(struct bt_conn *conn, int err, const void *pdu,
 	}
 }
 
-static int gatt_read_blob_encode(struct net_buf *buf, size_t len,
-				 void *user_data)
+static int gatt_read_blob_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
 	struct bt_att_read_blob_req *req;
@@ -4836,19 +4681,16 @@ static int gatt_read_blob_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_read_blob(struct bt_conn *conn,
-			  struct bt_gatt_read_params *params)
+static int gatt_read_blob(struct bt_conn *conn, struct bt_gatt_read_params *params)
 {
 	LOG_DBG("handle 0x%04x offset 0x%04x", params->single.handle, params->single.offset);
 
-	return gatt_req_send(conn, gatt_read_rsp, params,
-			     gatt_read_blob_encode, BT_ATT_OP_READ_BLOB_REQ,
-			     sizeof(struct bt_att_read_blob_req),
+	return gatt_req_send(conn, gatt_read_rsp, params, gatt_read_blob_encode,
+			     BT_ATT_OP_READ_BLOB_REQ, sizeof(struct bt_att_read_blob_req),
 			     BT_ATT_CHAN_OPT(params));
 }
 
-static int gatt_read_uuid_encode(struct net_buf *buf, size_t len,
-				 void *user_data)
+static int gatt_read_uuid_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
 	struct bt_att_read_type_req *req;
@@ -4866,21 +4708,19 @@ static int gatt_read_uuid_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_read_uuid(struct bt_conn *conn,
-			  struct bt_gatt_read_params *params)
+static int gatt_read_uuid(struct bt_conn *conn, struct bt_gatt_read_params *params)
 {
 	LOG_DBG("start_handle 0x%04x end_handle 0x%04x uuid %s", params->by_uuid.start_handle,
 		params->by_uuid.end_handle, bt_uuid_str(params->by_uuid.uuid));
 
-	return gatt_req_send(conn, gatt_read_rsp, params,
-			     gatt_read_uuid_encode, BT_ATT_OP_READ_TYPE_REQ,
-			     sizeof(struct bt_att_read_type_req),
+	return gatt_req_send(conn, gatt_read_rsp, params, gatt_read_uuid_encode,
+			     BT_ATT_OP_READ_TYPE_REQ, sizeof(struct bt_att_read_type_req),
 			     BT_ATT_CHAN_OPT(params));
 }
 
 #if defined(CONFIG_BT_GATT_READ_MULTIPLE)
-static void gatt_read_mult_rsp(struct bt_conn *conn, int err, const void *pdu,
-			       uint16_t length, void *user_data)
+static void gatt_read_mult_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
+			       void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
 
@@ -4897,8 +4737,7 @@ static void gatt_read_mult_rsp(struct bt_conn *conn, int err, const void *pdu,
 	params->func(conn, 0, params, NULL, 0);
 }
 
-static int gatt_read_mult_encode(struct net_buf *buf, size_t len,
-				 void *user_data)
+static int gatt_read_mult_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
 	uint8_t i;
@@ -4910,28 +4749,24 @@ static int gatt_read_mult_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_read_mult(struct bt_conn *conn,
-			  struct bt_gatt_read_params *params)
+static int gatt_read_mult(struct bt_conn *conn, struct bt_gatt_read_params *params)
 {
 	LOG_DBG("handle_count %zu", params->handle_count);
 
-	return gatt_req_send(conn, gatt_read_mult_rsp, params,
-			     gatt_read_mult_encode, BT_ATT_OP_READ_MULT_REQ,
-			     params->handle_count * sizeof(uint16_t),
+	return gatt_req_send(conn, gatt_read_mult_rsp, params, gatt_read_mult_encode,
+			     BT_ATT_OP_READ_MULT_REQ, params->handle_count * sizeof(uint16_t),
 			     BT_ATT_CHAN_OPT(params));
 }
 
 #else
-static int gatt_read_mult(struct bt_conn *conn,
-			      struct bt_gatt_read_params *params)
+static int gatt_read_mult(struct bt_conn *conn, struct bt_gatt_read_params *params)
 {
 	return -ENOTSUP;
 }
 #endif /* CONFIG_BT_GATT_READ_MULTIPLE */
 
 #if defined(CONFIG_BT_GATT_READ_MULT_VAR_LEN)
-static void gatt_read_mult_vl_rsp(struct bt_conn *conn, int err,
-				  const void *pdu, uint16_t length,
+static void gatt_read_mult_vl_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 				  void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
@@ -4970,8 +4805,7 @@ static void gatt_read_mult_vl_rsp(struct bt_conn *conn, int err,
 	params->func(conn, 0, params, NULL, 0);
 }
 
-static int gatt_read_mult_vl_encode(struct net_buf *buf, size_t len,
-				    void *user_data)
+static int gatt_read_mult_vl_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_read_params *params = user_data;
 	uint8_t i;
@@ -4983,21 +4817,17 @@ static int gatt_read_mult_vl_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_read_mult_vl(struct bt_conn *conn,
-			     struct bt_gatt_read_params *params)
+static int gatt_read_mult_vl(struct bt_conn *conn, struct bt_gatt_read_params *params)
 {
 	LOG_DBG("handle_count %zu", params->handle_count);
 
-	return gatt_req_send(conn, gatt_read_mult_vl_rsp, params,
-			     gatt_read_mult_vl_encode,
-			     BT_ATT_OP_READ_MULT_VL_REQ,
-			     params->handle_count * sizeof(uint16_t),
+	return gatt_req_send(conn, gatt_read_mult_vl_rsp, params, gatt_read_mult_vl_encode,
+			     BT_ATT_OP_READ_MULT_VL_REQ, params->handle_count * sizeof(uint16_t),
 			     BT_ATT_CHAN_OPT(params));
 }
 
 #else
-static int gatt_read_mult_vl(struct bt_conn *conn,
-			     struct bt_gatt_read_params *params)
+static int gatt_read_mult_vl(struct bt_conn *conn, struct bt_gatt_read_params *params)
 {
 	return -ENOTSUP;
 }
@@ -5041,13 +4871,12 @@ int bt_gatt_read(struct bt_conn *conn, struct bt_gatt_read_params *params)
 
 	LOG_DBG("handle 0x%04x", params->single.handle);
 
-	return gatt_req_send(conn, gatt_read_rsp, params, gatt_read_encode,
-			     BT_ATT_OP_READ_REQ, sizeof(struct bt_att_read_req),
-			     BT_ATT_CHAN_OPT(params));
+	return gatt_req_send(conn, gatt_read_rsp, params, gatt_read_encode, BT_ATT_OP_READ_REQ,
+			     sizeof(struct bt_att_read_req), BT_ATT_CHAN_OPT(params));
 }
 
-static void gatt_write_rsp(struct bt_conn *conn, int err, const void *pdu,
-			   uint16_t length, void *user_data)
+static void gatt_write_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
+			   void *user_data)
 {
 	struct bt_gatt_write_params *params = user_data;
 
@@ -5056,9 +4885,8 @@ static void gatt_write_rsp(struct bt_conn *conn, int err, const void *pdu,
 	params->func(conn, att_err_from_int(err), params);
 }
 
-int bt_gatt_write_without_response_cb(struct bt_conn *conn, uint16_t handle,
-				      const void *data, uint16_t length, bool sign,
-				      bt_gatt_complete_func_t func,
+int bt_gatt_write_without_response_cb(struct bt_conn *conn, uint16_t handle, const void *data,
+				      uint16_t length, bool sign, bt_gatt_complete_func_t func,
 				      void *user_data)
 {
 	struct net_buf *buf;
@@ -5083,8 +4911,7 @@ int bt_gatt_write_without_response_cb(struct bt_conn *conn, uint16_t handle,
 		buf = bt_att_create_pdu(conn, BT_ATT_OP_SIGNED_WRITE_CMD,
 					sizeof(*cmd) + length + 12);
 	} else {
-		buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_CMD,
-					sizeof(*cmd) + length);
+		buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_CMD, sizeof(*cmd) + length);
 	}
 	if (!buf) {
 		return -ENOMEM;
@@ -5117,14 +4944,12 @@ static int gatt_exec_encode(struct net_buf *buf, size_t len, void *user_data)
 	return 0;
 }
 
-static int gatt_exec_write(struct bt_conn *conn,
-			   struct bt_gatt_write_params *params)
+static int gatt_exec_write(struct bt_conn *conn, struct bt_gatt_write_params *params)
 {
 	LOG_DBG("");
 
 	return gatt_req_send(conn, gatt_write_rsp, params, gatt_exec_encode,
-			     BT_ATT_OP_EXEC_WRITE_REQ,
-			     sizeof(struct bt_att_exec_write_req),
+			     BT_ATT_OP_EXEC_WRITE_REQ, sizeof(struct bt_att_exec_write_req),
 			     BT_ATT_CHAN_OPT(params));
 }
 
@@ -5138,19 +4963,16 @@ static int gatt_cancel_encode(struct net_buf *buf, size_t len, void *user_data)
 	return 0;
 }
 
-static int gatt_cancel_all_writes(struct bt_conn *conn,
-			   struct bt_gatt_write_params *params)
+static int gatt_cancel_all_writes(struct bt_conn *conn, struct bt_gatt_write_params *params)
 {
 	LOG_DBG("");
 
 	return gatt_req_send(conn, gatt_write_rsp, params, gatt_cancel_encode,
-			     BT_ATT_OP_EXEC_WRITE_REQ,
-			     sizeof(struct bt_att_exec_write_req),
+			     BT_ATT_OP_EXEC_WRITE_REQ, sizeof(struct bt_att_exec_write_req),
 			     BT_ATT_CHAN_OPT(params));
 }
 
-static void gatt_prepare_write_rsp(struct bt_conn *conn, int err,
-				   const void *pdu, uint16_t length,
+static void gatt_prepare_write_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 				   void *user_data)
 {
 	struct bt_gatt_write_params *params = user_data;
@@ -5218,8 +5040,7 @@ fail:
 	params->func(conn, BT_ATT_ERR_UNLIKELY, params);
 }
 
-static int gatt_prepare_write_encode(struct net_buf *buf, size_t len,
-				     void *user_data)
+static int gatt_prepare_write_encode(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_write_params *params = user_data;
 	struct bt_att_prepare_write_req *req;
@@ -5229,9 +5050,8 @@ static int gatt_prepare_write_encode(struct net_buf *buf, size_t len,
 	req->handle = sys_cpu_to_le16(params->handle);
 	req->offset = sys_cpu_to_le16(params->offset);
 
-	write = net_buf_append_bytes(buf, len - sizeof(*req),
-				     (uint8_t *)params->data, K_NO_WAIT, NULL,
-				     NULL);
+	write = net_buf_append_bytes(buf, len - sizeof(*req), (uint8_t *)params->data, K_NO_WAIT,
+				     NULL, NULL);
 	if (write != (len - sizeof(*req))) {
 		return -ENOMEM;
 	}
@@ -5239,8 +5059,7 @@ static int gatt_prepare_write_encode(struct net_buf *buf, size_t len,
 	return 0;
 }
 
-static int gatt_prepare_write(struct bt_conn *conn,
-			      struct bt_gatt_write_params *params)
+static int gatt_prepare_write(struct bt_conn *conn, struct bt_gatt_write_params *params)
 {
 	uint16_t len, req_len;
 
@@ -5250,10 +5069,8 @@ static int gatt_prepare_write(struct bt_conn *conn,
 	len = MIN(params->length, len);
 	len += req_len;
 
-	return gatt_req_send(conn, gatt_prepare_write_rsp, params,
-			     gatt_prepare_write_encode,
-			     BT_ATT_OP_PREPARE_WRITE_REQ, len,
-			     BT_ATT_CHAN_OPT(params));
+	return gatt_req_send(conn, gatt_prepare_write_rsp, params, gatt_prepare_write_encode,
+			     BT_ATT_OP_PREPARE_WRITE_REQ, len, BT_ATT_CHAN_OPT(params));
 }
 
 static int gatt_write_encode(struct net_buf *buf, size_t len, void *user_data)
@@ -5265,8 +5082,7 @@ static int gatt_write_encode(struct net_buf *buf, size_t len, void *user_data)
 	req = net_buf_add(buf, sizeof(*req));
 	req->handle = sys_cpu_to_le16(params->handle);
 
-	write = net_buf_append_bytes(buf, params->length, params->data,
-				     K_NO_WAIT, NULL, NULL);
+	write = net_buf_append_bytes(buf, params->length, params->data, K_NO_WAIT, NULL, NULL);
 	if (write != params->length) {
 		return -ENOMEM;
 	}
@@ -5295,12 +5111,11 @@ int bt_gatt_write(struct bt_conn *conn, struct bt_gatt_write_params *params)
 
 	LOG_DBG("handle 0x%04x length %u", params->handle, params->length);
 
-	return gatt_req_send(conn, gatt_write_rsp, params, gatt_write_encode,
-			     BT_ATT_OP_WRITE_REQ, len, BT_ATT_CHAN_OPT(params));
+	return gatt_req_send(conn, gatt_write_rsp, params, gatt_write_encode, BT_ATT_OP_WRITE_REQ,
+			     len, BT_ATT_CHAN_OPT(params));
 }
 
-static void gatt_write_ccc_rsp(struct bt_conn *conn, int err,
-			       const void *pdu, uint16_t length,
+static void gatt_write_ccc_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 			       void *user_data)
 {
 	struct bt_gatt_subscribe_params *params = user_data;
@@ -5341,7 +5156,6 @@ static void gatt_write_ccc_rsp(struct bt_conn *conn, int err,
 	}
 }
 
-
 static int gatt_write_ccc_buf(struct net_buf *buf, size_t len, void *user_data)
 {
 	struct bt_gatt_subscribe_params *params = user_data;
@@ -5356,8 +5170,7 @@ static int gatt_write_ccc_buf(struct net_buf *buf, size_t len, void *user_data)
 	return 0;
 }
 
-static int gatt_write_ccc(struct bt_conn *conn,
-			  struct bt_gatt_subscribe_params *params,
+static int gatt_write_ccc(struct bt_conn *conn, struct bt_gatt_subscribe_params *params,
 			  bt_att_func_t rsp)
 {
 	size_t len = sizeof(struct bt_att_write_req) + sizeof(uint16_t);
@@ -5369,14 +5182,12 @@ static int gatt_write_ccc(struct bt_conn *conn,
 	 */
 	atomic_set_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_SENT);
 
-	return gatt_req_send(conn, rsp, params,
-			     gatt_write_ccc_buf, BT_ATT_OP_WRITE_REQ, len,
+	return gatt_req_send(conn, rsp, params, gatt_write_ccc_buf, BT_ATT_OP_WRITE_REQ, len,
 			     BT_ATT_CHAN_OPT(params));
 }
 
 #if defined(CONFIG_BT_GATT_AUTO_DISCOVER_CCC)
-static uint8_t gatt_ccc_discover_cb(struct bt_conn *conn,
-				    const struct bt_gatt_attr *attr,
+static uint8_t gatt_ccc_discover_cb(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 				    struct bt_gatt_discover_params *params)
 {
 	struct bt_gatt_subscribe_params *sub_params = params->sub_params;
@@ -5404,8 +5215,7 @@ static uint8_t gatt_ccc_discover_cb(struct bt_conn *conn,
 	return BT_GATT_ITER_CONTINUE;
 }
 
-static int gatt_ccc_discover(struct bt_conn *conn,
-			     struct bt_gatt_subscribe_params *params)
+static int gatt_ccc_discover(struct bt_conn *conn, struct bt_gatt_subscribe_params *params)
 {
 	int err;
 	static struct bt_uuid_16 ccc_uuid = BT_UUID_INIT_16(0);
@@ -5429,23 +5239,20 @@ static int gatt_ccc_discover(struct bt_conn *conn,
 		return err;
 	}
 	return 0;
-
 }
 #endif /* CONFIG_BT_GATT_AUTO_DISCOVER_CCC */
 
-int bt_gatt_subscribe(struct bt_conn *conn,
-		      struct bt_gatt_subscribe_params *params)
+int bt_gatt_subscribe(struct bt_conn *conn, struct bt_gatt_subscribe_params *params)
 {
 	struct gatt_sub *sub;
 	struct bt_gatt_subscribe_params *tmp;
 	bool has_subscription = false;
 
 	__ASSERT(conn, "invalid parameters\n");
-	__ASSERT(params && params->notify,  "invalid parameters\n");
+	__ASSERT(params && params->notify, "invalid parameters\n");
 	__ASSERT(params->value, "invalid parameters\n");
 #if defined(CONFIG_BT_GATT_AUTO_DISCOVER_CCC)
-	__ASSERT(params->ccc_handle ||
-		 (params->end_handle && params->disc_params),
+	__ASSERT(params->ccc_handle || (params->end_handle && params->disc_params),
 		 "invalid parameters\n");
 #else
 	__ASSERT(params->ccc_handle, "invalid parameters\n");
@@ -5476,8 +5283,7 @@ int bt_gatt_subscribe(struct bt_conn *conn,
 		}
 
 		/* Check if another subscription exists */
-		if (tmp->value_handle == params->value_handle &&
-		    tmp->value >= params->value) {
+		if (tmp->value_handle == params->value_handle && tmp->value >= params->value) {
 			has_subscription = true;
 		}
 	}
@@ -5508,12 +5314,12 @@ int bt_gatt_subscribe(struct bt_conn *conn,
 }
 
 int bt_gatt_resubscribe(uint8_t id, const bt_addr_le_t *peer,
-			     struct bt_gatt_subscribe_params *params)
+			struct bt_gatt_subscribe_params *params)
 {
 	struct gatt_sub *sub;
 	struct bt_gatt_subscribe_params *tmp;
 
-	__ASSERT(params && params->notify,  "invalid parameters\n");
+	__ASSERT(params && params->notify, "invalid parameters\n");
 	__ASSERT(params->value, "invalid parameters\n");
 	__ASSERT(params->ccc_handle, "invalid parameters\n");
 
@@ -5535,8 +5341,7 @@ int bt_gatt_resubscribe(uint8_t id, const bt_addr_le_t *peer,
 	return 0;
 }
 
-int bt_gatt_unsubscribe(struct bt_conn *conn,
-			struct bt_gatt_subscribe_params *params)
+int bt_gatt_unsubscribe(struct bt_conn *conn, struct bt_gatt_subscribe_params *params)
 {
 	struct gatt_sub *sub;
 	struct bt_gatt_subscribe_params *tmp;
@@ -5621,8 +5426,7 @@ void bt_gatt_cancel(struct bt_conn *conn, void *params)
 }
 
 #if defined(CONFIG_BT_GATT_AUTO_RESUBSCRIBE)
-static void gatt_resub_ccc_rsp(struct bt_conn *conn, int err,
-			       const void *pdu, uint16_t length,
+static void gatt_resub_ccc_rsp(struct bt_conn *conn, int err, const void *pdu, uint16_t length,
 			       void *user_data)
 {
 	LOG_DBG("err %d", err);
@@ -5638,8 +5442,7 @@ static void gatt_resub_ccc_rsp(struct bt_conn *conn, int err,
 	gatt_write_ccc_rsp(conn, err, pdu, length, user_data);
 }
 
-static int gatt_resub_ccc(struct bt_conn *conn,
-			  struct bt_gatt_subscribe_params *params)
+static int gatt_resub_ccc(struct bt_conn *conn, struct bt_gatt_subscribe_params *params)
 {
 	return gatt_write_ccc(conn, params, gatt_resub_ccc_rsp);
 }
@@ -5660,10 +5463,8 @@ static void add_subscriptions(struct bt_conn *conn)
 
 	/* Lookup existing subscriptions */
 	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
-		if (!atomic_test_bit(params->flags,
-				     BT_GATT_SUBSCRIBE_FLAG_SENT) &&
-		    !atomic_test_bit(params->flags,
-				     BT_GATT_SUBSCRIBE_FLAG_NO_RESUB)) {
+		if (!atomic_test_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_SENT) &&
+		    !atomic_test_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_NO_RESUB)) {
 			int err;
 
 			/* Force write to CCC to workaround devices that don't
@@ -5671,13 +5472,13 @@ static void add_subscriptions(struct bt_conn *conn)
 			 */
 			err = gatt_resub_ccc(conn, params);
 			if (err < 0) {
-				LOG_WRN("conn %p params %p resub failed (err %d)",
-					(void *)conn, params, err);
+				LOG_WRN("conn %p params %p resub failed (err %d)", (void *)conn,
+					params, err);
 			}
 		}
 	}
 }
-#endif	/* CONFIG_BT_GATT_AUTO_RESUBSCRIBE */
+#endif /* CONFIG_BT_GATT_AUTO_RESUBSCRIBE */
 
 #if defined(CONFIG_BT_GATT_AUTO_UPDATE_MTU)
 static void gatt_exchange_mtu_func(struct bt_conn *conn, uint8_t err,
@@ -5700,13 +5501,11 @@ static struct bt_gatt_exchange_params gatt_exchange_params = {
 #define CCC_STORE_MAX 0
 #endif /* defined(CONFIG_BT_SETTINGS_CCC_STORE_MAX) */
 
-static struct bt_gatt_ccc_cfg *ccc_find_cfg(struct _bt_gatt_ccc *ccc,
-					    const bt_addr_le_t *addr,
+static struct bt_gatt_ccc_cfg *ccc_find_cfg(struct _bt_gatt_ccc *ccc, const bt_addr_le_t *addr,
 					    uint8_t id)
 {
 	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
-		if (id == ccc->cfg[i].id &&
-		    bt_addr_le_eq(&ccc->cfg[i].peer, addr)) {
+		if (id == ccc->cfg[i].id && bt_addr_le_eq(&ccc->cfg[i].peer, addr)) {
 			return &ccc->cfg[i];
 		}
 	}
@@ -5725,9 +5524,7 @@ struct ccc_load {
 	size_t count;
 };
 
-static void ccc_clear(struct _bt_gatt_ccc *ccc,
-		      const bt_addr_le_t *addr,
-		      uint8_t id)
+static void ccc_clear(struct _bt_gatt_ccc *ccc, const bt_addr_le_t *addr, uint8_t id)
 {
 	struct bt_gatt_ccc_cfg *cfg;
 
@@ -5740,8 +5537,7 @@ static void ccc_clear(struct _bt_gatt_ccc *ccc,
 	clear_ccc_cfg(cfg);
 }
 
-static uint8_t ccc_load(const struct bt_gatt_attr *attr, uint16_t handle,
-			void *user_data)
+static uint8_t ccc_load(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct ccc_load *load = user_data;
 	struct _bt_gatt_ccc *ccc;
@@ -5769,7 +5565,8 @@ static uint8_t ccc_load(const struct bt_gatt_attr *attr, uint16_t handle,
 		 */
 		if (load->entry->handle < handle) {
 			LOG_DBG("Unable to restore CCC: handle 0x%04x cannot be"
-			       " found",  load->entry->handle);
+				" found",
+				load->entry->handle);
 			goto next;
 		}
 		return BT_GATT_ITER_CONTINUE;
@@ -5798,8 +5595,7 @@ next:
 	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
 }
 
-static int ccc_set(const char *name, size_t len_rd, settings_read_cb read_cb,
-		   void *cb_arg)
+static int ccc_set(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 		struct ccc_store ccc_store[CCC_STORE_MAX];
@@ -5864,8 +5660,7 @@ static int ccc_set(const char *name, size_t len_rd, settings_read_cb read_cb,
 	return 0;
 }
 
-static int ccc_set_cb(const char *name, size_t len_rd, settings_read_cb read_cb,
-		      void *cb_arg)
+static int ccc_set_cb(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING)) {
 		/* Only load CCCs on demand */
@@ -5877,8 +5672,8 @@ static int ccc_set_cb(const char *name, size_t len_rd, settings_read_cb read_cb,
 
 BT_SETTINGS_DEFINE(ccc, "ccc", ccc_set_cb, NULL);
 
-static int ccc_set_direct(const char *key, size_t len, settings_read_cb read_cb,
-			  void *cb_arg, void *param)
+static int ccc_set_direct(const char *key, size_t len, settings_read_cb read_cb, void *cb_arg,
+			  void *param)
 {
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 		const char *name;
@@ -5914,11 +5709,9 @@ void bt_gatt_connected(struct bt_conn *conn)
 			char id_str[4];
 
 			u8_to_dec(id_str, sizeof(id_str), conn->id);
-			bt_settings_encode_key(key, sizeof(key), "ccc",
-					       &conn->le.dst, id_str);
+			bt_settings_encode_key(key, sizeof(key), "ccc", &conn->le.dst, id_str);
 		} else {
-			bt_settings_encode_key(key, sizeof(key), "ccc",
-					       &conn->le.dst, NULL);
+			bt_settings_encode_key(key, sizeof(key), "ccc", &conn->le.dst, NULL);
 		}
 
 		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
@@ -5943,8 +5736,7 @@ void bt_gatt_connected(struct bt_conn *conn)
 	 * enabling encryption will fail.
 	 */
 	if (IS_ENABLED(CONFIG_BT_SMP) &&
-	    (conn->role == BT_HCI_ROLE_CENTRAL ||
-	     IS_ENABLED(CONFIG_BT_GATT_AUTO_SEC_REQ)) &&
+	    (conn->role == BT_HCI_ROLE_CENTRAL || IS_ENABLED(CONFIG_BT_GATT_AUTO_SEC_REQ)) &&
 	    bt_conn_get_security(conn) < data.sec) {
 		int err = bt_conn_set_security(conn, data.sec);
 
@@ -5985,7 +5777,7 @@ void bt_gatt_encrypt_change(struct bt_conn *conn)
 
 #if defined(CONFIG_BT_GATT_AUTO_RESUBSCRIBE)
 	add_subscriptions(conn);
-#endif	/* CONFIG_BT_GATT_AUTO_RESUBSCRIBE */
+#endif /* CONFIG_BT_GATT_AUTO_RESUBSCRIBE */
 
 	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
 
@@ -6052,15 +5844,13 @@ bool bt_gatt_change_aware(struct bt_conn *conn, bool req)
 #endif
 }
 
-static struct gatt_cf_cfg *find_cf_cfg_by_addr(uint8_t id,
-					       const bt_addr_le_t *addr)
+static struct gatt_cf_cfg *find_cf_cfg_by_addr(uint8_t id, const bt_addr_le_t *addr)
 {
 	if (IS_ENABLED(CONFIG_BT_GATT_CACHING)) {
 		int i;
 
 		for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
-			if (id == cf_cfg[i].id &&
-			    bt_addr_le_eq(addr, &cf_cfg[i].peer)) {
+			if (id == cf_cfg[i].id && bt_addr_le_eq(addr, &cf_cfg[i].peer)) {
 				return &cf_cfg[i];
 			}
 		}
@@ -6077,8 +5867,7 @@ struct ccc_save {
 	size_t count;
 };
 
-static uint8_t ccc_save(const struct bt_gatt_attr *attr, uint16_t handle,
-			void *user_data)
+static uint8_t ccc_save(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct ccc_save *save = user_data;
 	struct _bt_gatt_ccc *ccc;
@@ -6100,7 +5889,7 @@ static uint8_t ccc_save(const struct bt_gatt_attr *attr, uint16_t handle,
 
 	CHECKIF(save->count >= CCC_STORE_MAX) {
 		LOG_ERR("Too many Client Characteristic Configuration. "
-				"See CONFIG_BT_SETTINGS_CCC_STORE_MAX\n");
+			"See CONFIG_BT_SETTINGS_CCC_STORE_MAX\n");
 		return BT_GATT_ITER_STOP;
 	}
 
@@ -6153,8 +5942,7 @@ int bt_gatt_store_ccc(uint8_t id, const bt_addr_le_t *addr)
 }
 
 #if defined(CONFIG_BT_GATT_SERVICE_CHANGED)
-static int sc_set(const char *name, size_t len_rd, settings_read_cb read_cb,
-		  void *cb_arg)
+static int sc_set(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	struct gatt_sc_cfg *cfg;
 	uint8_t id;
@@ -6239,8 +6027,7 @@ BT_SETTINGS_DEFINE(sc, "sc", sc_set, sc_commit);
 #endif /* CONFIG_BT_GATT_SERVICE_CHANGED */
 
 #if defined(CONFIG_BT_GATT_CACHING)
-static int cf_set(const char *name, size_t len_rd, settings_read_cb read_cb,
-		  void *cb_arg)
+static int cf_set(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	struct gatt_cf_cfg *cfg;
 	bt_addr_le_t addr;
@@ -6327,8 +6114,7 @@ static int cf_set(const char *name, size_t len_rd, settings_read_cb read_cb,
 
 BT_SETTINGS_DEFINE(cf, "cf", cf_set, NULL);
 
-static int db_hash_set(const char *name, size_t len_rd,
-		       settings_read_cb read_cb, void *cb_arg)
+static int db_hash_set(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	ssize_t len;
 
@@ -6360,8 +6146,8 @@ BT_SETTINGS_DEFINE(hash, "hash", db_hash_set, db_hash_commit);
 #endif /*CONFIG_BT_GATT_CACHING */
 #endif /* CONFIG_BT_SETTINGS */
 
-static uint8_t remove_peer_from_attr(const struct bt_gatt_attr *attr,
-				     uint16_t handle, void *user_data)
+static uint8_t remove_peer_from_attr(const struct bt_gatt_attr *attr, uint16_t handle,
+				     void *user_data)
 {
 	const struct addr_with_id *addr_with_id = user_data;
 	struct _bt_gatt_ccc *ccc;
@@ -6389,8 +6175,7 @@ static int bt_gatt_clear_ccc(uint8_t id, const bt_addr_le_t *addr)
 		.id = id,
 	};
 
-	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
-			     &addr_with_id);
+	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr, &addr_with_id);
 
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 		return bt_settings_delete_ccc(id, addr);
@@ -6413,17 +6198,14 @@ static int bt_gatt_clear_cf(uint8_t id, const bt_addr_le_t *addr)
 	}
 
 	return 0;
-
 }
 
-
 static struct gatt_sub *find_gatt_sub(uint8_t id, const bt_addr_le_t *addr)
 {
 	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
 		struct gatt_sub *sub = &subscriptions[i];
 
-		if (id == sub->id &&
-		    bt_addr_le_eq(addr, &sub->peer)) {
+		if (id == sub->id && bt_addr_le_eq(addr, &sub->peer)) {
 			return sub;
 		}
 	}
@@ -6442,8 +6224,7 @@ static void bt_gatt_clear_subscriptions(uint8_t id, const bt_addr_le_t *addr)
 		return;
 	}
 
-	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
-					  node) {
+	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
 		params->value = 0U;
 		gatt_sub_remove(NULL, sub, prev, params);
 	}
@@ -6500,9 +6281,7 @@ void bt_gatt_disconnected(struct bt_conn *conn)
 			.addr = &conn->le.dst,
 			.id = conn->id,
 		};
-		bt_gatt_foreach_attr(0x0001, 0xffff,
-				     remove_peer_from_attr,
-				     &addr_with_id);
+		bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr, &addr_with_id);
 	}
 
 #if defined(CONFIG_BT_GATT_CLIENT)
diff --git a/subsys/bluetooth/host/gatt_internal.h b/subsys/bluetooth/host/gatt_internal.h
index 718ce95a5d7..b0bdf85bdee 100644
--- a/subsys/bluetooth/host/gatt_internal.h
+++ b/subsys/bluetooth/host/gatt_internal.h
@@ -8,26 +8,20 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-#define BT_GATT_CENTRAL_ADDR_RES_NOT_SUPP	0
-#define BT_GATT_CENTRAL_ADDR_RES_SUPP		1
-
-#define BT_GATT_PERM_READ_MASK			(BT_GATT_PERM_READ | \
-						BT_GATT_PERM_READ_ENCRYPT | \
-						BT_GATT_PERM_READ_AUTHEN | \
-						BT_GATT_PERM_READ_LESC)
-#define BT_GATT_PERM_WRITE_MASK			(BT_GATT_PERM_WRITE | \
-						BT_GATT_PERM_WRITE_ENCRYPT | \
-						BT_GATT_PERM_WRITE_AUTHEN | \
-						BT_GATT_PERM_WRITE_LESC)
-#define BT_GATT_PERM_ENCRYPT_MASK		(BT_GATT_PERM_READ_ENCRYPT | \
-						BT_GATT_PERM_WRITE_ENCRYPT)
-#define BT_GATT_PERM_AUTHEN_MASK		(BT_GATT_PERM_READ_AUTHEN | \
-						BT_GATT_PERM_WRITE_AUTHEN)
-#define BT_GATT_PERM_LESC_MASK			(BT_GATT_PERM_READ_LESC | \
-						BT_GATT_PERM_WRITE_LESC)
-#define BT_GATT_PERM_READ_ENCRYPT_MASK		(BT_GATT_PERM_READ_ENCRYPT | \
-						BT_GATT_PERM_READ_AUTHEN | \
-						BT_GATT_PERM_READ_LESC)
+#define BT_GATT_CENTRAL_ADDR_RES_NOT_SUPP 0
+#define BT_GATT_CENTRAL_ADDR_RES_SUPP     1
+
+#define BT_GATT_PERM_READ_MASK                                                                     \
+	(BT_GATT_PERM_READ | BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_READ_AUTHEN |                \
+	 BT_GATT_PERM_READ_LESC)
+#define BT_GATT_PERM_WRITE_MASK                                                                    \
+	(BT_GATT_PERM_WRITE | BT_GATT_PERM_WRITE_ENCRYPT | BT_GATT_PERM_WRITE_AUTHEN |             \
+	 BT_GATT_PERM_WRITE_LESC)
+#define BT_GATT_PERM_ENCRYPT_MASK (BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_WRITE_ENCRYPT)
+#define BT_GATT_PERM_AUTHEN_MASK  (BT_GATT_PERM_READ_AUTHEN | BT_GATT_PERM_WRITE_AUTHEN)
+#define BT_GATT_PERM_LESC_MASK    (BT_GATT_PERM_READ_LESC | BT_GATT_PERM_WRITE_LESC)
+#define BT_GATT_PERM_READ_ENCRYPT_MASK                                                             \
+	(BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_READ_AUTHEN | BT_GATT_PERM_READ_LESC)
 
 void bt_gatt_init(void);
 void bt_gatt_connected(struct bt_conn *conn);
@@ -42,19 +36,17 @@ int bt_gatt_store_ccc(uint8_t id, const bt_addr_le_t *addr);
 int bt_gatt_clear(uint8_t id, const bt_addr_le_t *addr);
 
 #if defined(CONFIG_BT_GATT_CLIENT)
-void bt_gatt_notification(struct bt_conn *conn, uint16_t handle,
-			  const void *data, uint16_t length);
+void bt_gatt_notification(struct bt_conn *conn, uint16_t handle, const void *data, uint16_t length);
 
-void bt_gatt_mult_notification(struct bt_conn *conn, const void *data,
-			       uint16_t length);
+void bt_gatt_mult_notification(struct bt_conn *conn, const void *data, uint16_t length);
 #else
-static inline void bt_gatt_notification(struct bt_conn *conn, uint16_t handle,
-					const void *data, uint16_t length)
+static inline void bt_gatt_notification(struct bt_conn *conn, uint16_t handle, const void *data,
+					uint16_t length)
 {
 }
 
-static inline void bt_gatt_mult_notification(struct bt_conn *conn,
-					     const void *data, uint16_t length)
+static inline void bt_gatt_mult_notification(struct bt_conn *conn, const void *data,
+					     uint16_t length)
 {
 }
 #endif /* CONFIG_BT_GATT_CLIENT */
@@ -62,5 +54,4 @@ static inline void bt_gatt_mult_notification(struct bt_conn *conn,
 struct bt_gatt_attr;
 
 /* Check attribute permission */
-uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			uint16_t mask);
+uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr *attr, uint16_t mask);
diff --git a/subsys/bluetooth/host/hci_core.c b/subsys/bluetooth/host/hci_core.c
index f5aa584e4cd..b87a90729f9 100644
--- a/subsys/bluetooth/host/hci_core.c
+++ b/subsys/bluetooth/host/hci_core.c
@@ -84,7 +84,7 @@ BUILD_ASSERT(IS_ENABLED(CONFIG_ZTEST), "Missing DT chosen property for HCI");
 
 void bt_tx_irq_raise(void);
 
-#define HCI_CMD_TIMEOUT      K_SECONDS(10)
+#define HCI_CMD_TIMEOUT K_SECONDS(10)
 
 /* Stacks for the threads */
 static void rx_work_handler(struct k_work *work);
@@ -97,9 +97,9 @@ static K_KERNEL_STACK_DEFINE(rx_thread_stack, CONFIG_BT_RX_STACK_SIZE);
 static void init_work(struct k_work *work);
 
 struct bt_dev bt_dev = {
-	.init          = Z_WORK_INITIALIZER(init_work),
+	.init = Z_WORK_INITIALIZER(init_work),
 #if defined(CONFIG_BT_PRIVACY)
-	.rpa_timeout   = CONFIG_BT_RPA_TIMEOUT,
+	.rpa_timeout = CONFIG_BT_RPA_TIMEOUT,
 #endif
 #if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
 	.appearance = CONFIG_BT_DEVICE_APPEARANCE,
@@ -115,7 +115,7 @@ static bt_hci_vnd_evt_cb_t *hci_vnd_evt_cb;
 
 struct cmd_data {
 	/** HCI status of the command completion */
-	uint8_t  status;
+	uint8_t status;
 
 	/** The command OpCode that the buffer contains */
 	uint16_t opcode;
@@ -142,8 +142,7 @@ bool bt_drv_quirk_no_auto_dle(void)
 	return ((BT_HCI_QUIRKS & BT_HCI_QUIRK_NO_AUTO_DLE) != 0);
 }
 
-void bt_hci_cmd_state_set_init(struct net_buf *buf,
-			       struct bt_hci_cmd_state_set *state,
+void bt_hci_cmd_state_set_init(struct net_buf *buf, struct bt_hci_cmd_state_set *state,
 			       atomic_t *target, int bit, bool val)
 {
 	state->target = target;
@@ -157,8 +156,8 @@ void bt_hci_cmd_state_set_init(struct net_buf *buf,
  * command complete or command status.
  */
 #define CMD_BUF_SIZE MAX(BT_BUF_EVT_RX_SIZE, BT_BUF_CMD_TX_SIZE)
-NET_BUF_POOL_FIXED_DEFINE(hci_cmd_pool, CONFIG_BT_BUF_CMD_TX_COUNT,
-			  CMD_BUF_SIZE, sizeof(struct bt_buf_data), NULL);
+NET_BUF_POOL_FIXED_DEFINE(hci_cmd_pool, CONFIG_BT_BUF_CMD_TX_COUNT, CMD_BUF_SIZE,
+			  sizeof(struct bt_buf_data), NULL);
 
 struct event_handler {
 	uint8_t event;
@@ -166,12 +165,12 @@ struct event_handler {
 	void (*handler)(struct net_buf *buf);
 };
 
-#define EVENT_HANDLER(_evt, _handler, _min_len) \
-{ \
-	.event = _evt, \
-	.handler = _handler, \
-	.min_len = _min_len, \
-}
+#define EVENT_HANDLER(_evt, _handler, _min_len)                                                    \
+	{                                                                                          \
+		.event = _evt,                                                                     \
+		.handler = _handler,                                                               \
+		.min_len = _min_len,                                                               \
+	}
 
 static int handle_event_common(uint8_t event, struct net_buf *buf,
 			       const struct event_handler *handlers, size_t num_handlers)
@@ -244,8 +243,7 @@ void bt_send_one_host_num_completed_packets(uint16_t handle)
 
 	LOG_DBG("Reporting completed packet for handle %u", handle);
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS,
-				sizeof(*cp) + sizeof(*hc));
+	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, sizeof(*cp) + sizeof(*hc));
 	BT_ASSERT_MSG(buf, "Unable to alloc for Host NCP");
 
 	cp = net_buf_add(buf, sizeof(*cp));
@@ -253,7 +251,7 @@ void bt_send_one_host_num_completed_packets(uint16_t handle)
 
 	hc = net_buf_add(buf, sizeof(*hc));
 	hc->handle = sys_cpu_to_le16(handle);
-	hc->count  = sys_cpu_to_le16(1);
+	hc->count = sys_cpu_to_le16(1);
 
 	err = bt_hci_cmd_send(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, buf);
 	BT_ASSERT_MSG(err == 0, "Unable to send Host NCP (err %d)", err);
@@ -293,8 +291,7 @@ void bt_hci_host_num_completed_packets(struct net_buf *buf)
 		return;
 	}
 
-	if (conn->state != BT_CONN_CONNECTED &&
-	    conn->state != BT_CONN_DISCONNECTING) {
+	if (conn->state != BT_CONN_CONNECTED && conn->state != BT_CONN_DISCONNECTING) {
 		LOG_WRN("Not reporting packet for non-connected conn");
 		bt_conn_unref(conn);
 		return;
@@ -370,8 +367,7 @@ int bt_hci_cmd_send(uint16_t opcode, struct net_buf *buf)
 }
 
 static bool process_pending_cmd(k_timeout_t timeout);
-int bt_hci_cmd_send_sync(uint16_t opcode, struct net_buf *buf,
-			 struct net_buf **rsp)
+int bt_hci_cmd_send_sync(uint16_t opcode, struct net_buf *buf, struct net_buf **rsp)
 {
 	struct k_sem sync_sem;
 	uint8_t status;
@@ -434,13 +430,13 @@ int bt_hci_cmd_send_sync(uint16_t opcode, struct net_buf *buf,
 	/* Now that we have sent the command, suspend until the LL replies */
 	err = k_sem_take(&sync_sem, HCI_CMD_TIMEOUT);
 	BT_ASSERT_MSG(err == 0,
-		      "Controller unresponsive, command opcode 0x%04x timeout with err %d",
-		      opcode, err);
+		      "Controller unresponsive, command opcode 0x%04x timeout with err %d", opcode,
+		      err);
 
 	status = cmd(buf)->status;
 	if (status) {
-		LOG_WRN("opcode 0x%04x status 0x%02x %s", opcode,
-			status, bt_hci_err_to_str(status));
+		LOG_WRN("opcode 0x%04x status 0x%02x %s", opcode, status,
+			bt_hci_err_to_str(status));
 		net_buf_unref(buf);
 
 		switch (status) {
@@ -564,10 +560,8 @@ static void hci_num_completed_packets(struct net_buf *buf)
 	int i;
 
 	if (sizeof(*evt) + sizeof(evt->h[0]) * evt->num_handles > buf->len) {
-		LOG_ERR("evt num_handles (=%u) too large (%u > %u)",
-			evt->num_handles,
-			sizeof(*evt) + sizeof(evt->h[0]) * evt->num_handles,
-			buf->len);
+		LOG_ERR("evt num_handles (=%u) too large (%u > %u)", evt->num_handles,
+			sizeof(*evt) + sizeof(evt->h[0]) * evt->num_handles, buf->len);
 		return;
 	}
 
@@ -671,8 +665,7 @@ static void hci_data_buf_overflow(struct net_buf *buf)
 }
 
 #if defined(CONFIG_BT_CENTRAL)
-static void set_phy_conn_param(const struct bt_conn *conn,
-			       struct bt_hci_ext_conn_phy *phy)
+static void set_phy_conn_param(const struct bt_conn *conn, struct bt_hci_ext_conn_phy *phy)
 {
 	phy->conn_interval_min = sys_cpu_to_le16(conn->le.interval_min);
 	phy->conn_interval_max = sys_cpu_to_le16(conn->le.interval_max);
@@ -703,13 +696,11 @@ int bt_le_create_conn_ext(const struct bt_conn *conn)
 		return err;
 	}
 
-	num_phys = (!(bt_dev.create_param.options &
-		      BT_CONN_LE_OPT_NO_1M) ? 1 : 0) +
-		   ((bt_dev.create_param.options &
-		      BT_CONN_LE_OPT_CODED) ? 1 : 0);
+	num_phys = (!(bt_dev.create_param.options & BT_CONN_LE_OPT_NO_1M) ? 1 : 0) +
+		   ((bt_dev.create_param.options & BT_CONN_LE_OPT_CODED) ? 1 : 0);
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_EXT_CREATE_CONN, sizeof(*cp) +
-				num_phys * sizeof(*phy));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_EXT_CREATE_CONN,
+				sizeof(*cp) + num_phys * sizeof(*phy));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -740,25 +731,20 @@ int bt_le_create_conn_ext(const struct bt_conn *conn)
 	if (!(bt_dev.create_param.options & BT_CONN_LE_OPT_NO_1M)) {
 		cp->phys |= BT_HCI_LE_EXT_SCAN_PHY_1M;
 		phy = net_buf_add(buf, sizeof(*phy));
-		phy->scan_interval = sys_cpu_to_le16(
-			bt_dev.create_param.interval);
-		phy->scan_window = sys_cpu_to_le16(
-			bt_dev.create_param.window);
+		phy->scan_interval = sys_cpu_to_le16(bt_dev.create_param.interval);
+		phy->scan_window = sys_cpu_to_le16(bt_dev.create_param.window);
 		set_phy_conn_param(conn, phy);
 	}
 
 	if (bt_dev.create_param.options & BT_CONN_LE_OPT_CODED) {
 		cp->phys |= BT_HCI_LE_EXT_SCAN_PHY_CODED;
 		phy = net_buf_add(buf, sizeof(*phy));
-		phy->scan_interval = sys_cpu_to_le16(
-			bt_dev.create_param.interval_coded);
-		phy->scan_window = sys_cpu_to_le16(
-			bt_dev.create_param.window_coded);
+		phy->scan_interval = sys_cpu_to_le16(bt_dev.create_param.interval_coded);
+		phy->scan_window = sys_cpu_to_le16(bt_dev.create_param.window_coded);
 		set_phy_conn_param(conn, phy);
 	}
 
-	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags,
-				  BT_DEV_INITIATING, true);
+	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_INITIATING, true);
 
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_EXT_CREATE_CONN, buf, NULL);
 }
@@ -863,16 +849,14 @@ static int bt_le_create_conn_legacy(const struct bt_conn *conn)
 	cp->conn_latency = sys_cpu_to_le16(conn->le.latency);
 	cp->supervision_timeout = sys_cpu_to_le16(conn->le.timeout);
 
-	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags,
-				  BT_DEV_INITIATING, true);
+	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_INITIATING, true);
 
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CREATE_CONN, buf, NULL);
 }
 
 int bt_le_create_conn(const struct bt_conn *conn)
 {
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		return bt_le_create_conn_ext(conn);
 	}
 
@@ -886,8 +870,7 @@ int bt_le_create_conn_cancel(void)
 
 	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN_CANCEL, 0);
 
-	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags,
-				  BT_DEV_INITIATING, false);
+	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_INITIATING, false);
 
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CREATE_CONN_CANCEL, buf, NULL);
 }
@@ -954,8 +937,8 @@ static void hci_disconn_complete_prio(struct net_buf *buf)
 	uint16_t handle = sys_le16_to_cpu(evt->handle);
 	struct bt_conn *conn;
 
-	LOG_DBG("status 0x%02x %s handle %u reason 0x%02x",
-		evt->status, bt_hci_err_to_str(evt->status), handle, evt->reason);
+	LOG_DBG("status 0x%02x %s handle %u reason 0x%02x", evt->status,
+		bt_hci_err_to_str(evt->status), handle, evt->reason);
 
 	if (evt->status) {
 		return;
@@ -982,8 +965,8 @@ static void hci_disconn_complete(struct net_buf *buf)
 	uint16_t handle = sys_le16_to_cpu(evt->handle);
 	struct bt_conn *conn;
 
-	LOG_DBG("status 0x%02x %s handle %u reason 0x%02x",
-		evt->status, bt_hci_err_to_str(evt->status), handle, evt->reason);
+	LOG_DBG("status 0x%02x %s handle %u reason 0x%02x", evt->status,
+		bt_hci_err_to_str(evt->status), handle, evt->reason);
 
 	if (evt->status) {
 		return;
@@ -1036,8 +1019,7 @@ int bt_hci_le_read_remote_features(struct bt_conn *conn)
 	struct bt_hci_cp_le_read_remote_features *cp;
 	struct net_buf *buf;
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -1062,8 +1044,7 @@ int bt_hci_read_remote_version(struct bt_conn *conn)
 		return 0;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_READ_REMOTE_VERSION_INFO,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_READ_REMOTE_VERSION_INFO, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -1071,8 +1052,7 @@ int bt_hci_read_remote_version(struct bt_conn *conn)
 	cp = net_buf_add(buf, sizeof(*cp));
 	cp->handle = sys_cpu_to_le16(conn->handle);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_READ_REMOTE_VERSION_INFO, buf,
-				    NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_READ_REMOTE_VERSION_INFO, buf, NULL);
 }
 
 /* LE Data Length Change Event is optional so this function just ignore
@@ -1126,8 +1106,8 @@ static int hci_le_read_phy(struct bt_conn *conn)
 }
 #endif /* defined(CONFIG_BT_USER_PHY_UPDATE) */
 
-int bt_le_set_phy(struct bt_conn *conn, uint8_t all_phys,
-		  uint8_t pref_tx_phy, uint8_t pref_rx_phy, uint8_t phy_opts)
+int bt_le_set_phy(struct bt_conn *conn, uint8_t all_phys, uint8_t pref_tx_phy, uint8_t pref_rx_phy,
+		  uint8_t phy_opts)
 {
 	struct bt_hci_cp_le_set_phy *cp;
 	struct net_buf *buf;
@@ -1156,11 +1136,9 @@ static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_add
 	 * CONNECT or CONNECT_AUTO state associated with passed peer LE address.
 	 */
 	if (IS_ENABLED(CONFIG_BT_CENTRAL) && role == BT_HCI_ROLE_CENTRAL) {
-		conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, peer_addr,
-					       BT_CONN_INITIATING);
+		conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, peer_addr, BT_CONN_INITIATING);
 		if (IS_ENABLED(CONFIG_BT_FILTER_ACCEPT_LIST) && !conn) {
-			conn = bt_conn_lookup_state_le(BT_ID_DEFAULT,
-						       BT_ADDR_LE_NONE,
+			conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, BT_ADDR_LE_NONE,
 						       BT_CONN_INITIATING_FILTER_LIST);
 		}
 
@@ -1171,8 +1149,7 @@ static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_add
 		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
 					       BT_CONN_ADV_DIR_CONNECTABLE);
 		if (!conn) {
-			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
-						       BT_ADDR_LE_NONE,
+			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, BT_ADDR_LE_NONE,
 						       BT_CONN_ADV_CONNECTABLE);
 		}
 
@@ -1230,8 +1207,7 @@ static void le_conn_complete_cancel(uint8_t err)
 
 static void le_conn_complete_adv_timeout(void)
 {
-	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	      BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 		struct bt_conn *conn;
 
@@ -1241,8 +1217,7 @@ static void le_conn_complete_adv_timeout(void)
 
 		atomic_clear_bit(adv->flags, BT_ADV_ENABLED);
 
-		if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-		    !BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+		if (IS_ENABLED(CONFIG_BT_EXT_ADV) && !BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 			/* No advertising set terminated event, must be a
 			 * legacy advertiser set.
 			 */
@@ -1268,20 +1243,17 @@ static void le_conn_complete_adv_timeout(void)
 static void enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 {
 #if defined(CONFIG_BT_CONN) && (CONFIG_BT_EXT_ADV_MAX_ADV_SET > 1)
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-		evt->role == BT_HCI_ROLE_PERIPHERAL &&
-		evt->status == BT_HCI_ERR_SUCCESS &&
-		(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-				BT_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && evt->role == BT_HCI_ROLE_PERIPHERAL &&
+	    evt->status == BT_HCI_ERR_SUCCESS &&
+	    (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 
 		/* Cache the connection complete event. Process it later.
 		 * See bt_dev.cached_conn_complete.
 		 */
 		for (int i = 0; i < ARRAY_SIZE(bt_dev.cached_conn_complete); i++) {
 			if (!bt_dev.cached_conn_complete[i].valid) {
-				(void)memcpy(&bt_dev.cached_conn_complete[i].evt,
-					evt,
-					sizeof(struct bt_hci_evt_le_enh_conn_complete));
+				(void)memcpy(&bt_dev.cached_conn_complete[i].evt, evt,
+					     sizeof(struct bt_hci_evt_le_enh_conn_complete));
 				bt_dev.cached_conn_complete[i].valid = true;
 				return;
 			}
@@ -1343,9 +1315,9 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 	struct bt_conn *conn;
 	uint8_t id;
 
-	LOG_DBG("status 0x%02x %s handle %u role %u peer %s peer RPA %s",
-		evt->status, bt_hci_err_to_str(evt->status), handle,
-		evt->role, bt_addr_le_str(&evt->peer_addr), bt_addr_str(&evt->peer_rpa));
+	LOG_DBG("status 0x%02x %s handle %u role %u peer %s peer RPA %s", evt->status,
+		bt_hci_err_to_str(evt->status), handle, evt->role, bt_addr_le_str(&evt->peer_addr),
+		bt_addr_str(&evt->peer_rpa));
 	LOG_DBG("local RPA %s", bt_addr_str(&evt->local_rpa));
 
 #if defined(CONFIG_BT_SMP)
@@ -1357,10 +1329,8 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 
 	conn = find_pending_connect(evt->role, &id_addr);
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    evt->role == BT_HCI_ROLE_PERIPHERAL &&
-	    !(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	      BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && evt->role == BT_HCI_ROLE_PERIPHERAL &&
+	    !(IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 		/* Clear advertising even if we are not able to add connection
 		 * object to keep host in sync with controller state.
@@ -1369,8 +1339,7 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 		(void)bt_le_lim_adv_cancel_timeout(adv);
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    evt->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && evt->role == BT_HCI_ROLE_CENTRAL) {
 		/* Clear initiating even if we are not able to add connection
 		 * object to keep the host in sync with controller state.
 		 */
@@ -1394,8 +1363,7 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 	 * or responder address. Only peripheral needs to be updated. For central all
 	 * was set during outgoing connection creation.
 	 */
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    conn->role == BT_HCI_ROLE_PERIPHERAL) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->role == BT_HCI_ROLE_PERIPHERAL) {
 		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
 
 		if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
@@ -1406,15 +1374,12 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 			    !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
 				conn->le.resp_addr.type = BT_ADDR_LE_RANDOM;
 				if (!bt_addr_eq(&evt->local_rpa, BT_ADDR_ANY)) {
-					bt_addr_copy(&conn->le.resp_addr.a,
-						     &evt->local_rpa);
+					bt_addr_copy(&conn->le.resp_addr.a, &evt->local_rpa);
 				} else {
-					bt_addr_copy(&conn->le.resp_addr.a,
-						     &bt_dev.random_addr.a);
+					bt_addr_copy(&conn->le.resp_addr.a, &bt_dev.random_addr.a);
 				}
 			} else {
-				bt_addr_le_copy(&conn->le.resp_addr,
-						&bt_dev.id_addr[conn->id]);
+				bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr[conn->id]);
 			}
 		} else {
 			/* Copy the local RPA and handle this in advertising set
@@ -1432,8 +1397,7 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 			bt_le_adv_resume();
 		}
 
-		if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-		    !BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+		if (IS_ENABLED(CONFIG_BT_EXT_ADV) && !BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 			struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
 			/* No advertising set terminated event, must be a
 			 * legacy advertiser set.
@@ -1444,28 +1408,23 @@ void bt_hci_le_enh_conn_complete(struct bt_hci_evt_le_enh_conn_complete *evt)
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL) {
 		bt_addr_le_copy(&conn->le.resp_addr, &peer_addr);
 
 		if (IS_ENABLED(CONFIG_BT_PRIVACY)) {
 			conn->le.init_addr.type = BT_ADDR_LE_RANDOM;
 			if (!bt_addr_eq(&evt->local_rpa, BT_ADDR_ANY)) {
-				bt_addr_copy(&conn->le.init_addr.a,
-					     &evt->local_rpa);
+				bt_addr_copy(&conn->le.init_addr.a, &evt->local_rpa);
 			} else {
-				bt_addr_copy(&conn->le.init_addr.a,
-					     &bt_dev.random_addr.a);
+				bt_addr_copy(&conn->le.init_addr.a, &bt_dev.random_addr.a);
 			}
 		} else {
-			bt_addr_le_copy(&conn->le.init_addr,
-					&bt_dev.id_addr[conn->id]);
+			bt_addr_le_copy(&conn->le.init_addr, &bt_dev.id_addr[conn->id]);
 		}
 	}
 
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		int err;
 
 		err = hci_le_read_phy(conn);
@@ -1528,9 +1487,9 @@ void bt_hci_le_enh_conn_complete_sync(struct bt_hci_evt_le_enh_conn_complete_v2
 		return;
 	}
 
-	LOG_DBG("status 0x%02x %s handle %u role %u peer %s peer RPA %s",
-		evt->status, bt_hci_err_to_str(evt->status), handle,
-		evt->role, bt_addr_le_str(&evt->peer_addr), bt_addr_str(&evt->peer_rpa));
+	LOG_DBG("status 0x%02x %s handle %u role %u peer %s peer RPA %s", evt->status,
+		bt_hci_err_to_str(evt->status), handle, evt->role, bt_addr_le_str(&evt->peer_addr),
+		bt_addr_str(&evt->peer_rpa));
 	LOG_DBG("local RPA %s", bt_addr_str(&evt->local_rpa));
 
 	if (evt->role != BT_HCI_ROLE_PERIPHERAL) {
@@ -1679,16 +1638,15 @@ static void le_legacy_conn_complete(struct net_buf *buf)
 		return;
 	}
 
-	LOG_DBG("status 0x%02x %s role %u %s",
-		evt->status, bt_hci_err_to_str(evt->status), evt->role,
-		bt_addr_le_str(&evt->peer_addr));
+	LOG_DBG("status 0x%02x %s role %u %s", evt->status, bt_hci_err_to_str(evt->status),
+		evt->role, bt_addr_le_str(&evt->peer_addr));
 
-	enh.status         = evt->status;
-	enh.handle         = evt->handle;
-	enh.role           = evt->role;
-	enh.interval       = evt->interval;
-	enh.latency        = evt->latency;
-	enh.supv_timeout   = evt->supv_timeout;
+	enh.status = evt->status;
+	enh.handle = evt->handle;
+	enh.role = evt->role;
+	enh.interval = evt->interval;
+	enh.latency = evt->latency;
+	enh.supv_timeout = evt->supv_timeout;
 	enh.clock_accuracy = evt->clock_accuracy;
 
 	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
@@ -1717,14 +1675,12 @@ static void le_remote_feat_complete(struct net_buf *buf)
 	}
 
 	if (!evt->status) {
-		memcpy(conn->le.features, evt->features,
-		       sizeof(conn->le.features));
+		memcpy(conn->le.features, evt->features, sizeof(conn->le.features));
 	}
 
 	atomic_set_bit(conn->flags, BT_CONN_LE_FEATURES_EXCHANGED);
 
-	if (IS_ENABLED(CONFIG_BT_REMOTE_INFO) &&
-	    !IS_ENABLED(CONFIG_BT_REMOTE_VERSION)) {
+	if (IS_ENABLED(CONFIG_BT_REMOTE_INFO) && !IS_ENABLED(CONFIG_BT_REMOTE_VERSION)) {
 		notify_remote_info(conn);
 	}
 
@@ -1790,9 +1746,8 @@ static void le_phy_update_complete(struct net_buf *buf)
 		return;
 	}
 
-	LOG_DBG("PHY updated: status: 0x%02x %s, tx: %u, rx: %u",
-		evt->status, bt_hci_err_to_str(evt->status), evt->tx_phy,
-		evt->rx_phy);
+	LOG_DBG("PHY updated: status: 0x%02x %s, tx: %u, rx: %u", evt->status,
+		bt_hci_err_to_str(evt->status), evt->tx_phy, evt->rx_phy);
 
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
 	conn->le.phy.tx_phy = bt_get_phy(evt->tx_phy);
@@ -1812,8 +1767,8 @@ bool bt_le_conn_params_valid(const struct bt_le_conn_param *param)
 
 	/* All limits according to BT Core spec 5.0 [Vol 2, Part E, 7.8.12] */
 
-	if (param->interval_min > param->interval_max ||
-	    param->interval_min < 6 || param->interval_max > 3200) {
+	if (param->interval_min > param->interval_max || param->interval_min < 6 ||
+	    param->interval_max > 3200) {
 		return false;
 	}
 
@@ -1822,8 +1777,7 @@ bool bt_le_conn_params_valid(const struct bt_le_conn_param *param)
 	}
 
 	if (param->timeout < 10 || param->timeout > 3200 ||
-	    ((param->timeout * 4U) <=
-	     ((1U + param->latency) * param->interval_max))) {
+	    ((param->timeout * 4U) <= ((1U + param->latency) * param->interval_max))) {
 		return false;
 	}
 
@@ -1835,8 +1789,7 @@ static void le_conn_param_neg_reply(uint16_t handle, uint8_t reason)
 	struct bt_hci_cp_le_conn_param_req_neg_reply *cp;
 	struct net_buf *buf;
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, sizeof(*cp));
 	if (!buf) {
 		LOG_ERR("Unable to allocate buffer");
 		return;
@@ -1849,8 +1802,7 @@ static void le_conn_param_neg_reply(uint16_t handle, uint8_t reason)
 	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
 }
 
-static int le_conn_param_req_reply(uint16_t handle,
-				   const struct bt_le_conn_param *param)
+static int le_conn_param_req_reply(uint16_t handle, const struct bt_le_conn_param *param)
 {
 	struct bt_hci_cp_le_conn_param_req_reply *cp;
 	struct net_buf *buf;
@@ -1909,8 +1861,7 @@ static void le_conn_update_complete(struct net_buf *buf)
 
 	handle = sys_le16_to_cpu(evt->handle);
 
-	LOG_DBG("status 0x%02x %s, handle %u",
-		evt->status, bt_hci_err_to_str(evt->status), handle);
+	LOG_DBG("status 0x%02x %s, handle %u", evt->status, bt_hci_err_to_str(evt->status), handle);
 
 	conn = bt_conn_lookup_handle(handle, BT_CONN_TYPE_LE);
 	if (!conn) {
@@ -1920,8 +1871,7 @@ static void le_conn_update_complete(struct net_buf *buf)
 
 	if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
 	    conn->role == BT_HCI_ROLE_PERIPHERAL &&
-	    !atomic_test_and_set_bit(conn->flags,
-				     BT_CONN_PERIPHERAL_PARAM_L2CAP)) {
+	    !atomic_test_and_set_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) {
 		/* CPR not supported, let's try L2CAP CPUP instead */
 		struct bt_le_conn_param param;
 
@@ -1955,20 +1905,16 @@ static void le_conn_update_complete(struct net_buf *buf)
 			}
 
 #if defined(CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS)
-			atomic_clear_bit(conn->flags,
-					 BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
-		} else if (atomic_test_bit(conn->flags,
-					   BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE) &&
+			atomic_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
+		} else if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE) &&
 			   evt->status == BT_HCI_ERR_UNSUPP_LL_PARAM_VAL &&
 			   conn->le.conn_param_retry_countdown) {
 			conn->le.conn_param_retry_countdown--;
 			k_work_schedule(&conn->deferred_work,
 					K_MSEC(CONFIG_BT_CONN_PARAM_RETRY_TIMEOUT));
 		} else {
-			atomic_clear_bit(conn->flags,
-					 BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
+			atomic_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_AUTO_UPDATE);
 #endif /* CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS */
-
 		}
 
 		notify_le_param_updated(conn);
@@ -1990,8 +1936,7 @@ static int set_flow_control(void)
 		return 0;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
-				sizeof(*hbs));
+	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE, sizeof(*hbs));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -2057,8 +2002,7 @@ static void unpair(uint8_t id, const bt_addr_le_t *addr)
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
 	struct bt_conn_auth_info_cb *listener, *next;
 
-	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
-					  next, node) {
+	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 		if (listener->bond_deleted) {
 			listener->bond_deleted(id, addr);
 		}
@@ -2068,7 +2012,7 @@ static void unpair(uint8_t id, const bt_addr_le_t *addr)
 
 static void unpair_remote(const struct bt_bond_info *info, void *data)
 {
-	uint8_t *id = (uint8_t *) data;
+	uint8_t *id = (uint8_t *)data;
 
 	unpair(*id, &info->addr);
 }
@@ -2147,8 +2091,8 @@ static void hci_encrypt_change(struct net_buf *buf)
 	uint8_t status = evt->status;
 	struct bt_conn *conn;
 
-	LOG_DBG("status 0x%02x %s handle %u encrypt 0x%02x",
-		evt->status, bt_hci_err_to_str(evt->status), handle, evt->encrypt);
+	LOG_DBG("status 0x%02x %s handle %u encrypt 0x%02x", evt->status,
+		bt_hci_err_to_str(evt->status), handle, evt->encrypt);
 
 	conn = bt_conn_lookup_handle(handle, BT_CONN_TYPE_ALL);
 	if (!conn) {
@@ -2157,8 +2101,7 @@ static void hci_encrypt_change(struct net_buf *buf)
 	}
 
 	if (status) {
-		bt_conn_security_changed(conn, status,
-					 bt_security_err_get(status));
+		bt_conn_security_changed(conn, status, bt_security_err_get(status));
 		bt_conn_unref(conn);
 		return;
 	}
@@ -2229,8 +2172,7 @@ static void hci_encrypt_key_refresh_complete(struct net_buf *buf)
 
 	handle = sys_le16_to_cpu(evt->handle);
 
-	LOG_DBG("status 0x%02x %s handle %u",
-		evt->status, bt_hci_err_to_str(evt->status), handle);
+	LOG_DBG("status 0x%02x %s handle %u", evt->status, bt_hci_err_to_str(evt->status), handle);
 
 	conn = bt_conn_lookup_handle(handle, BT_CONN_TYPE_ALL);
 	if (!conn) {
@@ -2239,8 +2181,7 @@ static void hci_encrypt_key_refresh_complete(struct net_buf *buf)
 	}
 
 	if (status) {
-		bt_conn_security_changed(conn, status,
-					 bt_security_err_get(status));
+		bt_conn_security_changed(conn, status, bt_security_err_get(status));
 		bt_conn_unref(conn);
 		return;
 	}
@@ -2344,8 +2285,7 @@ static void le_ltk_reply(uint16_t handle, uint8_t *ltk)
 	struct bt_hci_cp_le_ltk_req_reply *cp;
 	struct net_buf *buf;
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_REPLY,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_REPLY, sizeof(*cp));
 	if (!buf) {
 		LOG_ERR("Out of command buffers");
 		return;
@@ -2413,8 +2353,8 @@ static void hci_cmd_done(uint16_t opcode, uint8_t status, struct net_buf *evt_bu
 	/* Original command buffer. */
 	struct net_buf *buf = NULL;
 
-	LOG_DBG("opcode 0x%04x status 0x%02x %s buf %p", opcode,
-		status, bt_hci_err_to_str(status), evt_buf);
+	LOG_DBG("opcode 0x%04x status 0x%02x %s buf %p", opcode, status, bt_hci_err_to_str(status),
+		evt_buf);
 
 	/* Unsolicited cmd complete. This does not complete a command.
 	 * The controller can send these for effect of the `ncmd` field.
@@ -2489,8 +2429,8 @@ static void hci_cmd_complete(struct net_buf *buf)
 	 * The generation of this command ignores `ncmd_sem`, so should not be given here.
 	 */
 	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
-		LOG_WRN("Unexpected HOST_NUM_COMPLETED_PACKETS, status 0x%02x %s",
-			status, bt_hci_err_to_str(status));
+		LOG_WRN("Unexpected HOST_NUM_COMPLETED_PACKETS, status 0x%02x %s", status,
+			bt_hci_err_to_str(status));
 		return;
 	}
 
@@ -2578,7 +2518,7 @@ void bt_hci_le_transmit_power_report(struct net_buf *buf)
 	conn = bt_conn_lookup_handle(sys_le16_to_cpu(evt->handle), BT_CONN_TYPE_LE);
 	if (!conn) {
 		LOG_ERR("Unknown conn handle 0x%04X for transmit power report",
-		       sys_le16_to_cpu(evt->handle));
+			sys_le16_to_cpu(evt->handle));
 		return;
 	}
 
@@ -2604,15 +2544,14 @@ void bt_hci_le_path_loss_threshold_event(struct net_buf *buf)
 	evt = net_buf_pull_mem(buf, sizeof(*evt));
 
 	if (evt->zone_entered > BT_CONN_LE_PATH_LOSS_ZONE_ENTERED_HIGH) {
-		LOG_ERR("Invalid zone %u in bt_hci_evt_le_path_loss_threshold",
-			evt->zone_entered);
+		LOG_ERR("Invalid zone %u in bt_hci_evt_le_path_loss_threshold", evt->zone_entered);
 		return;
 	}
 
 	conn = bt_conn_lookup_handle(sys_le16_to_cpu(evt->handle), BT_CONN_TYPE_LE);
 	if (!conn) {
 		LOG_ERR("Unknown conn handle 0x%04X for path loss threshold report",
-		       sys_le16_to_cpu(evt->handle));
+			sys_le16_to_cpu(evt->handle));
 		return;
 	}
 
@@ -2642,7 +2581,7 @@ void bt_hci_le_subrate_change_event(struct net_buf *buf)
 	conn = bt_conn_lookup_handle(sys_le16_to_cpu(evt->handle), BT_CONN_TYPE_LE);
 	if (!conn) {
 		LOG_ERR("Unknown conn handle 0x%04X for subrating event",
-		       sys_le16_to_cpu(evt->handle));
+			sys_le16_to_cpu(evt->handle));
 		return;
 	}
 
@@ -2735,11 +2674,9 @@ static const struct event_handler meta_events[] = {
 		      sizeof(struct bt_hci_evt_le_conn_complete)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_ENH_CONN_COMPLETE, le_enh_conn_complete,
 		      sizeof(struct bt_hci_evt_le_enh_conn_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE,
-		      le_conn_update_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, le_conn_update_complete,
 		      sizeof(struct bt_hci_evt_le_conn_update_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_REMOTE_FEAT_COMPLETE,
-		      le_remote_feat_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_REMOTE_FEAT_COMPLETE, le_remote_feat_complete,
 		      sizeof(struct bt_hci_evt_le_remote_feat_complete)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_CONN_PARAM_REQ, le_conn_param_req,
 		      sizeof(struct bt_hci_evt_le_conn_param_req)),
@@ -2748,8 +2685,7 @@ static const struct event_handler meta_events[] = {
 		      sizeof(struct bt_hci_evt_le_data_len_change)),
 #endif /* CONFIG_BT_DATA_LEN_UPDATE */
 #if defined(CONFIG_BT_PHY_UPDATE)
-	EVENT_HANDLER(BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE,
-		      le_phy_update_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE, le_phy_update_complete,
 		      sizeof(struct bt_hci_evt_le_phy_update_complete)),
 #endif /* CONFIG_BT_PHY_UPDATE */
 #endif /* CONFIG_BT_CONN */
@@ -2758,11 +2694,9 @@ static const struct event_handler meta_events[] = {
 		      sizeof(struct bt_hci_evt_le_ltk_request)),
 #endif /* CONFIG_BT_SMP */
 #if defined(CONFIG_BT_ECC)
-	EVENT_HANDLER(BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE,
-		      bt_hci_evt_le_pkey_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE, bt_hci_evt_le_pkey_complete,
 		      sizeof(struct bt_hci_evt_le_p256_public_key_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE,
-		      bt_hci_evt_le_dhkey_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE, bt_hci_evt_le_dhkey_complete,
 		      sizeof(struct bt_hci_evt_le_generate_dhkey_complete)),
 #endif /* CONFIG_BT_SMP */
 #if defined(CONFIG_BT_EXT_ADV)
@@ -2773,14 +2707,12 @@ static const struct event_handler meta_events[] = {
 		      sizeof(struct bt_hci_evt_le_scan_req_received)),
 #endif
 #if defined(CONFIG_BT_OBSERVER)
-	EVENT_HANDLER(BT_HCI_EVT_LE_SCAN_TIMEOUT, bt_hci_le_scan_timeout,
-		      0),
+	EVENT_HANDLER(BT_HCI_EVT_LE_SCAN_TIMEOUT, bt_hci_le_scan_timeout, 0),
 	EVENT_HANDLER(BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT, bt_hci_le_adv_ext_report,
 		      sizeof(struct bt_hci_evt_le_ext_advertising_report)),
 #endif /* defined(CONFIG_BT_OBSERVER) */
 #if defined(CONFIG_BT_PER_ADV_SYNC)
-	EVENT_HANDLER(BT_HCI_EVT_LE_PER_ADV_SYNC_ESTABLISHED,
-		      bt_hci_le_per_adv_sync_established,
+	EVENT_HANDLER(BT_HCI_EVT_LE_PER_ADV_SYNC_ESTABLISHED, bt_hci_le_per_adv_sync_established,
 		      sizeof(struct bt_hci_evt_le_per_adv_sync_established)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_PER_ADVERTISING_REPORT, bt_hci_le_per_adv_report,
 		      sizeof(struct bt_hci_evt_le_per_advertising_report)),
@@ -2798,27 +2730,21 @@ static const struct event_handler meta_events[] = {
 	EVENT_HANDLER(BT_HCI_EVT_LE_CIS_ESTABLISHED_V2, hci_le_cis_established_v2,
 		      sizeof(struct bt_hci_evt_le_cis_established_v2)),
 #if defined(CONFIG_BT_ISO_PERIPHERAL)
-	EVENT_HANDLER(BT_HCI_EVT_LE_CIS_REQ, hci_le_cis_req,
-		      sizeof(struct bt_hci_evt_le_cis_req)),
+	EVENT_HANDLER(BT_HCI_EVT_LE_CIS_REQ, hci_le_cis_req, sizeof(struct bt_hci_evt_le_cis_req)),
 #endif /* (CONFIG_BT_ISO_PERIPHERAL) */
 #endif /* (CONFIG_BT_ISO_UNICAST) */
 #if defined(CONFIG_BT_ISO_BROADCASTER)
-	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_COMPLETE,
-		      hci_le_big_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_COMPLETE, hci_le_big_complete,
 		      sizeof(struct bt_hci_evt_le_big_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_TERMINATE,
-		      hci_le_big_terminate,
+	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_TERMINATE, hci_le_big_terminate,
 		      sizeof(struct bt_hci_evt_le_big_terminate)),
 #endif /* CONFIG_BT_ISO_BROADCASTER */
 #if defined(CONFIG_BT_ISO_SYNC_RECEIVER)
-	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_SYNC_ESTABLISHED,
-		      hci_le_big_sync_established,
+	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_SYNC_ESTABLISHED, hci_le_big_sync_established,
 		      sizeof(struct bt_hci_evt_le_big_sync_established)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_SYNC_LOST,
-		      hci_le_big_sync_lost,
+	EVENT_HANDLER(BT_HCI_EVT_LE_BIG_SYNC_LOST, hci_le_big_sync_lost,
 		      sizeof(struct bt_hci_evt_le_big_sync_lost)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_BIGINFO_ADV_REPORT,
-		      bt_hci_le_biginfo_adv_report,
+	EVENT_HANDLER(BT_HCI_EVT_LE_BIGINFO_ADV_REPORT, bt_hci_le_biginfo_adv_report,
 		      sizeof(struct bt_hci_evt_le_biginfo_adv_report)),
 #endif /* CONFIG_BT_ISO_SYNC_RECEIVER */
 #if defined(CONFIG_BT_DF_CONNECTIONLESS_CTE_RX)
@@ -2879,20 +2805,18 @@ static const struct event_handler meta_events[] = {
 	EVENT_HANDLER(BT_HCI_EVT_LE_CS_CONFIG_COMPLETE, bt_hci_le_cs_config_complete_event,
 		      sizeof(struct bt_hci_evt_le_cs_config_complete)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_CS_SECURITY_ENABLE_COMPLETE,
-			  bt_hci_le_cs_security_enable_complete,
-			  sizeof(struct bt_hci_evt_le_cs_security_enable_complete)),
+		      bt_hci_le_cs_security_enable_complete,
+		      sizeof(struct bt_hci_evt_le_cs_security_enable_complete)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_CS_PROCEDURE_ENABLE_COMPLETE,
-			  bt_hci_le_cs_procedure_enable_complete,
-			  sizeof(struct bt_hci_evt_le_cs_procedure_enable_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_LE_CS_SUBEVENT_RESULT,
-		      bt_hci_le_cs_subevent_result,
+		      bt_hci_le_cs_procedure_enable_complete,
+		      sizeof(struct bt_hci_evt_le_cs_procedure_enable_complete)),
+	EVENT_HANDLER(BT_HCI_EVT_LE_CS_SUBEVENT_RESULT, bt_hci_le_cs_subevent_result,
 		      sizeof(struct bt_hci_evt_le_cs_subevent_result)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_CS_SUBEVENT_RESULT_CONTINUE,
 		      bt_hci_le_cs_subevent_result_continue,
 		      sizeof(struct bt_hci_evt_le_cs_subevent_result_continue)),
 #if defined(CONFIG_BT_CHANNEL_SOUNDING_TEST)
-	EVENT_HANDLER(BT_HCI_EVT_LE_CS_TEST_END_COMPLETE,
-		      bt_hci_le_cs_test_end_complete,
+	EVENT_HANDLER(BT_HCI_EVT_LE_CS_TEST_END_COMPLETE, bt_hci_le_cs_test_end_complete,
 		      sizeof(struct bt_hci_evt_le_cs_test_end_complete)),
 #endif /* CONFIG_BT_CHANNEL_SOUNDING_TEST */
 #endif /* CONFIG_BT_CHANNEL_SOUNDING */
@@ -2911,8 +2835,7 @@ static void hci_le_meta_event(struct net_buf *buf)
 }
 
 static const struct event_handler normal_events[] = {
-	EVENT_HANDLER(BT_HCI_EVT_VENDOR, hci_vendor_event,
-		      sizeof(struct bt_hci_evt_vs)),
+	EVENT_HANDLER(BT_HCI_EVT_VENDOR, hci_vendor_event, sizeof(struct bt_hci_evt_vs)),
 	EVENT_HANDLER(BT_HCI_EVT_LE_META_EVENT, hci_le_meta_event,
 		      sizeof(struct bt_hci_evt_le_meta_event)),
 #if defined(CONFIG_BT_CLASSIC)
@@ -2934,29 +2857,23 @@ static const struct event_handler normal_events[] = {
 		      sizeof(struct bt_hci_evt_ssp_complete)),
 	EVENT_HANDLER(BT_HCI_EVT_USER_CONFIRM_REQ, bt_hci_user_confirm_req,
 		      sizeof(struct bt_hci_evt_user_confirm_req)),
-	EVENT_HANDLER(BT_HCI_EVT_USER_PASSKEY_NOTIFY,
-		      bt_hci_user_passkey_notify,
+	EVENT_HANDLER(BT_HCI_EVT_USER_PASSKEY_NOTIFY, bt_hci_user_passkey_notify,
 		      sizeof(struct bt_hci_evt_user_passkey_notify)),
 	EVENT_HANDLER(BT_HCI_EVT_USER_PASSKEY_REQ, bt_hci_user_passkey_req,
 		      sizeof(struct bt_hci_evt_user_passkey_req)),
 	EVENT_HANDLER(BT_HCI_EVT_INQUIRY_COMPLETE, bt_hci_inquiry_complete,
 		      sizeof(struct bt_hci_evt_inquiry_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_INQUIRY_RESULT_WITH_RSSI,
-		      bt_hci_inquiry_result_with_rssi,
+	EVENT_HANDLER(BT_HCI_EVT_INQUIRY_RESULT_WITH_RSSI, bt_hci_inquiry_result_with_rssi,
 		      sizeof(struct bt_hci_evt_inquiry_result_with_rssi)),
-	EVENT_HANDLER(BT_HCI_EVT_EXTENDED_INQUIRY_RESULT,
-		      bt_hci_extended_inquiry_result,
+	EVENT_HANDLER(BT_HCI_EVT_EXTENDED_INQUIRY_RESULT, bt_hci_extended_inquiry_result,
 		      sizeof(struct bt_hci_evt_extended_inquiry_result)),
-	EVENT_HANDLER(BT_HCI_EVT_REMOTE_NAME_REQ_COMPLETE,
-		      bt_hci_remote_name_request_complete,
+	EVENT_HANDLER(BT_HCI_EVT_REMOTE_NAME_REQ_COMPLETE, bt_hci_remote_name_request_complete,
 		      sizeof(struct bt_hci_evt_remote_name_req_complete)),
 	EVENT_HANDLER(BT_HCI_EVT_AUTH_COMPLETE, bt_hci_auth_complete,
 		      sizeof(struct bt_hci_evt_auth_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_REMOTE_FEATURES,
-		      bt_hci_read_remote_features_complete,
+	EVENT_HANDLER(BT_HCI_EVT_REMOTE_FEATURES, bt_hci_read_remote_features_complete,
 		      sizeof(struct bt_hci_evt_remote_features)),
-	EVENT_HANDLER(BT_HCI_EVT_REMOTE_EXT_FEATURES,
-		      bt_hci_read_remote_ext_features_complete,
+	EVENT_HANDLER(BT_HCI_EVT_REMOTE_EXT_FEATURES, bt_hci_read_remote_ext_features_complete,
 		      sizeof(struct bt_hci_evt_remote_ext_features)),
 	EVENT_HANDLER(BT_HCI_EVT_ROLE_CHANGE, bt_hci_role_change,
 		      sizeof(struct bt_hci_evt_role_change)),
@@ -2970,20 +2887,17 @@ static const struct event_handler normal_events[] = {
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
 	EVENT_HANDLER(BT_HCI_EVT_ENCRYPT_CHANGE, hci_encrypt_change,
 		      sizeof(struct bt_hci_evt_encrypt_change)),
-	EVENT_HANDLER(BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE,
-		      hci_encrypt_key_refresh_complete,
+	EVENT_HANDLER(BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE, hci_encrypt_key_refresh_complete,
 		      sizeof(struct bt_hci_evt_encrypt_key_refresh_complete)),
 #endif /* CONFIG_BT_SMP || CONFIG_BT_CLASSIC */
 #if defined(CONFIG_BT_REMOTE_VERSION)
-	EVENT_HANDLER(BT_HCI_EVT_REMOTE_VERSION_INFO,
-		      bt_hci_evt_read_remote_version_complete,
+	EVENT_HANDLER(BT_HCI_EVT_REMOTE_VERSION_INFO, bt_hci_evt_read_remote_version_complete,
 		      sizeof(struct bt_hci_evt_remote_version_info)),
 #endif /* CONFIG_BT_REMOTE_VERSION */
 	EVENT_HANDLER(BT_HCI_EVT_HARDWARE_ERROR, hci_hardware_error,
 		      sizeof(struct bt_hci_evt_hardware_error)),
 };
 
-
 #define BT_HCI_EVT_FLAG_RECV_PRIO BIT(0)
 #define BT_HCI_EVT_FLAG_RECV      BIT(1)
 
@@ -3209,8 +3123,7 @@ static void read_supported_commands_complete(struct net_buf *buf)
 
 	LOG_DBG("status 0x%02x %s", rp->status, bt_hci_err_to_str(rp->status));
 
-	memcpy(bt_dev.supported_commands, rp->commands,
-	       sizeof(bt_dev.supported_commands));
+	memcpy(bt_dev.supported_commands, rp->commands, sizeof(bt_dev.supported_commands));
 
 	/* Report additional HCI commands used for ECDH as
 	 * supported if PSA Crypto API ECC is used for emulation.
@@ -3284,8 +3197,7 @@ static int common_init(void)
 	net_buf_unref(rsp);
 
 	/* Read Local Version Information */
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
-				   &rsp);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL, &rsp);
 	if (err) {
 		return err;
 	}
@@ -3293,8 +3205,7 @@ static int common_init(void)
 	net_buf_unref(rsp);
 
 	/* Read Local Supported Commands */
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
-				   &rsp);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL, &rsp);
 	if (err) {
 		return err;
 	}
@@ -3337,8 +3248,7 @@ static int le_set_event_mask(void)
 
 	mask |= BT_EVT_MASK_LE_ADVERTISING_REPORT;
 
-	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		mask |= BT_EVT_MASK_LE_ADV_SET_TERMINATED;
 		mask |= BT_EVT_MASK_LE_SCAN_REQ_RECEIVED;
 		mask |= BT_EVT_MASK_LE_EXT_ADVERTISING_REPORT;
@@ -3352,10 +3262,8 @@ static int le_set_event_mask(void)
 	}
 
 	if (IS_ENABLED(CONFIG_BT_CONN)) {
-		if ((IS_ENABLED(CONFIG_BT_SMP) &&
-		     BT_FEAT_LE_PRIVACY(bt_dev.le.features)) ||
-		    (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-		     BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+		if ((IS_ENABLED(CONFIG_BT_SMP) && BT_FEAT_LE_PRIVACY(bt_dev.le.features)) ||
+		    (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 			/* C24:
 			 * Mandatory if the LE Controller supports Connection
 			 * State and either LE Feature (LL Privacy) or
@@ -3373,8 +3281,7 @@ static int le_set_event_mask(void)
 			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
 		}
 
-		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
-		    BT_FEAT_LE_DLE(bt_dev.le.features)) {
+		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) && BT_FEAT_LE_DLE(bt_dev.le.features)) {
 			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
 		}
 
@@ -3397,8 +3304,7 @@ static int le_set_event_mask(void)
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP) &&
-	    BT_FEAT_LE_ENCR(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_SMP) && BT_FEAT_LE_ENCR(bt_dev.le.features)) {
 		mask |= BT_EVT_MASK_LE_LTK_REQUEST;
 	}
 
@@ -3406,8 +3312,7 @@ static int le_set_event_mask(void)
 	 * If "LE Read Local P-256 Public Key" and "LE Generate DH Key" are
 	 * supported we need to enable events generated by those commands.
 	 */
-	if (IS_ENABLED(CONFIG_BT_ECC) &&
-	    (BT_CMD_TEST(bt_dev.supported_commands, 34, 1)) &&
+	if (IS_ENABLED(CONFIG_BT_ECC) && (BT_CMD_TEST(bt_dev.supported_commands, 34, 1)) &&
 	    (BT_CMD_TEST(bt_dev.supported_commands, 34, 2))) {
 		mask |= BT_EVT_MASK_LE_P256_PUBLIC_KEY_COMPLETE;
 		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
@@ -3417,8 +3322,7 @@ static int le_set_event_mask(void)
 	 * Enable CIS events only if ISO connections are enabled and controller
 	 * support them.
 	 */
-	if (IS_ENABLED(CONFIG_BT_ISO) &&
-	    BT_FEAT_LE_CIS(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_ISO) && BT_FEAT_LE_CIS(bt_dev.le.features)) {
 		mask |= BT_EVT_MASK_LE_CIS_ESTABLISHED;
 		mask |= BT_EVT_MASK_LE_CIS_ESTABLISHED_V2;
 		if (BT_FEAT_LE_CIS_PERIPHERAL(bt_dev.le.features)) {
@@ -3467,7 +3371,6 @@ static int le_set_event_mask(void)
 		mask |= BT_EVT_MASK_LE_ENH_CONN_COMPLETE_V2;
 	}
 
-
 	if (IS_ENABLED(CONFIG_BT_CHANNEL_SOUNDING) &&
 	    BT_FEAT_LE_CHANNEL_SOUNDING(bt_dev.le.features)) {
 		mask |= BT_EVT_MASK_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE;
@@ -3500,8 +3403,7 @@ static int le_init_iso(void)
 	/* Octet 41, bit 5 is read buffer size V2 */
 	if (BT_CMD_TEST(bt_dev.supported_commands, 41, 5)) {
 		/* Read ISO Buffer Size V2 */
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE_V2,
-					   NULL, &rsp);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE_V2, NULL, &rsp);
 		if (err) {
 			return err;
 		}
@@ -3518,8 +3420,7 @@ static int le_init_iso(void)
 		/* Read LE Buffer Size in the case that we support ACL without TX ISO (e.g. if we
 		 * only support ISO sync receiver).
 		 */
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
-					   NULL, &rsp);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE, NULL, &rsp);
 		if (err) {
 			return err;
 		}
@@ -3545,8 +3446,7 @@ static int le_init(void)
 	}
 
 	/* Read Low Energy Supported Features */
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
-				   &rsp);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL, &rsp);
 	if (err) {
 		return err;
 	}
@@ -3554,16 +3454,14 @@ static int le_init(void)
 	read_le_features_complete(rsp);
 	net_buf_unref(rsp);
 
-	if (IS_ENABLED(CONFIG_BT_ISO) &&
-	    BT_FEAT_LE_ISO(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_ISO) && BT_FEAT_LE_ISO(bt_dev.le.features)) {
 		err = le_init_iso();
 		if (err) {
 			return err;
 		}
 	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
 		/* Read LE Buffer Size */
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
-					   NULL, &rsp);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE, NULL, &rsp);
 		if (err) {
 			return err;
 		}
@@ -3593,8 +3491,7 @@ static int le_init(void)
 #endif /* CONFIG_BT_BROADCASTER */
 
 	if (BT_FEAT_BREDR(bt_dev.features)) {
-		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
-					sizeof(*cp_le));
+		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, sizeof(*cp_le));
 		if (!buf) {
 			return -ENOBUFS;
 		}
@@ -3604,8 +3501,7 @@ static int le_init(void)
 		/* Explicitly enable LE for dual-mode controllers */
 		cp_le->le = 0x01;
 		cp_le->simul = 0x00;
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
-					   NULL);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf, NULL);
 		if (err) {
 			return err;
 		}
@@ -3613,8 +3509,7 @@ static int le_init(void)
 
 	/* Read LE Supported States */
 	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
-					   &rsp);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL, &rsp);
 		if (err) {
 			return err;
 		}
@@ -3623,10 +3518,8 @@ static int le_init(void)
 		net_buf_unref(rsp);
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CONN) &&
-	    IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
-	    IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
-	    BT_FEAT_LE_DLE(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_CONN) && IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
+	    IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) && BT_FEAT_LE_DLE(bt_dev.le.features)) {
 		struct bt_hci_cp_le_write_default_data_len *cp;
 		uint16_t tx_octets, tx_time;
 
@@ -3635,8 +3528,7 @@ static int le_init(void)
 			return err;
 		}
 
-		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
-					sizeof(*cp));
+		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN, sizeof(*cp));
 		if (!buf) {
 			return -ENOBUFS;
 		}
@@ -3645,8 +3537,7 @@ static int le_init(void)
 		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
 		cp->max_tx_time = sys_cpu_to_le16(tx_time);
 
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
-					   buf, NULL);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN, buf, NULL);
 		if (err) {
 			return err;
 		}
@@ -3657,23 +3548,20 @@ static int le_init(void)
 #if defined(CONFIG_BT_PRIVACY)
 		struct bt_hci_cp_le_set_rpa_timeout *cp;
 
-		buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RPA_TIMEOUT,
-					sizeof(*cp));
+		buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RPA_TIMEOUT, sizeof(*cp));
 		if (!buf) {
 			return -ENOBUFS;
 		}
 
 		cp = net_buf_add(buf, sizeof(*cp));
 		cp->rpa_timeout = sys_cpu_to_le16(bt_dev.rpa_timeout);
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RPA_TIMEOUT, buf,
-					   NULL);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RPA_TIMEOUT, buf, NULL);
 		if (err) {
 			return err;
 		}
 #endif /* defined(CONFIG_BT_PRIVACY) */
 
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_RL_SIZE, NULL,
-					   &rsp);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_RL_SIZE, NULL, &rsp);
 		if (err) {
 			return err;
 		}
@@ -3693,8 +3581,7 @@ static int le_init(void)
 	}
 #endif /* CONFIG_BT_DF */
 
-	if (IS_ENABLED(CONFIG_BT_SUBRATING) &&
-	    BT_FEAT_LE_CONN_SUBRATING(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_SUBRATING) && BT_FEAT_LE_CONN_SUBRATING(bt_dev.le.features)) {
 		/* Connection Subrating (Host Support) */
 		err = le_set_host_feature(BT_LE_FEAT_BIT_CONN_SUBRATING_HOST_SUPP, 1);
 		if (err) {
@@ -3710,7 +3597,7 @@ static int le_init(void)
 		}
 	}
 
-	return  le_set_event_mask();
+	return le_set_event_mask();
 }
 
 #if !defined(CONFIG_BT_CLASSIC)
@@ -3786,8 +3673,7 @@ static int set_event_mask(void)
 		mask |= BT_EVT_MASK_REMOTE_VERSION_INFO;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP) &&
-	    BT_FEAT_LE_ENCR(bt_dev.le.features)) {
+	if (IS_ENABLED(CONFIG_BT_SMP) && BT_FEAT_LE_ENCR(bt_dev.le.features)) {
 		mask |= BT_EVT_MASK_ENCRYPT_CHANGE;
 		mask |= BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE;
 	}
@@ -3798,10 +3684,8 @@ static int set_event_mask(void)
 
 const char *bt_hci_get_ver_str(uint8_t core_version)
 {
-	const char * const str[] = {
-		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
-		"5.0", "5.1", "5.2", "5.3", "5.4", "6.0"
-	};
+	const char *const str[] = {"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1",
+				   "4.2",  "5.0", "5.1", "5.2", "5.3", "5.4", "6.0"};
 
 	if (core_version < ARRAY_SIZE(str)) {
 		return str[core_version];
@@ -3839,8 +3723,7 @@ static void bt_dev_show_info(void)
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP) &&
-	    IS_ENABLED(CONFIG_BT_LOG_SNIFFER_INFO)) {
+	if (IS_ENABLED(CONFIG_BT_SMP) && IS_ENABLED(CONFIG_BT_LOG_SNIFFER_INFO)) {
 		bt_keys_foreach_type(BT_KEYS_ALL, bt_keys_show_sniffer_info, NULL);
 	}
 
@@ -3854,9 +3737,8 @@ static void bt_dev_show_info(void)
 #if defined(CONFIG_BT_HCI_VS)
 static const char *vs_hw_platform(uint16_t platform)
 {
-	static const char * const plat_str[] = {
-		"reserved", "Intel Corporation", "Nordic Semiconductor",
-		"NXP Semiconductors" };
+	static const char *const plat_str[] = {"reserved", "Intel Corporation",
+					       "Nordic Semiconductor", "NXP Semiconductors"};
 
 	if (platform < ARRAY_SIZE(plat_str)) {
 		return plat_str[platform];
@@ -3867,9 +3749,8 @@ static const char *vs_hw_platform(uint16_t platform)
 
 static const char *vs_hw_variant(uint16_t platform, uint16_t variant)
 {
-	static const char * const nordic_str[] = {
-		"reserved", "nRF51x", "nRF52x", "nRF53x", "nRF54Hx", "nRF54Lx"
-	};
+	static const char *const nordic_str[] = {"reserved", "nRF51x",  "nRF52x",
+						 "nRF53x",   "nRF54Hx", "nRF54Lx"};
 
 	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
 		return "unknown";
@@ -3884,7 +3765,7 @@ static const char *vs_hw_variant(uint16_t platform, uint16_t variant)
 
 static const char *vs_fw_variant(uint8_t variant)
 {
-	static const char * const var_str[] = {
+	static const char *const var_str[] = {
 		"Standard Bluetooth controller",
 		"Vendor specific controller",
 		"Firmware loader",
@@ -3915,8 +3796,7 @@ static void hci_vs_init(void)
 	if (IS_ENABLED(CONFIG_BT_HCI_VS_EXT_DETECT)) {
 		bt_addr_le_t addr;
 
-		if ((bt_dev.hci_version < BT_HCI_VERSION_5_0) ||
-		    bt_id_read_public_addr(&addr)) {
+		if ((bt_dev.hci_version < BT_HCI_VERSION_5_0) || bt_id_read_public_addr(&addr)) {
 			LOG_WRN("Controller doesn't seem to support "
 				"Zephyr vendor HCI");
 			return;
@@ -3949,8 +3829,7 @@ static void hci_vs_init(void)
 
 	net_buf_unref(rsp);
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
-				   NULL, &rsp);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS, NULL, &rsp);
 	if (err) {
 		LOG_WRN("Failed to read supported vendor commands");
 		return;
@@ -3968,24 +3847,21 @@ static void hci_vs_init(void)
 	net_buf_unref(rsp);
 
 	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
-		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
-					   NULL, &rsp);
+		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES, NULL, &rsp);
 		if (err) {
 			LOG_WRN("Failed to read supported vendor features");
 			return;
 		}
 
 		if (IS_ENABLED(CONFIG_BT_HCI_VS_EXT_DETECT) &&
-		    rsp->len !=
-		    sizeof(struct bt_hci_rp_vs_read_supported_features)) {
+		    rsp->len != sizeof(struct bt_hci_rp_vs_read_supported_features)) {
 			LOG_WRN("Invalid Vendor HCI extensions");
 			net_buf_unref(rsp);
 			return;
 		}
 
 		rp.feat = (void *)rsp->data;
-		memcpy(bt_dev.vs_features, rp.feat->features,
-		       BT_DEV_VS_FEAT_MAX);
+		memcpy(bt_dev.vs_features, rp.feat->features, BT_DEV_VS_FEAT_MAX);
 		net_buf_unref(rsp);
 	}
 }
@@ -3996,7 +3872,7 @@ static int hci_init(void)
 	int err;
 
 #if defined(CONFIG_BT_HCI_SETUP)
-	struct bt_hci_setup_params setup_params = { 0 };
+	struct bt_hci_setup_params setup_params = {0};
 
 	bt_addr_copy(&setup_params.public_addr, BT_ADDR_ANY);
 #if defined(CONFIG_BT_HCI_SET_PUBLIC_ADDR)
@@ -4069,18 +3945,15 @@ int bt_send(struct net_buf *buf)
 static const struct event_handler prio_events[] = {
 	EVENT_HANDLER(BT_HCI_EVT_CMD_COMPLETE, hci_cmd_complete,
 		      sizeof(struct bt_hci_evt_cmd_complete)),
-	EVENT_HANDLER(BT_HCI_EVT_CMD_STATUS, hci_cmd_status,
-		      sizeof(struct bt_hci_evt_cmd_status)),
+	EVENT_HANDLER(BT_HCI_EVT_CMD_STATUS, hci_cmd_status, sizeof(struct bt_hci_evt_cmd_status)),
 #if defined(CONFIG_BT_CONN)
-	EVENT_HANDLER(BT_HCI_EVT_DATA_BUF_OVERFLOW,
-		      hci_data_buf_overflow,
+	EVENT_HANDLER(BT_HCI_EVT_DATA_BUF_OVERFLOW, hci_data_buf_overflow,
 		      sizeof(struct bt_hci_evt_data_buf_overflow)),
 	EVENT_HANDLER(BT_HCI_EVT_DISCONN_COMPLETE, hci_disconn_complete_prio,
 		      sizeof(struct bt_hci_evt_disconn_complete)),
 #endif /* CONFIG_BT_CONN */
 #if defined(CONFIG_BT_CONN_TX)
-	EVENT_HANDLER(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
-		      hci_num_completed_packets,
+	EVENT_HANDLER(BT_HCI_EVT_NUM_COMPLETED_PACKETS, hci_num_completed_packets,
 		      sizeof(struct bt_hci_evt_num_completed_packets)),
 #endif /* CONFIG_BT_CONN_TX */
 };
@@ -4138,8 +4011,7 @@ static int bt_recv_unsafe(struct net_buf *buf)
 		rx_queue_put(buf);
 		return 0;
 #endif /* BT_CONN */
-	case BT_BUF_EVT:
-	{
+	case BT_BUF_EVT: {
 		struct bt_hci_evt_hdr *hdr = (void *)buf->data;
 		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
 
@@ -4351,8 +4223,7 @@ int bt_enable(bt_ready_cb_t cb)
 #if defined(CONFIG_BT_RECV_WORKQ_BT)
 	/* RX thread */
 	k_work_queue_init(&bt_workq);
-	k_work_queue_start(&bt_workq, rx_thread_stack,
-			   CONFIG_BT_RX_STACK_SIZE,
+	k_work_queue_start(&bt_workq, rx_thread_stack, CONFIG_BT_RX_STACK_SIZE,
 			   K_PRIO_COOP(CONFIG_BT_RX_PRIO), NULL);
 	k_thread_name_set(&bt_workq.thread, "BT RX WQ");
 #endif
@@ -4632,8 +4503,7 @@ int bt_le_set_chan_map(uint8_t chan_map[5])
 		return -ENOTSUP;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -4643,8 +4513,7 @@ int bt_le_set_chan_map(uint8_t chan_map[5])
 	memcpy(&cp->ch_map[0], &chan_map[0], 4);
 	cp->ch_map[4] = chan_map[4] & BIT_MASK(5);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
-				    buf, NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF, buf, NULL);
 }
 
 #if defined(CONFIG_BT_RPA_TIMEOUT_DYNAMIC)
@@ -4665,8 +4534,7 @@ int bt_le_set_rpa_timeout(uint16_t new_rpa_timeout)
 }
 #endif
 
-int bt_configure_data_path(uint8_t dir, uint8_t id, uint8_t vs_config_len,
-			   const uint8_t *vs_config)
+int bt_configure_data_path(uint8_t dir, uint8_t id, uint8_t vs_config_len, const uint8_t *vs_config)
 {
 	struct bt_hci_rp_configure_data_path *rp;
 	struct bt_hci_cp_configure_data_path *cp;
@@ -4674,15 +4542,14 @@ int bt_configure_data_path(uint8_t dir, uint8_t id, uint8_t vs_config_len,
 	struct net_buf *buf;
 	int err;
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_CONFIGURE_DATA_PATH, sizeof(*cp) +
-				vs_config_len);
+	buf = bt_hci_cmd_create(BT_HCI_OP_CONFIGURE_DATA_PATH, sizeof(*cp) + vs_config_len);
 	if (!buf) {
 		return -ENOBUFS;
 	}
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	cp->data_path_dir = dir;
-	cp->data_path_id  = id;
+	cp->data_path_id = id;
 	cp->vs_config_len = vs_config_len;
 	if (vs_config_len) {
 		(void)memcpy(cp->vs_config, vs_config, vs_config_len);
diff --git a/subsys/bluetooth/host/hci_core.h b/subsys/bluetooth/host/hci_core.h
index ac2bf9d2970..cafdadd7309 100644
--- a/subsys/bluetooth/host/hci_core.h
+++ b/subsys/bluetooth/host/hci_core.h
@@ -10,17 +10,17 @@
 #include <zephyr/devicetree.h>
 
 /* LL connection parameters */
-#define LE_CONN_LATENCY		0x0000
-#define LE_CONN_TIMEOUT		0x002a
+#define LE_CONN_LATENCY 0x0000
+#define LE_CONN_TIMEOUT 0x002a
 
 #if defined(CONFIG_BT_CLASSIC)
-#define LMP_FEAT_PAGES_COUNT	3
+#define LMP_FEAT_PAGES_COUNT 3
 #else
-#define LMP_FEAT_PAGES_COUNT	1
+#define LMP_FEAT_PAGES_COUNT 1
 #endif
 
 /* SCO  settings */
-#define BT_VOICE_CVSD_16BIT     0x0060
+#define BT_VOICE_CVSD_16BIT 0x0060
 
 /* k_poll event tags */
 enum {
@@ -82,15 +82,14 @@ enum {
 };
 
 /* Flags which should not be cleared upon HCI_Reset */
-#define BT_DEV_PERSISTENT_FLAGS (BIT(BT_DEV_ENABLE) | \
-				 BIT(BT_DEV_PRESET_ID))
+#define BT_DEV_PERSISTENT_FLAGS (BIT(BT_DEV_ENABLE) | BIT(BT_DEV_PRESET_ID))
 
 #if defined(CONFIG_BT_EXT_ADV_LEGACY_SUPPORT)
 /* Check the feature bit for extended or legacy advertising commands */
 #define BT_DEV_FEAT_LE_EXT_ADV(feat) BT_FEAT_LE_EXT_ADV(feat)
 #else
 /* Always use extended advertising commands. */
-#define BT_DEV_FEAT_LE_EXT_ADV(feat)  1
+#define BT_DEV_FEAT_LE_EXT_ADV(feat) 1
 #endif
 
 enum {
@@ -157,16 +156,16 @@ enum {
 
 struct bt_le_ext_adv {
 	/* ID Address used for advertising */
-	uint8_t                 id;
+	uint8_t id;
 
 	/* Advertising handle */
-	uint8_t                 handle;
+	uint8_t handle;
 
 	/* Current local Random Address */
-	bt_addr_le_t            random_addr;
+	bt_addr_le_t random_addr;
 
 	/* Current target address */
-	bt_addr_le_t            target_addr;
+	bt_addr_le_t target_addr;
 
 	ATOMIC_DEFINE(flags, BT_ADV_NUM_FLAGS);
 
@@ -174,10 +173,10 @@ struct bt_le_ext_adv {
 	const struct bt_le_ext_adv_cb *cb;
 
 	/* TX Power in use by the controller */
-	int8_t                    tx_power;
+	int8_t tx_power;
 #endif /* defined(CONFIG_BT_EXT_ADV) */
 
-	struct k_work_delayable	lim_adv_timeout_work;
+	struct k_work_delayable lim_adv_timeout_work;
 
 	/** The options used to set the parameters for this advertising set
 	 * @ref bt_le_adv_param
@@ -272,21 +271,21 @@ struct bt_le_per_adv_sync {
 
 struct bt_dev_le {
 	/* LE features */
-	uint8_t			features[8];
+	uint8_t features[8];
 	/* LE states */
-	uint64_t			states;
+	uint64_t states;
 
 #if defined(CONFIG_BT_CONN)
 	/* Controller buffer information */
-	uint16_t		mtu;
-	struct k_sem		pkts;
-	uint16_t		acl_mtu;
-	struct k_sem		acl_pkts;
+	uint16_t mtu;
+	struct k_sem pkts;
+	uint16_t acl_mtu;
+	struct k_sem acl_pkts;
 #endif /* CONFIG_BT_CONN */
 #if defined(CONFIG_BT_ISO)
-	uint16_t		iso_mtu;
-	uint8_t			iso_limit;
-	struct k_sem		iso_pkts;
+	uint16_t iso_mtu;
+	uint8_t iso_limit;
+	struct k_sem iso_pkts;
 #endif /* CONFIG_BT_ISO */
 #if defined(CONFIG_BT_BROADCASTER)
 	uint16_t max_adv_data_len;
@@ -294,26 +293,26 @@ struct bt_dev_le {
 
 #if defined(CONFIG_BT_SMP)
 	/* Size of the controller resolving list */
-	uint8_t                    rl_size;
+	uint8_t rl_size;
 	/* Number of entries in the resolving list. rl_entries > rl_size
 	 * means that host-side resolving is used.
 	 */
-	uint8_t                    rl_entries;
+	uint8_t rl_entries;
 #endif /* CONFIG_BT_SMP */
 	/* List of `struct bt_conn` that have either pending data to send, or
 	 * something to process (e.g. a disconnection event).
 	 *
 	 * Each element in this list contains a reference to its `conn` object.
 	 */
-	sys_slist_t		conn_ready;
+	sys_slist_t conn_ready;
 };
 
 #if defined(CONFIG_BT_CLASSIC)
 struct bt_dev_br {
 	/* Max controller's acceptable ACL packet length */
-	uint16_t         mtu;
-	struct k_sem  pkts;
-	uint16_t         esco_pkt_type;
+	uint16_t mtu;
+	struct k_sem pkts;
+	uint16_t esco_pkt_type;
 };
 #endif
 
@@ -322,23 +321,23 @@ struct bt_dev_br {
  * These values must be updated whenever the host implementation is
  * extended beyond the current values.
  */
-#define BT_DEV_VS_FEAT_MAX  1
-#define BT_DEV_VS_CMDS_MAX  2
+#define BT_DEV_VS_FEAT_MAX 1
+#define BT_DEV_VS_CMDS_MAX 2
 
 /* State tracking for the local Bluetooth controller */
 struct bt_dev {
 	/* Local Identity Address(es) */
-	bt_addr_le_t            id_addr[CONFIG_BT_ID_MAX];
-	uint8_t                    id_count;
+	bt_addr_le_t id_addr[CONFIG_BT_ID_MAX];
+	uint8_t id_count;
 
 	struct bt_conn_le_create_param create_param;
 
 #if !defined(CONFIG_BT_EXT_ADV)
 	/* Legacy advertiser */
-	struct bt_le_ext_adv    adv;
+	struct bt_le_ext_adv adv;
 #else
 	/* Pointer to reserved advertising set */
-	struct bt_le_ext_adv    *adv;
+	struct bt_le_ext_adv *adv;
 #if defined(CONFIG_BT_CONN) && (CONFIG_BT_EXT_ADV_MAX_ADV_SET > 1)
 	/* When supporting multiple concurrent connectable advertising sets
 	 * with multiple identities, we need to know the identity of
@@ -352,66 +351,65 @@ struct bt_dev {
 	struct {
 		bool valid;
 		struct bt_hci_evt_le_enh_conn_complete evt;
-	} cached_conn_complete[MIN(CONFIG_BT_MAX_CONN,
-				CONFIG_BT_EXT_ADV_MAX_ADV_SET)];
+	} cached_conn_complete[MIN(CONFIG_BT_MAX_CONN, CONFIG_BT_EXT_ADV_MAX_ADV_SET)];
 #endif
 #endif
 	/* Current local Random Address */
-	bt_addr_le_t            random_addr;
-	uint8_t                    adv_conn_id;
+	bt_addr_le_t random_addr;
+	uint8_t adv_conn_id;
 
 	/* Controller version & manufacturer information */
-	uint8_t			hci_version;
-	uint8_t			lmp_version;
-	uint16_t			hci_revision;
-	uint16_t			lmp_subversion;
-	uint16_t			manufacturer;
+	uint8_t hci_version;
+	uint8_t lmp_version;
+	uint16_t hci_revision;
+	uint16_t lmp_subversion;
+	uint16_t manufacturer;
 
 	/* LMP features (pages 0, 1, 2) */
-	uint8_t			features[LMP_FEAT_PAGES_COUNT][8];
+	uint8_t features[LMP_FEAT_PAGES_COUNT][8];
 
 	/* Supported commands */
-	uint8_t			supported_commands[64];
+	uint8_t supported_commands[64];
 
 #if defined(CONFIG_BT_HCI_VS)
 	/* Vendor HCI support */
-	uint8_t                    vs_features[BT_DEV_VS_FEAT_MAX];
-	uint8_t                    vs_commands[BT_DEV_VS_CMDS_MAX];
+	uint8_t vs_features[BT_DEV_VS_FEAT_MAX];
+	uint8_t vs_commands[BT_DEV_VS_CMDS_MAX];
 #endif
 
-	struct k_work           init;
+	struct k_work init;
 
 	ATOMIC_DEFINE(flags, BT_DEV_NUM_FLAGS);
 
 	/* LE controller specific features */
-	struct bt_dev_le	le;
+	struct bt_dev_le le;
 
 #if defined(CONFIG_BT_CLASSIC)
 	/* BR/EDR controller specific features */
-	struct bt_dev_br	br;
+	struct bt_dev_br br;
 #endif
 
 	/* Number of commands controller can accept */
-	struct k_sem		ncmd_sem;
+	struct k_sem ncmd_sem;
 
 	/* Last sent HCI command */
-	struct net_buf		*sent_cmd;
+	struct net_buf *sent_cmd;
 
 	/* Queue for incoming HCI events & ACL data */
 	sys_slist_t rx_queue;
 
 	/* Queue for outgoing HCI commands */
-	struct k_fifo		cmd_tx_queue;
+	struct k_fifo cmd_tx_queue;
 
 	const struct device *hci;
 
 #if defined(CONFIG_BT_PRIVACY)
 	/* Local Identity Resolving Key */
-	uint8_t			irk[CONFIG_BT_ID_MAX][16];
+	uint8_t irk[CONFIG_BT_ID_MAX][16];
 
 #if defined(CONFIG_BT_RPA_SHARING)
 	/* Only 1 RPA per identity */
-	bt_addr_t		rpa[CONFIG_BT_ID_MAX];
+	bt_addr_t rpa[CONFIG_BT_ID_MAX];
 #endif
 
 	/* Work used for RPA rotation */
@@ -423,11 +421,11 @@ struct bt_dev {
 
 	/* Local Name */
 #if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
-	char			name[CONFIG_BT_DEVICE_NAME_MAX + 1];
+	char name[CONFIG_BT_DEVICE_NAME_MAX + 1];
 #endif
 #if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
 	/* Appearance Value */
-	uint16_t		appearance;
+	uint16_t appearance;
 #endif
 };
 
@@ -453,16 +451,15 @@ struct bt_hci_cmd_state_set {
 };
 
 /* Set command state related with the command buffer */
-void bt_hci_cmd_state_set_init(struct net_buf *buf,
-			       struct bt_hci_cmd_state_set *state,
+void bt_hci_cmd_state_set_init(struct net_buf *buf, struct bt_hci_cmd_state_set *state,
 			       atomic_t *target, int bit, bool val);
 
 int bt_hci_disconnect(uint16_t handle, uint8_t reason);
 
 bool bt_le_conn_params_valid(const struct bt_le_conn_param *param);
 int bt_le_set_data_len(struct bt_conn *conn, uint16_t tx_octets, uint16_t tx_time);
-int bt_le_set_phy(struct bt_conn *conn, uint8_t all_phys,
-		  uint8_t pref_tx_phy, uint8_t pref_rx_phy, uint8_t phy_opts);
+int bt_le_set_phy(struct bt_conn *conn, uint8_t all_phys, uint8_t pref_tx_phy, uint8_t pref_rx_phy,
+		  uint8_t phy_opts);
 uint8_t bt_get_phy(uint8_t hci_phy);
 /**
  * @brief Convert CTE type value from HCI format to @ref bt_df_cte_type format.
@@ -549,7 +546,6 @@ void bt_hci_le_scan_req_received(struct net_buf *buf);
 void bt_hci_conn_req(struct net_buf *buf);
 void bt_hci_conn_complete(struct net_buf *buf);
 
-
 void bt_hci_inquiry_complete(struct net_buf *buf);
 void bt_hci_inquiry_result_with_rssi(struct net_buf *buf);
 void bt_hci_extended_inquiry_result(struct net_buf *buf);
diff --git a/subsys/bluetooth/host/hci_ecc.c b/subsys/bluetooth/host/hci_ecc.c
index de9440e2d5e..455060d37a1 100644
--- a/subsys/bluetooth/host/hci_ecc.c
+++ b/subsys/bluetooth/host/hci_ecc.c
@@ -44,10 +44,9 @@ K_WORK_DEFINE(ecc_work, ecc_process);
 
 /* based on Core Specification 4.2 Vol 3. Part H 2.3.5.6.1 */
 static const uint8_t debug_private_key_be[BT_PRIV_KEY_LEN] = {
-	0x3f, 0x49, 0xf6, 0xd4, 0xa3, 0xc5, 0x5f, 0x38,
-	0x74, 0xc9, 0xb3, 0xe3, 0xd2, 0x10, 0x3f, 0x50,
-	0x4a, 0xff, 0x60, 0x7b, 0xeb, 0x40, 0xb7, 0x99,
-	0x58, 0x99, 0xb8, 0xa6, 0xcd, 0x3c, 0x1a, 0xbd,
+	0x3f, 0x49, 0xf6, 0xd4, 0xa3, 0xc5, 0x5f, 0x38, 0x74, 0xc9, 0xb3,
+	0xe3, 0xd2, 0x10, 0x3f, 0x50, 0x4a, 0xff, 0x60, 0x7b, 0xeb, 0x40,
+	0xb7, 0x99, 0x58, 0x99, 0xb8, 0xa6, 0xcd, 0x3c, 0x1a, 0xbd,
 };
 
 enum {
@@ -116,8 +115,8 @@ static uint8_t generate_keys(void)
 		return BT_HCI_ERR_UNSPECIFIED;
 	}
 
-	if (psa_export_public_key(key_id, tmp_pub_key_buf, sizeof(tmp_pub_key_buf),
-				&tmp_len) != PSA_SUCCESS) {
+	if (psa_export_public_key(key_id, tmp_pub_key_buf, sizeof(tmp_pub_key_buf), &tmp_len) !=
+	    PSA_SUCCESS) {
 		LOG_ERR("Failed to export ECC public key");
 		return BT_HCI_ERR_UNSPECIFIED;
 	}
@@ -127,8 +126,7 @@ static uint8_t generate_keys(void)
 	 */
 	memcpy(ecc.public_key_be, &tmp_pub_key_buf[1], BT_PUB_KEY_LEN);
 
-	if (psa_export_key(key_id, ecc.private_key_be, BT_PRIV_KEY_LEN,
-			&tmp_len) != PSA_SUCCESS) {
+	if (psa_export_key(key_id, ecc.private_key_be, BT_PRIV_KEY_LEN, &tmp_len) != PSA_SUCCESS) {
 		LOG_ERR("Failed to export ECC private key");
 		return BT_HCI_ERR_UNSPECIFIED;
 	}
@@ -195,22 +193,21 @@ static void emulate_le_generate_dhkey(void)
 	/* PSA expects secp256r1 public key to start with a predefined 0x04 byte
 	 * at the beginning the buffer.
 	 */
-	uint8_t tmp_pub_key_buf[BT_PUB_KEY_LEN + 1] = { 0x04 };
+	uint8_t tmp_pub_key_buf[BT_PUB_KEY_LEN + 1] = {0x04};
 	size_t tmp_len;
 
 	set_key_attributes(&attr);
 
 	if (psa_import_key(&attr, use_debug ? debug_private_key_be : ecc.private_key_be,
-				BT_PRIV_KEY_LEN, &key_id) != PSA_SUCCESS) {
+			   BT_PRIV_KEY_LEN, &key_id) != PSA_SUCCESS) {
 		ret = -EIO;
 		LOG_ERR("Failed to import the private key for key agreement");
 		goto exit;
 	}
 
 	memcpy(&tmp_pub_key_buf[1], ecc.public_key_be, BT_PUB_KEY_LEN);
-	if (psa_raw_key_agreement(PSA_ALG_ECDH, key_id, tmp_pub_key_buf,
-				sizeof(tmp_pub_key_buf), ecc.dhkey_be, BT_DH_KEY_LEN,
-				&tmp_len) != PSA_SUCCESS) {
+	if (psa_raw_key_agreement(PSA_ALG_ECDH, key_id, tmp_pub_key_buf, sizeof(tmp_pub_key_buf),
+				  ecc.dhkey_be, BT_DH_KEY_LEN, &tmp_len) != PSA_SUCCESS) {
 		ret = -EIO;
 		LOG_ERR("Raw key agreement failed");
 		goto exit;
@@ -295,8 +292,7 @@ static uint8_t le_gen_dhkey(uint8_t *key, uint8_t key_type)
 	sys_memcpy_swap(&ecc.public_key_be[BT_PUB_KEY_COORD_LEN], &key[BT_PUB_KEY_COORD_LEN],
 			BT_PUB_KEY_COORD_LEN);
 
-	atomic_set_bit_to(flags, USE_DEBUG_KEY,
-			  key_type == BT_HCI_LE_KEY_TYPE_DEBUG);
+	atomic_set_bit_to(flags, USE_DEBUG_KEY, key_type == BT_HCI_LE_KEY_TYPE_DEBUG);
 
 	bt_long_wq_submit(&ecc_work);
 
diff --git a/subsys/bluetooth/host/hci_raw.c b/subsys/bluetooth/host/hci_raw.c
index 1580fea5ba5..2b98898eec2 100644
--- a/subsys/bluetooth/host/hci_raw.c
+++ b/subsys/bluetooth/host/hci_raw.c
@@ -50,28 +50,28 @@ static void hci_rx_buf_destroy(struct net_buf *buf)
 NET_BUF_POOL_FIXED_DEFINE(hci_rx_pool, BT_BUF_RX_COUNT, BT_BUF_RX_SIZE, sizeof(struct bt_buf_data),
 			  hci_rx_buf_destroy);
 NET_BUF_POOL_FIXED_DEFINE(hci_cmd_pool, CONFIG_BT_BUF_CMD_TX_COUNT,
-			  BT_BUF_CMD_SIZE(CONFIG_BT_BUF_CMD_TX_SIZE),
-			  sizeof(struct bt_buf_data), NULL);
+			  BT_BUF_CMD_SIZE(CONFIG_BT_BUF_CMD_TX_SIZE), sizeof(struct bt_buf_data),
+			  NULL);
 NET_BUF_POOL_FIXED_DEFINE(hci_acl_pool, CONFIG_BT_BUF_ACL_TX_COUNT,
-			  BT_BUF_ACL_SIZE(CONFIG_BT_BUF_ACL_TX_SIZE),
-			  sizeof(struct bt_buf_data), NULL);
+			  BT_BUF_ACL_SIZE(CONFIG_BT_BUF_ACL_TX_SIZE), sizeof(struct bt_buf_data),
+			  NULL);
 #if defined(CONFIG_BT_ISO)
 NET_BUF_POOL_FIXED_DEFINE(hci_iso_pool, CONFIG_BT_ISO_TX_BUF_COUNT,
-			  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU),
-			  sizeof(struct bt_buf_data), NULL);
+			  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU), sizeof(struct bt_buf_data),
+			  NULL);
 #endif /* CONFIG_BT_ISO */
 
 #if DT_HAS_CHOSEN(zephyr_bt_hci)
-#define BT_HCI_NODE   DT_CHOSEN(zephyr_bt_hci)
-#define BT_HCI_DEV    DEVICE_DT_GET(BT_HCI_NODE)
-#define BT_HCI_BUS    BT_DT_HCI_BUS_GET(BT_HCI_NODE)
-#define BT_HCI_NAME   BT_DT_HCI_NAME_GET(BT_HCI_NODE)
+#define BT_HCI_NODE DT_CHOSEN(zephyr_bt_hci)
+#define BT_HCI_DEV  DEVICE_DT_GET(BT_HCI_NODE)
+#define BT_HCI_BUS  BT_DT_HCI_BUS_GET(BT_HCI_NODE)
+#define BT_HCI_NAME BT_DT_HCI_NAME_GET(BT_HCI_NODE)
 #else
 /* The zephyr,bt-hci chosen property is mandatory, except for unit tests */
 BUILD_ASSERT(IS_ENABLED(CONFIG_ZTEST), "Missing DT chosen property for HCI");
-#define BT_HCI_DEV    NULL
-#define BT_HCI_BUS    0
-#define BT_HCI_NAME   ""
+#define BT_HCI_DEV  NULL
+#define BT_HCI_BUS  0
+#define BT_HCI_NAME ""
 #endif
 
 struct bt_dev_raw bt_dev = {
@@ -110,8 +110,8 @@ void bt_buf_rx_freed_cb_set(bt_buf_rx_freed_cb_t cb)
 	buf_rx_freed_cb = cb;
 }
 
-struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout,
-			      const void *data, size_t size)
+struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout, const void *data,
+			      size_t size)
 {
 	struct net_buf_pool *pool;
 	struct net_buf *buf;
@@ -129,8 +129,7 @@ struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout,
 		break;
 #endif /* CONFIG_BT_ISO */
 	case BT_BUF_H4:
-		if (IS_ENABLED(CONFIG_BT_HCI_RAW_H4) &&
-		    raw_mode == BT_HCI_RAW_MODE_H4) {
+		if (IS_ENABLED(CONFIG_BT_HCI_RAW_H4) && raw_mode == BT_HCI_RAW_MODE_H4) {
 			uint8_t h4_type = ((uint8_t *)data)[0];
 
 			switch (h4_type) {
@@ -197,8 +196,7 @@ int bt_hci_recv(const struct device *dev, struct net_buf *buf)
 
 	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);
 
-	if (IS_ENABLED(CONFIG_BT_HCI_RAW_H4) &&
-	    raw_mode == BT_HCI_RAW_MODE_H4) {
+	if (IS_ENABLED(CONFIG_BT_HCI_RAW_H4) && raw_mode == BT_HCI_RAW_MODE_H4) {
 		switch (bt_buf_get_type(buf)) {
 		case BT_BUF_EVT:
 			net_buf_push_u8(buf, BT_HCI_H4_EVT);
@@ -303,8 +301,7 @@ int bt_send(struct net_buf *buf)
 
 	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);
 
-	if (IS_ENABLED(CONFIG_BT_HCI_RAW_CMD_EXT) &&
-	    bt_buf_get_type(buf) == BT_BUF_CMD) {
+	if (IS_ENABLED(CONFIG_BT_HCI_RAW_CMD_EXT) && bt_buf_get_type(buf) == BT_BUF_CMD) {
 		uint8_t status;
 
 		status = bt_send_ext(buf);
diff --git a/subsys/bluetooth/host/id.c b/subsys/bluetooth/host/id.c
index 67f691dfa79..e4ac8a9d8b8 100644
--- a/subsys/bluetooth/host/id.c
+++ b/subsys/bluetooth/host/id.c
@@ -79,8 +79,7 @@ static void adv_id_check_func(struct bt_le_ext_adv *adv, void *data)
 			check_data->adv_enabled = true;
 		}
 	} else {
-		if (check_data->id == adv->id &&
-		    atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
+		if (check_data->id == adv->id && atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
 			check_data->adv_enabled = true;
 		}
 	}
@@ -161,8 +160,7 @@ static int set_random_address(const bt_addr_t *addr)
 	return 0;
 }
 
-int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv,
-			      const bt_addr_t *addr)
+int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv, const bt_addr_t *addr)
 {
 	struct bt_hci_cp_le_set_adv_set_random_addr *cp;
 	struct net_buf *buf;
@@ -172,8 +170,7 @@ int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv,
 		return -EINVAL;
 	}
 
-	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	      BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		return set_random_address(addr);
 	}
 
@@ -186,8 +183,7 @@ int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv,
 		return 0;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_SET_RANDOM_ADDR,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_SET_RANDOM_ADDR, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -197,8 +193,7 @@ int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv,
 	cp->handle = adv->handle;
 	bt_addr_copy(&cp->bdaddr, addr);
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_SET_RANDOM_ADDR, buf,
-				   NULL);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_SET_RANDOM_ADDR, buf, NULL);
 	if (err) {
 		return err;
 	}
@@ -219,8 +214,7 @@ static void adv_rpa_expired(struct bt_le_ext_adv *adv, void *data)
 	bool rpa_invalid = true;
 #if defined(CONFIG_BT_EXT_ADV) && defined(CONFIG_BT_PRIVACY)
 	/* Notify the user about the RPA timeout and set the RPA validity. */
-	if (atomic_test_bit(adv->flags, BT_ADV_RPA_VALID) &&
-	    adv->cb && adv->cb->rpa_expired) {
+	if (atomic_test_bit(adv->flags, BT_ADV_RPA_VALID) && adv->cb && adv->cb->rpa_expired) {
 		rpa_invalid = adv->cb->rpa_expired(adv);
 	}
 #endif
@@ -304,8 +298,7 @@ static void le_rpa_timeout_update(void)
 		struct net_buf *buf;
 		struct bt_hci_cp_le_set_rpa_timeout *cp;
 
-		buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RPA_TIMEOUT,
-					sizeof(*cp));
+		buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RPA_TIMEOUT, sizeof(*cp));
 		if (!buf) {
 			LOG_ERR("Failed to create HCI RPA timeout command");
 			err = -ENOBUFS;
@@ -412,8 +405,7 @@ int bt_id_set_adv_private_addr(struct bt_le_ext_adv *adv)
 		return -EINVAL;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    (adv->options & BT_LE_ADV_OPT_USE_NRPA)) {
+	if (IS_ENABLED(CONFIG_BT_PRIVACY) && (adv->options & BT_LE_ADV_OPT_USE_NRPA)) {
 		/* The host doesn't support setting NRPAs when BT_PRIVACY=y.
 		 * In that case you probably want to use an RPA anyway.
 		 */
@@ -422,8 +414,7 @@ int bt_id_set_adv_private_addr(struct bt_le_ext_adv *adv)
 		return -ENOSYS;
 	}
 
-	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	      BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	if (!(IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		return bt_id_set_private_addr(adv->id);
 	}
 
@@ -496,7 +487,7 @@ int bt_id_set_private_addr(uint8_t id)
 	BT_ADDR_SET_NRPA(&nrpa);
 
 	err = set_random_address(&nrpa);
-	if (err)  {
+	if (err) {
 		return err;
 	}
 
@@ -561,8 +552,7 @@ static bool le_adv_rpa_timeout(void)
 	bool adv_enabled = false;
 
 	if (IS_ENABLED(CONFIG_BT_BROADCASTER)) {
-		if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-		    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
+		if (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 			/* Pause all advertising sets using RPAs */
 			bt_le_ext_adv_foreach(adv_pause_rpa, &adv_enabled);
 		} else {
@@ -608,8 +598,7 @@ static void le_update_private_addr(void)
 		scan_enabled = true;
 	}
 #endif
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING)) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING)) {
 		/* Canceled initiating procedure will be restarted by
 		 * connection complete event.
 		 */
@@ -617,12 +606,10 @@ static void le_update_private_addr(void)
 	}
 
 	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
-	    !(IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	      BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	    !(IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		adv = bt_le_adv_lookup_legacy();
 
-		if (adv &&
-		    atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
+		if (adv && atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
 		    !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
 			adv_enabled = true;
 			id = adv->id;
@@ -640,14 +627,12 @@ static void le_update_private_addr(void)
 		return;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
-	    IS_ENABLED(CONFIG_BT_EXT_ADV) &&
+	if (IS_ENABLED(CONFIG_BT_BROADCASTER) && IS_ENABLED(CONFIG_BT_EXT_ADV) &&
 	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
 		bt_le_ext_adv_foreach(adv_enable_rpa, NULL);
 	}
 
-	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
-	    adv && adv_enabled) {
+	if (IS_ENABLED(CONFIG_BT_BROADCASTER) && adv && adv_enabled) {
 		bt_le_adv_set_enable_legacy(adv, true);
 	}
 
@@ -678,9 +663,8 @@ static void rpa_timeout(struct k_work *work)
 	LOG_DBG("");
 
 	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
-		struct bt_conn *conn =
-			bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL,
-						BT_CONN_SCAN_BEFORE_INITIATING);
+		struct bt_conn *conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL,
+							       BT_CONN_SCAN_BEFORE_INITIATING);
 
 		if (conn) {
 			bt_conn_unref(conn);
@@ -708,8 +692,7 @@ bool bt_id_scan_random_addr_check(void)
 	struct bt_le_ext_adv *adv;
 
 	if (!IS_ENABLED(CONFIG_BT_BROADCASTER) ||
-	    (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	     BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	    (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		/* Advertiser is not enabled or advertiser and scanner are using
 		 * a different random address.
 		 */
@@ -757,8 +740,7 @@ bool bt_id_adv_random_addr_check(const struct bt_le_adv_param *param)
 	}
 
 	if (!IS_ENABLED(CONFIG_BT_OBSERVER) ||
-	    (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	     BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	    (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		/* If scanner roles are not enabled or advertiser and scanner
 		 * are using a different random address.
 		 */
@@ -796,11 +778,10 @@ bool bt_id_adv_random_addr_check(const struct bt_le_adv_param *param)
 		 */
 
 		if (!(param->options & _BT_LE_ADV_OPT_CONNECTABLE) &&
-		     (param->options & BT_LE_ADV_OPT_USE_IDENTITY)) {
+		    (param->options & BT_LE_ADV_OPT_USE_IDENTITY)) {
 			/* Attempt to set non-connectable NRPA */
 			return false;
-		} else if (bt_dev.id_addr[param->id].type ==
-			   BT_ADDR_LE_RANDOM &&
+		} else if (bt_dev.id_addr[param->id].type == BT_ADDR_LE_RANDOM &&
 			   param->id != BT_ID_DEFAULT) {
 			/* Attempt to set connectable, or non-connectable with
 			 * identity different than scanner.
@@ -868,8 +849,7 @@ static int addr_res_enable(uint8_t enable)
 
 	net_buf_add_u8(buf, enable);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
-				    buf, NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, buf, NULL);
 }
 
 static int hci_id_add(uint8_t id, const bt_addr_le_t *addr, uint8_t peer_irk[16])
@@ -925,8 +905,7 @@ static void bt_id_pending_keys_update_set(struct bt_keys *keys, uint8_t flag)
 void bt_id_pending_keys_update(void)
 {
 	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
-		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-		    IS_ENABLED(CONFIG_BT_PRIVACY)) {
+		if (IS_ENABLED(CONFIG_BT_CENTRAL) && IS_ENABLED(CONFIG_BT_PRIVACY)) {
 			bt_keys_foreach_type(BT_KEYS_ALL, pending_id_update, NULL);
 		} else {
 			bt_keys_foreach_type(BT_KEYS_IRK, pending_id_update, NULL);
@@ -1021,14 +1000,12 @@ void bt_id_add(struct bt_keys *keys)
 		return;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
-	    IS_ENABLED(CONFIG_BT_EXT_ADV)) {
+	if (IS_ENABLED(CONFIG_BT_BROADCASTER) && IS_ENABLED(CONFIG_BT_EXT_ADV)) {
 		bool adv_enabled = false;
 
 		bt_le_ext_adv_foreach(adv_is_limited_enabled, &adv_enabled);
 		if (adv_enabled) {
-			bt_id_pending_keys_update_set(keys,
-						   BT_KEYS_ID_PENDING_ADD);
+			bt_id_pending_keys_update_set(keys, BT_KEYS_ID_PENDING_ADD);
 			return;
 		}
 	}
@@ -1153,8 +1130,7 @@ void bt_id_del(struct bt_keys *keys)
 
 	LOG_DBG("addr %s", bt_addr_le_str(&keys->addr));
 
-	if (!bt_dev.le.rl_size ||
-	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
+	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
 		__ASSERT_NO_MSG(bt_dev.le.rl_entries > 0);
 		if (bt_dev.le.rl_entries > 0) {
 			bt_dev.le.rl_entries--;
@@ -1170,8 +1146,7 @@ void bt_id_del(struct bt_keys *keys)
 		return;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
-	    IS_ENABLED(CONFIG_BT_EXT_ADV)) {
+	if (IS_ENABLED(CONFIG_BT_BROADCASTER) && IS_ENABLED(CONFIG_BT_EXT_ADV)) {
 		bool adv_enabled = false;
 
 		bt_le_ext_adv_foreach(adv_is_limited_enabled, &adv_enabled);
@@ -1210,8 +1185,7 @@ void bt_id_del(struct bt_keys *keys)
 	if (bt_dev.le.rl_entries > bt_dev.le.rl_size) {
 		bt_dev.le.rl_entries--;
 		keys->state &= ~BT_KEYS_ID_ADDED;
-		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-		    IS_ENABLED(CONFIG_BT_PRIVACY)) {
+		if (IS_ENABLED(CONFIG_BT_CENTRAL) && IS_ENABLED(CONFIG_BT_PRIVACY)) {
 			bt_keys_foreach_type(BT_KEYS_ALL, keys_add_id, NULL);
 		} else {
 			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
@@ -1297,7 +1271,7 @@ static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
 
 #if defined(CONFIG_BT_PRIVACY)
 	{
-		uint8_t zero_irk[16] = { 0 };
+		uint8_t zero_irk[16] = {0};
 
 		if (irk && memcmp(irk, zero_irk, 16)) {
 			memcpy(&bt_dev.irk[id], irk, 16);
@@ -1323,8 +1297,7 @@ static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
 	 * we don't know the flash content, so it's potentially harmful to
 	 * try to write anything there.
 	 */
-	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
-	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
+	if (IS_ENABLED(CONFIG_BT_SETTINGS) && atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 		(void)bt_settings_store_id();
 		(void)bt_settings_store_irk();
 	}
@@ -1365,14 +1338,13 @@ int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
 
 	/* bt_rand is not available before Bluetooth enable has been called */
 	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
-		uint8_t zero_irk[16] = { 0 };
+		uint8_t zero_irk[16] = {0};
 
 		if (!(addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY))) {
 			return -EINVAL;
 		}
 
-		if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-		    !(irk && memcmp(irk, zero_irk, 16))) {
+		if (IS_ENABLED(CONFIG_BT_PRIVACY) && !(irk && memcmp(irk, zero_irk, 16))) {
 			return -EINVAL;
 		}
 	}
@@ -1392,8 +1364,7 @@ int bt_id_reset(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
 	int err;
 
 	if (addr && !bt_addr_le_eq(addr, BT_ADDR_LE_ANY)) {
-		if (addr->type != BT_ADDR_LE_RANDOM ||
-		    !BT_ADDR_IS_STATIC(&addr->a)) {
+		if (addr->type != BT_ADDR_LE_RANDOM || !BT_ADDR_IS_STATIC(&addr->a)) {
 			LOG_ERR("Only static random identity address supported");
 			return -EINVAL;
 		}
@@ -1423,8 +1394,7 @@ int bt_id_reset(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP) &&
-	    !bt_addr_le_eq(&bt_dev.id_addr[id], BT_ADDR_LE_ANY)) {
+	if (IS_ENABLED(CONFIG_BT_SMP) && !bt_addr_le_eq(&bt_dev.id_addr[id], BT_ADDR_LE_ANY)) {
 		err = bt_unpair(id, NULL);
 		if (err) {
 			return err;
@@ -1479,8 +1449,7 @@ int bt_id_delete(uint8_t id)
 		bt_dev.id_count--;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
-	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
+	if (IS_ENABLED(CONFIG_BT_SETTINGS) && atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
 		(void)bt_settings_store_id();
 		(void)bt_settings_store_irk();
 	}
@@ -1503,8 +1472,7 @@ static void bt_read_identity_root(uint8_t *ir)
 		return;
 	}
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_KEY_HIERARCHY_ROOTS, NULL,
-				   &rsp);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_KEY_HIERARCHY_ROOTS, NULL, &rsp);
 	if (err) {
 		LOG_WRN("Failed to read identity root");
 		return;
@@ -1545,8 +1513,7 @@ uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
 
 	rp = (void *)rsp->data;
 
-	if (bt_addr_eq(&rp->bdaddr, BT_ADDR_ANY) ||
-	    bt_addr_eq(&rp->bdaddr, BT_ADDR_NONE)) {
+	if (bt_addr_eq(&rp->bdaddr, BT_ADDR_ANY) || bt_addr_eq(&rp->bdaddr, BT_ADDR_NONE)) {
 		LOG_DBG("Controller has no public address");
 		net_buf_unref(rsp);
 		return 0U;
@@ -1627,8 +1594,7 @@ static uint8_t vs_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t
 
 	if (IS_ENABLED(CONFIG_BT_HCI_VS_EXT_DETECT) &&
 	    rsp->len != (sizeof(struct bt_hci_rp_vs_read_static_addrs) +
-			 rp->num_addrs *
-			 sizeof(struct bt_hci_vs_static_addr))) {
+			 rp->num_addrs * sizeof(struct bt_hci_vs_static_addr))) {
 		LOG_WRN("Invalid Vendor HCI extensions");
 		net_buf_unref(rsp);
 		return 0;
@@ -1708,8 +1674,8 @@ int bt_setup_random_id_addr(void)
 static inline bool rpa_timeout_valid_check(void)
 {
 #if defined(CONFIG_BT_PRIVACY)
-	uint32_t remaining_ms = k_ticks_to_ms_floor32(
-		k_work_delayable_remaining_get(&bt_dev.rpa_update));
+	uint32_t remaining_ms =
+		k_ticks_to_ms_floor32(k_work_delayable_remaining_get(&bt_dev.rpa_update));
 	/* Check if create conn timeout will happen before RPA timeout. */
 	return remaining_ms > (10 * bt_dev.create_param.timeout);
 #else
@@ -1775,8 +1741,7 @@ static bool is_adv_using_rand_addr(void)
 	struct bt_le_ext_adv *adv;
 
 	if (!IS_ENABLED(CONFIG_BT_BROADCASTER) ||
-	    (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
-	     BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
+	    (IS_ENABLED(CONFIG_BT_EXT_ADV) && BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features))) {
 		/* When advertising is not enabled or is using extended
 		 * advertising HCI commands then only the scanner uses the set
 		 * random address command.
@@ -1819,8 +1784,7 @@ int bt_id_set_scan_own_addr(bool active_scan, uint8_t *own_addr_type)
 		 * (through Kconfig).
 		 * Use same RPA as legacy advertiser if advertising.
 		 */
-		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
-		    !is_adv_using_rand_addr()) {
+		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) && !is_adv_using_rand_addr()) {
 			err = bt_id_set_private_addr(BT_ID_DEFAULT);
 			if (err) {
 				if (active_scan || !is_adv_using_rand_addr()) {
@@ -1855,8 +1819,8 @@ int bt_id_set_scan_own_addr(bool active_scan, uint8_t *own_addr_type)
 }
 #endif /* defined(CONFIG_BT_OBSERVER) */
 
-int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
-			   bool dir_adv, uint8_t *own_addr_type)
+int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options, bool dir_adv,
+			   uint8_t *own_addr_type)
 {
 	const bt_addr_le_t *id_addr;
 	int err = 0;
@@ -1891,8 +1855,7 @@ int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
 			return -ENOTSUP;
 		}
 
-		if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-		    !(options & BT_LE_ADV_OPT_USE_IDENTITY)) {
+		if (IS_ENABLED(CONFIG_BT_PRIVACY) && !(options & BT_LE_ADV_OPT_USE_IDENTITY)) {
 			err = bt_id_set_adv_private_addr(adv);
 			if (err) {
 				return err;
@@ -2014,8 +1977,7 @@ int bt_le_oob_get_local(uint8_t id, struct bt_le_oob *oob)
 	}
 
 	if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    !(adv && adv->id == id &&
-	      atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
+	    !(adv && adv->id == id && atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
 	      atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY) &&
 	      bt_dev.id_addr[id].type == BT_ADDR_LE_RANDOM)) {
 		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
@@ -2033,8 +1995,7 @@ int bt_le_oob_get_local(uint8_t id, struct bt_le_oob *oob)
 			}
 		}
 
-		if (adv &&
-		    atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
+		if (adv && atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
 		    atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY) &&
 		    (bt_dev.id_addr[id].type == BT_ADDR_LE_RANDOM)) {
 			/* Cannot set a new RPA address while advertising with
@@ -2044,9 +2005,7 @@ int bt_le_oob_get_local(uint8_t id, struct bt_le_oob *oob)
 			return -EINVAL;
 		}
 
-		if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
-		    CONFIG_BT_ID_MAX > 1 &&
-		    id != BT_ID_DEFAULT &&
+		if (IS_ENABLED(CONFIG_BT_OBSERVER) && CONFIG_BT_ID_MAX > 1 && id != BT_ID_DEFAULT &&
 		    (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) ||
 		     atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING))) {
 			/* Cannot switch identity of scanner or initiator */
@@ -2071,8 +2030,7 @@ int bt_le_oob_get_local(uint8_t id, struct bt_le_oob *oob)
 }
 
 #if defined(CONFIG_BT_EXT_ADV)
-int bt_le_ext_adv_oob_get_local(struct bt_le_ext_adv *adv,
-				struct bt_le_oob *oob)
+int bt_le_ext_adv_oob_get_local(struct bt_le_ext_adv *adv, struct bt_le_oob *oob)
 {
 	int err;
 
@@ -2084,22 +2042,19 @@ int bt_le_ext_adv_oob_get_local(struct bt_le_ext_adv *adv,
 		return -EAGAIN;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
+	if (IS_ENABLED(CONFIG_BT_PRIVACY) && !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
 		/* Don't refresh RPA addresses if the RPA is new.
 		 * This allows back to back calls to this function or
 		 * bt_le_oob_get_local to not invalidate the previously set
 		 * RPAs.
 		 */
-		if (!atomic_test_bit(adv->flags, BT_ADV_LIMITED) &&
-		    !bt_id_rpa_is_new()) {
+		if (!atomic_test_bit(adv->flags, BT_ADV_LIMITED) && !bt_id_rpa_is_new()) {
 			if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
 			    atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING)) {
 				struct bt_conn *conn;
 
-				conn = bt_conn_lookup_state_le(
-					BT_ID_DEFAULT, NULL,
-					BT_CONN_SCAN_BEFORE_INITIATING);
+				conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL,
+							       BT_CONN_SCAN_BEFORE_INITIATING);
 
 				if (conn) {
 					/* Cannot set new RPA while creating
@@ -2142,8 +2097,7 @@ int bt_le_oob_set_legacy_tk(struct bt_conn *conn, const uint8_t *tk)
 #endif /* !defined(CONFIG_BT_SMP_SC_PAIR_ONLY) */
 
 #if !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)
-int bt_le_oob_set_sc_data(struct bt_conn *conn,
-			  const struct bt_le_oob_sc_data *oobd_local,
+int bt_le_oob_set_sc_data(struct bt_conn *conn, const struct bt_le_oob_sc_data *oobd_local,
 			  const struct bt_le_oob_sc_data *oobd_remote)
 {
 	CHECKIF(conn == NULL) {
@@ -2157,8 +2111,7 @@ int bt_le_oob_set_sc_data(struct bt_conn *conn,
 	return bt_smp_le_oob_set_sc_data(conn, oobd_local, oobd_remote);
 }
 
-int bt_le_oob_get_sc_data(struct bt_conn *conn,
-			  const struct bt_le_oob_sc_data **oobd_local,
+int bt_le_oob_get_sc_data(struct bt_conn *conn, const struct bt_le_oob_sc_data **oobd_local,
 			  const struct bt_le_oob_sc_data **oobd_remote)
 {
 	CHECKIF(conn == NULL) {
diff --git a/subsys/bluetooth/host/id.h b/subsys/bluetooth/host/id.h
index 55a25d93400..4a7c14dd767 100644
--- a/subsys/bluetooth/host/id.h
+++ b/subsys/bluetooth/host/id.h
@@ -10,8 +10,8 @@
 static inline bool bt_id_rpa_is_new(void)
 {
 #if defined(CONFIG_BT_PRIVACY)
-	uint32_t remaining_ms = k_ticks_to_ms_floor32(
-		k_work_delayable_remaining_get(&bt_dev.rpa_update));
+	uint32_t remaining_ms =
+		k_ticks_to_ms_floor32(k_work_delayable_remaining_get(&bt_dev.rpa_update));
 	/* RPA is considered new if there is less than half a second since the
 	 * timeout was started.
 	 */
@@ -29,15 +29,14 @@ int bt_id_set_create_conn_own_addr(bool use_filter, uint8_t *own_addr_type);
 
 int bt_id_set_scan_own_addr(bool active_scan, uint8_t *own_addr_type);
 
-int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
-			   bool dir_adv, uint8_t *own_addr_type);
+int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options, bool dir_adv,
+			   uint8_t *own_addr_type);
 
 bool bt_id_adv_random_addr_check(const struct bt_le_adv_param *param);
 
 bool bt_id_scan_random_addr_check(void);
 
-int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv,
-			      const bt_addr_t *addr);
+int bt_id_set_adv_random_addr(struct bt_le_ext_adv *adv, const bt_addr_t *addr);
 int bt_id_set_adv_private_addr(struct bt_le_ext_adv *adv);
 
 int bt_id_set_private_addr(uint8_t id);
diff --git a/subsys/bluetooth/host/iso_internal.h b/subsys/bluetooth/host/iso_internal.h
index 538435f5155..b19dfeceec8 100644
--- a/subsys/bluetooth/host/iso_internal.h
+++ b/subsys/bluetooth/host/iso_internal.h
@@ -25,7 +25,7 @@ struct iso_data {
 	struct bt_buf_data buf_data;
 
 	/* Index into the bt_conn storage array */
-	uint8_t  index;
+	uint8_t index;
 
 	/** ISO connection handle */
 	uint16_t handle;
@@ -43,7 +43,7 @@ struct bt_iso_cig {
 	sys_slist_t cis_channels;
 
 	/** Total number of CISes in the CIG. */
-	uint8_t  num_cis;
+	uint8_t num_cis;
 
 	/** The CIG ID */
 	uint8_t id;
@@ -71,7 +71,7 @@ struct bt_iso_big {
 	sys_slist_t bis_channels;
 
 	/** Total number of BISes in the BIG. */
-	uint8_t  num_bis;
+	uint8_t num_bis;
 
 	/** The BIG handle */
 	uint8_t handle;
@@ -126,10 +126,9 @@ void bt_iso_disconnected(struct bt_conn *iso);
 void bt_iso_security_changed(struct bt_conn *acl, uint8_t hci_status);
 
 #if defined(CONFIG_BT_ISO_LOG_LEVEL_DBG)
-void bt_iso_chan_set_state_debug(struct bt_iso_chan *chan,
-				 enum bt_iso_state state,
+void bt_iso_chan_set_state_debug(struct bt_iso_chan *chan, enum bt_iso_state state,
 				 const char *func, int line);
-#define bt_iso_chan_set_state(_chan, _state) \
+#define bt_iso_chan_set_state(_chan, _state)                                                       \
 	bt_iso_chan_set_state_debug(_chan, _state, __func__, __LINE__)
 #else
 void bt_iso_chan_set_state(struct bt_iso_chan *chan, enum bt_iso_state state);
diff --git a/subsys/bluetooth/host/keys.c b/subsys/bluetooth/host/keys.c
index 6740d43b1cd..7df6b6a5892 100644
--- a/subsys/bluetooth/host/keys.c
+++ b/subsys/bluetooth/host/keys.c
@@ -72,7 +72,7 @@ static void find_key_in_use(struct bt_conn *conn, void *data)
 
 static bool key_is_in_use(uint8_t id)
 {
-	struct key_data kdata = { false, id };
+	struct key_data kdata = {false, id};
 
 	bt_conn_foreach(BT_CONN_TYPE_ALL, find_key_in_use, &kdata);
 
@@ -138,7 +138,7 @@ struct bt_keys *bt_keys_get_addr(uint8_t id, const bt_addr_le_t *addr)
 		}
 	}
 
-#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
+#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 	if (first_free_slot < ARRAY_SIZE(key_pool)) {
 		keys = &key_pool[first_free_slot];
 		keys->id = id;
@@ -146,7 +146,7 @@ struct bt_keys *bt_keys_get_addr(uint8_t id, const bt_addr_le_t *addr)
 #if defined(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
 		keys->aging_counter = ++aging_counter_val;
 		last_keys_updated = keys;
-#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
+#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 		LOG_DBG("created %p for %s", keys, bt_addr_le_str(addr));
 		return keys;
 	}
@@ -156,8 +156,7 @@ struct bt_keys *bt_keys_get_addr(uint8_t id, const bt_addr_le_t *addr)
 	return NULL;
 }
 
-void bt_foreach_bond(uint8_t id, void (*func)(const struct bt_bond_info *info,
-					   void *user_data),
+void bt_foreach_bond(uint8_t id, void (*func)(const struct bt_bond_info *info, void *user_data),
 		     void *user_data)
 {
 	int i;
@@ -252,8 +251,7 @@ struct bt_keys *bt_keys_find_irk(uint8_t id, const bt_addr_le_t *addr)
 			continue;
 		}
 
-		if (key_pool[i].id == id &&
-		    bt_addr_eq(&addr->a, &key_pool[i].irk.rpa)) {
+		if (key_pool[i].id == id && bt_addr_eq(&addr->a, &key_pool[i].irk.rpa)) {
 			LOG_DBG("cached RPA %s for %s", bt_addr_str(&key_pool[i].irk.rpa),
 				bt_addr_le_str(&key_pool[i].addr));
 			return &key_pool[i];
@@ -293,8 +291,7 @@ struct bt_keys *bt_keys_find_addr(uint8_t id, const bt_addr_le_t *addr)
 	LOG_DBG("%s", bt_addr_le_str(addr));
 
 	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
-		if (key_pool[i].id == id &&
-		    bt_addr_le_eq(&key_pool[i].addr, addr)) {
+		if (key_pool[i].id == id && bt_addr_le_eq(&key_pool[i].addr, addr)) {
 			return &key_pool[i];
 		}
 	}
@@ -346,8 +343,7 @@ int bt_keys_store(struct bt_keys *keys)
 	return 0;
 }
 
-static int keys_set(const char *name, size_t len_rd, settings_read_cb read_cb,
-		    void *cb_arg)
+static int keys_set(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	struct bt_keys *keys;
 	bt_addr_le_t addr;
@@ -431,7 +427,7 @@ static int keys_set(const char *name, size_t len_rd, settings_read_cb read_cb,
 	if (aging_counter_val < keys->aging_counter) {
 		aging_counter_val = keys->aging_counter;
 	}
-#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
+#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 	return 0;
 }
 
@@ -486,7 +482,7 @@ void bt_keys_update_usage(uint8_t id, const bt_addr_le_t *addr)
 	}
 }
 
-#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
+#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 
 #if defined(CONFIG_BT_LOG_SNIFFER_INFO)
 void bt_keys_show_sniffer_info(struct bt_keys *keys, void *data)
diff --git a/subsys/bluetooth/host/keys.h b/subsys/bluetooth/host/keys.h
index c1da17fb488..b3b5e4b89eb 100644
--- a/subsys/bluetooth/host/keys.h
+++ b/subsys/bluetooth/host/keys.h
@@ -14,42 +14,41 @@
 /** @cond INTERNAL_HIDDEN */
 
 enum bt_keys_type {
-	BT_KEYS_PERIPH_LTK     = BIT(0),
-	BT_KEYS_IRK            = BIT(1),
-	BT_KEYS_LTK            = BIT(2),
-	BT_KEYS_LOCAL_CSRK     = BIT(3),
-	BT_KEYS_REMOTE_CSRK    = BIT(4),
-	BT_KEYS_LTK_P256       = BIT(5),
-
-	BT_KEYS_ALL            = (BT_KEYS_PERIPH_LTK | BT_KEYS_IRK |
-				  BT_KEYS_LTK | BT_KEYS_LOCAL_CSRK |
-				  BT_KEYS_REMOTE_CSRK | BT_KEYS_LTK_P256),
+	BT_KEYS_PERIPH_LTK = BIT(0),
+	BT_KEYS_IRK = BIT(1),
+	BT_KEYS_LTK = BIT(2),
+	BT_KEYS_LOCAL_CSRK = BIT(3),
+	BT_KEYS_REMOTE_CSRK = BIT(4),
+	BT_KEYS_LTK_P256 = BIT(5),
+
+	BT_KEYS_ALL = (BT_KEYS_PERIPH_LTK | BT_KEYS_IRK | BT_KEYS_LTK | BT_KEYS_LOCAL_CSRK |
+		       BT_KEYS_REMOTE_CSRK | BT_KEYS_LTK_P256),
 };
 
 enum {
-	BT_KEYS_ID_PENDING_ADD  = BIT(0),
-	BT_KEYS_ID_PENDING_DEL  = BIT(1),
-	BT_KEYS_ID_ADDED        = BIT(2),
+	BT_KEYS_ID_PENDING_ADD = BIT(0),
+	BT_KEYS_ID_PENDING_DEL = BIT(1),
+	BT_KEYS_ID_ADDED = BIT(2),
 };
 
 enum {
-	BT_KEYS_AUTHENTICATED   = BIT(0),
-	BT_KEYS_DEBUG           = BIT(1),
+	BT_KEYS_AUTHENTICATED = BIT(0),
+	BT_KEYS_DEBUG = BIT(1),
 	/* Bit 2 and 3 might accidentally exist in old stored keys */
-	BT_KEYS_SC              = BIT(4),
-	BT_KEYS_OOB             = BIT(5),
+	BT_KEYS_SC = BIT(4),
+	BT_KEYS_OOB = BIT(5),
 };
 
 struct bt_ltk {
-	uint8_t                    rand[8];
-	uint8_t                    ediv[2];
-	uint8_t                    val[16];
+	uint8_t rand[8];
+	uint8_t ediv[2];
+	uint8_t val[16];
 };
 
 struct bt_irk {
-	uint8_t                    val[16];
+	uint8_t val[16];
 	/* Cache for `bt_keys_find_irk`. Not reliable as "current RPA"! */
-	bt_addr_t               rpa;
+	bt_addr_t rpa;
 };
 
 static inline bool bt_irk_eq(struct bt_irk const *a, struct bt_irk const *b)
@@ -58,34 +57,33 @@ static inline bool bt_irk_eq(struct bt_irk const *a, struct bt_irk const *b)
 }
 
 struct bt_csrk {
-	uint8_t                    val[16];
-	uint32_t                   cnt;
+	uint8_t val[16];
+	uint32_t cnt;
 };
 
 struct bt_keys {
-	uint8_t                    id;
-	bt_addr_le_t            addr;
-	uint8_t                    state;
-	uint8_t                    storage_start[0] __aligned(sizeof(void *));
-	uint8_t                    enc_size;
-	uint8_t                    flags;
-	uint16_t                   keys;
-	struct bt_ltk           ltk;
-	struct bt_irk           irk;
+	uint8_t id;
+	bt_addr_le_t addr;
+	uint8_t state;
+	uint8_t storage_start[0] __aligned(sizeof(void *));
+	uint8_t enc_size;
+	uint8_t flags;
+	uint16_t keys;
+	struct bt_ltk ltk;
+	struct bt_irk irk;
 #if defined(CONFIG_BT_SIGNING)
-	struct bt_csrk          local_csrk;
-	struct bt_csrk          remote_csrk;
+	struct bt_csrk local_csrk;
+	struct bt_csrk remote_csrk;
 #endif /* BT_SIGNING */
 #if !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
-	struct bt_ltk           periph_ltk;
+	struct bt_ltk periph_ltk;
 #endif /* CONFIG_BT_SMP_SC_PAIR_ONLY */
 #if (defined(CONFIG_BT_KEYS_OVERWRITE_OLDEST))
-	uint32_t                   aging_counter;
+	uint32_t aging_counter;
 #endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 };
 
-#define BT_KEYS_STORAGE_LEN     (sizeof(struct bt_keys) - \
-				 offsetof(struct bt_keys, storage_start))
+#define BT_KEYS_STORAGE_LEN (sizeof(struct bt_keys) - offsetof(struct bt_keys, storage_start))
 
 /** Clears all keys.
  *
@@ -204,22 +202,22 @@ static inline int bt_keys_store(struct bt_keys *keys)
 #endif
 
 enum {
-	BT_LINK_KEY_AUTHENTICATED  = BIT(0),
-	BT_LINK_KEY_DEBUG          = BIT(1),
-	BT_LINK_KEY_SC             = BIT(2),
+	BT_LINK_KEY_AUTHENTICATED = BIT(0),
+	BT_LINK_KEY_DEBUG = BIT(1),
+	BT_LINK_KEY_SC = BIT(2),
 };
 
 struct bt_keys_link_key {
-	bt_addr_t               addr;
-	uint8_t                 storage_start[0]  __aligned(sizeof(void *));
-	uint8_t                 flags;
-	uint8_t                 val[16];
+	bt_addr_t addr;
+	uint8_t storage_start[0] __aligned(sizeof(void *));
+	uint8_t flags;
+	uint8_t val[16];
 #if (defined(CONFIG_BT_KEYS_OVERWRITE_OLDEST))
-	uint32_t                aging_counter;
+	uint32_t aging_counter;
 #endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
 };
-#define BT_KEYS_LINK_KEY_STORAGE_LEN     (sizeof(struct bt_keys_link_key) - \
-	offsetof(struct bt_keys_link_key, storage_start))
+#define BT_KEYS_LINK_KEY_STORAGE_LEN                                                               \
+	(sizeof(struct bt_keys_link_key) - offsetof(struct bt_keys_link_key, storage_start))
 
 struct bt_keys_link_key *bt_keys_get_link_key(const bt_addr_t *addr);
 struct bt_keys_link_key *bt_keys_find_link_key(const bt_addr_t *addr);
diff --git a/subsys/bluetooth/host/l2cap.c b/subsys/bluetooth/host/l2cap.c
index 03b68592d5c..c71975d1057 100644
--- a/subsys/bluetooth/host/l2cap.c
+++ b/subsys/bluetooth/host/l2cap.c
@@ -35,42 +35,39 @@
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(bt_l2cap, CONFIG_BT_L2CAP_LOG_LEVEL);
 
-#define LE_CHAN_RTX(_w) CONTAINER_OF(k_work_delayable_from_work(_w), \
-				     struct bt_l2cap_le_chan, rtx_work)
+#define LE_CHAN_RTX(_w)                                                                            \
+	CONTAINER_OF(k_work_delayable_from_work(_w), struct bt_l2cap_le_chan, rtx_work)
 #define CHAN_RX(_w) CONTAINER_OF(_w, struct bt_l2cap_le_chan, rx_work)
 
-#define L2CAP_LE_MIN_MTU		23
+#define L2CAP_LE_MIN_MTU 23
 
-#define L2CAP_LE_MAX_CREDITS		(BT_BUF_ACL_RX_COUNT - 1)
+#define L2CAP_LE_MAX_CREDITS (BT_BUF_ACL_RX_COUNT - 1)
 
-#define L2CAP_LE_CID_DYN_START	0x0040
-#define L2CAP_LE_CID_DYN_END	0x007f
-#define L2CAP_LE_CID_IS_DYN(_cid) \
-	(_cid >= L2CAP_LE_CID_DYN_START && _cid <= L2CAP_LE_CID_DYN_END)
+#define L2CAP_LE_CID_DYN_START    0x0040
+#define L2CAP_LE_CID_DYN_END      0x007f
+#define L2CAP_LE_CID_IS_DYN(_cid) (_cid >= L2CAP_LE_CID_DYN_START && _cid <= L2CAP_LE_CID_DYN_END)
 
-#define L2CAP_LE_PSM_FIXED_START 0x0001
-#define L2CAP_LE_PSM_FIXED_END   0x007f
-#define L2CAP_LE_PSM_DYN_START   0x0080
-#define L2CAP_LE_PSM_DYN_END     0x00ff
-#define L2CAP_LE_PSM_IS_DYN(_psm) \
-	(_psm >= L2CAP_LE_PSM_DYN_START && _psm <= L2CAP_LE_PSM_DYN_END)
+#define L2CAP_LE_PSM_FIXED_START  0x0001
+#define L2CAP_LE_PSM_FIXED_END    0x007f
+#define L2CAP_LE_PSM_DYN_START    0x0080
+#define L2CAP_LE_PSM_DYN_END      0x00ff
+#define L2CAP_LE_PSM_IS_DYN(_psm) (_psm >= L2CAP_LE_PSM_DYN_START && _psm <= L2CAP_LE_PSM_DYN_END)
 
-#define L2CAP_CONN_TIMEOUT	K_SECONDS(40)
-#define L2CAP_DISC_TIMEOUT	K_SECONDS(2)
+#define L2CAP_CONN_TIMEOUT K_SECONDS(40)
+#define L2CAP_DISC_TIMEOUT K_SECONDS(2)
 /** @brief Local L2CAP RTX (Response Timeout eXpired)
  *
  *  Specification-allowed range for the value of RTX is 1 to 60 seconds.
  */
-#define L2CAP_RTX_TIMEOUT	K_SECONDS(2)
+#define L2CAP_RTX_TIMEOUT  K_SECONDS(2)
 
 #if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
 /* Dedicated pool for disconnect buffers so they are guaranteed to be send
  * even in case of data congestion due to flooding.
  */
 NET_BUF_POOL_FIXED_DEFINE(disc_pool, 1,
-			  BT_L2CAP_BUF_SIZE(
-				sizeof(struct bt_l2cap_sig_hdr) +
-				sizeof(struct bt_l2cap_disconn_req)),
+			  BT_L2CAP_BUF_SIZE(sizeof(struct bt_l2cap_sig_hdr) +
+					    sizeof(struct bt_l2cap_disconn_req)),
 			  CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);
 
 #define l2cap_lookup_ident(conn, ident) __l2cap_lookup_ident(conn, ident, false)
@@ -87,7 +84,7 @@ static void l2cap_tx_buf_destroy(struct bt_conn *conn, struct net_buf *buf, int
 /* L2CAP signalling channel specific context */
 struct bt_l2cap {
 	/* The channel this context is associated with */
-	struct bt_l2cap_le_chan	chan;
+	struct bt_l2cap_le_chan chan;
 };
 
 static const struct bt_l2cap_ecred_cb *ecred_cb;
@@ -136,8 +133,8 @@ static struct bt_l2cap_le_chan *l2cap_chan_alloc_cid(struct bt_conn *conn,
 	return NULL;
 }
 
-static struct bt_l2cap_le_chan *
-__l2cap_lookup_ident(struct bt_conn *conn, uint16_t ident, bool remove)
+static struct bt_l2cap_le_chan *__l2cap_lookup_ident(struct bt_conn *conn, uint16_t ident,
+						     bool remove)
 {
 	struct bt_l2cap_chan *chan;
 	sys_snode_t *prev = NULL;
@@ -145,8 +142,7 @@ __l2cap_lookup_ident(struct bt_conn *conn, uint16_t ident, bool remove)
 	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
 		if (BT_L2CAP_LE_CHAN(chan)->ident == ident) {
 			if (remove) {
-				sys_slist_remove(&conn->channels, prev,
-						 &chan->node);
+				sys_slist_remove(&conn->channels, prev, &chan->node);
 			}
 			return BT_L2CAP_LE_CHAN(chan);
 		}
@@ -193,8 +189,7 @@ const char *bt_l2cap_chan_state_str(bt_l2cap_chan_state_t state)
 
 #if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
 #if defined(CONFIG_BT_L2CAP_LOG_LEVEL_DBG)
-void bt_l2cap_chan_set_state_debug(struct bt_l2cap_chan *chan,
-				   bt_l2cap_chan_state_t state,
+void bt_l2cap_chan_set_state_debug(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state,
 				   const char *func, int line)
 {
 	struct bt_l2cap_le_chan *le_chan = BT_L2CAP_LE_CHAN(chan);
@@ -218,14 +213,12 @@ void bt_l2cap_chan_set_state_debug(struct bt_l2cap_chan *chan,
 		}
 		break;
 	case BT_L2CAP_CONNECTED:
-		if (le_chan->state != BT_L2CAP_CONFIG &&
-		    le_chan->state != BT_L2CAP_CONNECTING) {
+		if (le_chan->state != BT_L2CAP_CONFIG && le_chan->state != BT_L2CAP_CONNECTING) {
 			LOG_WRN("%s()%d: invalid transition", func, line);
 		}
 		break;
 	case BT_L2CAP_DISCONNECTING:
-		if (le_chan->state != BT_L2CAP_CONFIG &&
-		    le_chan->state != BT_L2CAP_CONNECTED) {
+		if (le_chan->state != BT_L2CAP_CONFIG && le_chan->state != BT_L2CAP_CONNECTED) {
 			LOG_WRN("%s()%d: invalid transition", func, line);
 		}
 		break;
@@ -237,8 +230,7 @@ void bt_l2cap_chan_set_state_debug(struct bt_l2cap_chan *chan,
 	le_chan->state = state;
 }
 #else
-void bt_l2cap_chan_set_state(struct bt_l2cap_chan *chan,
-			     bt_l2cap_chan_state_t state)
+void bt_l2cap_chan_set_state(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state)
 {
 	BT_L2CAP_LE_CHAN(chan)->state = state;
 }
@@ -307,8 +299,7 @@ static void l2cap_rtx_timeout(struct k_work *work)
 	}
 }
 
-static void l2cap_chan_le_recv(struct bt_l2cap_le_chan *chan,
-			       struct net_buf *buf);
+static void l2cap_chan_le_recv(struct bt_l2cap_le_chan *chan, struct net_buf *buf);
 
 static void l2cap_rx_process(struct k_work *work)
 {
@@ -395,8 +386,7 @@ void bt_l2cap_connected(struct bt_conn *conn)
 {
 	struct bt_l2cap_chan *chan;
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		bt_l2cap_br_connected(conn);
 		return;
 	}
@@ -439,8 +429,7 @@ void bt_l2cap_disconnected(struct bt_conn *conn)
 {
 	struct bt_l2cap_chan *chan, *next;
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		bt_l2cap_br_disconnected(conn);
 		return;
 	}
@@ -450,8 +439,7 @@ void bt_l2cap_disconnected(struct bt_conn *conn)
 	}
 }
 
-static struct net_buf *l2cap_create_le_sig_pdu(uint8_t code, uint8_t ident,
-					       uint16_t len)
+static struct net_buf *l2cap_create_le_sig_pdu(uint8_t code, uint8_t ident, uint16_t len)
 {
 	struct bt_l2cap_sig_hdr *hdr;
 	struct net_buf_pool *pool = NULL;
@@ -499,8 +487,8 @@ static int l2cap_send_sig(struct bt_conn *conn, struct net_buf *buf)
 }
 
 #if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
-static void l2cap_chan_send_req(struct bt_l2cap_chan *chan,
-				struct net_buf *buf, k_timeout_t timeout)
+static void l2cap_chan_send_req(struct bt_l2cap_chan *chan, struct net_buf *buf,
+				k_timeout_t timeout)
 {
 	if (l2cap_send_sig(chan->conn, buf)) {
 		return;
@@ -525,8 +513,7 @@ static int l2cap_le_conn_req(struct bt_l2cap_le_chan *ch)
 
 	ch->ident = get_ident();
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_LE_CONN_REQ,
-				      ch->ident, sizeof(*req));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_LE_CONN_REQ, ch->ident, sizeof(*req));
 	if (!buf) {
 		return -ENOMEM;
 	}
@@ -561,8 +548,7 @@ static int l2cap_ecred_conn_req(struct bt_l2cap_chan **chan, int channels)
 	ident = get_ident();
 
 	buf = l2cap_create_le_sig_pdu(BT_L2CAP_ECRED_CONN_REQ, ident,
-				      sizeof(*req) +
-				      (channels * sizeof(uint16_t)));
+				      sizeof(*req) + (channels * sizeof(uint16_t)));
 
 	if (!buf) {
 		return -ENOMEM;
@@ -605,8 +591,7 @@ static void l2cap_le_encrypt_change(struct bt_l2cap_chan *chan, uint8_t status)
 	struct bt_l2cap_le_chan *le = BT_L2CAP_LE_CHAN(chan);
 
 	/* Skip channels that are not pending waiting for encryption */
-	if (!atomic_test_and_clear_bit(chan->status,
-				       BT_L2CAP_STATUS_ENCRYPT_PENDING)) {
+	if (!atomic_test_and_clear_bit(chan->status, BT_L2CAP_STATUS_ENCRYPT_PENDING)) {
 		return;
 	}
 
@@ -653,8 +638,7 @@ void bt_l2cap_security_changed(struct bt_conn *conn, uint8_t hci_status)
 {
 	struct bt_l2cap_chan *chan, *next;
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		l2cap_br_encrypt_change(conn, hci_status);
 		return;
 	}
@@ -670,20 +654,16 @@ void bt_l2cap_security_changed(struct bt_conn *conn, uint8_t hci_status)
 	}
 }
 
-struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool,
-					    size_t reserve,
+struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool, size_t reserve,
 					    k_timeout_t timeout)
 {
-	return bt_conn_create_pdu_timeout(pool,
-					  sizeof(struct bt_l2cap_hdr) + reserve,
-					  timeout);
+	return bt_conn_create_pdu_timeout(pool, sizeof(struct bt_l2cap_hdr) + reserve, timeout);
 }
 
 static void raise_data_ready(struct bt_l2cap_le_chan *le_chan)
 {
 	if (!atomic_set(&le_chan->_pdu_ready_lock, 1)) {
-		sys_slist_append(&le_chan->chan.conn->l2cap_data_ready,
-				 &le_chan->_pdu_ready);
+		sys_slist_append(&le_chan->chan.conn->l2cap_data_ready, &le_chan->_pdu_ready);
 		LOG_DBG("data ready raised %p", le_chan);
 	} else {
 		LOG_DBG("data ready already %p", le_chan);
@@ -712,13 +692,12 @@ static void cancel_data_ready(struct bt_l2cap_le_chan *le_chan)
 
 	LOG_DBG("%p", le_chan);
 
-	sys_slist_find_and_remove(&conn->l2cap_data_ready,
-				  &le_chan->_pdu_ready);
+	sys_slist_find_and_remove(&conn->l2cap_data_ready, &le_chan->_pdu_ready);
 	atomic_set(&le_chan->_pdu_ready_lock, 0);
 }
 
-int bt_l2cap_send_pdu(struct bt_l2cap_le_chan *le_chan, struct net_buf *pdu,
-		      bt_conn_tx_cb_t cb, void *user_data)
+int bt_l2cap_send_pdu(struct bt_l2cap_le_chan *le_chan, struct net_buf *pdu, bt_conn_tx_cb_t cb,
+		      void *user_data)
 {
 	if (!le_chan->chan.conn || le_chan->chan.conn->state != BT_CONN_CONNECTED) {
 		return -ENOTCONN;
@@ -735,10 +714,8 @@ int bt_l2cap_send_pdu(struct bt_l2cap_le_chan *le_chan, struct net_buf *pdu,
 	}
 
 	if (pdu->user_data_size < sizeof(struct closure)) {
-		LOG_DBG("not enough room in user_data %d < %d pool %u",
-			pdu->user_data_size,
-			CONFIG_BT_CONN_TX_USER_DATA_SIZE,
-			pdu->pool_id);
+		LOG_DBG("not enough room in user_data %d < %d pool %u", pdu->user_data_size,
+			CONFIG_BT_CONN_TX_USER_DATA_SIZE, pdu->pool_id);
 		return -EINVAL;
 	}
 
@@ -749,7 +726,7 @@ int bt_l2cap_send_pdu(struct bt_l2cap_le_chan *le_chan, struct net_buf *pdu,
 
 	raise_data_ready(le_chan); /* tis just a flag */
 
-	return 0;		/* look ma, no failures */
+	return 0; /* look ma, no failures */
 }
 
 /* L2CAP channel wants to send a PDU */
@@ -852,8 +829,7 @@ static void l2cap_chan_sdu_sent(struct bt_conn *conn, void *user_data, int err)
 	}
 }
 
-static uint16_t get_pdu_len(struct bt_l2cap_le_chan *lechan,
-			    struct net_buf *buf)
+static uint16_t get_pdu_len(struct bt_l2cap_le_chan *lechan, struct net_buf *buf)
 {
 	if (!L2CAP_LE_CID_IS_DYN(lechan->tx.cid)) {
 		/* No segmentation shenanigans on static channels */
@@ -878,16 +854,12 @@ static bool chan_has_credits(struct bt_l2cap_le_chan *lechan)
 #endif
 }
 
-__weak void bt_test_l2cap_data_pull_spy(struct bt_conn *conn,
-					struct bt_l2cap_le_chan *lechan,
-					size_t amount,
-					size_t *length)
+__weak void bt_test_l2cap_data_pull_spy(struct bt_conn *conn, struct bt_l2cap_le_chan *lechan,
+					size_t amount, size_t *length)
 {
 }
 
-struct net_buf *l2cap_data_pull(struct bt_conn *conn,
-				size_t amount,
-				size_t *length)
+struct net_buf *l2cap_data_pull(struct bt_conn *conn, size_t amount, size_t *length)
 {
 	struct bt_l2cap_le_chan *lechan = get_ready_chan(conn);
 
@@ -940,8 +912,8 @@ struct net_buf *l2cap_data_pull(struct bt_conn *conn,
 		struct bt_l2cap_hdr *hdr;
 		uint16_t pdu_len = get_pdu_len(lechan, pdu);
 
-		LOG_DBG("Adding L2CAP PDU header: buf %p chan %p len %u / %u",
-			pdu, lechan, pdu_len, pdu->len);
+		LOG_DBG("Adding L2CAP PDU header: buf %p chan %p len %u / %u", pdu, lechan, pdu_len,
+			pdu->len);
 
 		LOG_HEXDUMP_DBG(pdu->data, pdu->len, "PDU payload");
 
@@ -974,8 +946,7 @@ struct net_buf *l2cap_data_pull(struct bt_conn *conn,
 
 		LOG_DBG("adding %s callback", sdu_end ? "`sdu_sent`" : "NULL");
 		/* No user callbacks for SDUs */
-		make_closure(pdu->user_data,
-			     sdu_end ? l2cap_chan_sdu_sent : NULL,
+		make_closure(pdu->user_data, sdu_end ? l2cap_chan_sdu_sent : NULL,
 			     sdu_end ? UINT_TO_POINTER(lechan->tx.cid) : NULL);
 	}
 
@@ -1012,14 +983,13 @@ struct net_buf *l2cap_data_pull(struct bt_conn *conn,
 	return pdu;
 }
 
-static void l2cap_send_reject(struct bt_conn *conn, uint8_t ident,
-			      uint16_t reason, void *data, uint8_t data_len)
+static void l2cap_send_reject(struct bt_conn *conn, uint8_t ident, uint16_t reason, void *data,
+			      uint8_t data_len)
 {
 	struct bt_l2cap_cmd_reject *rej;
 	struct net_buf *buf;
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_CMD_REJECT, ident,
-				      sizeof(*rej) + data_len);
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_CMD_REJECT, ident, sizeof(*rej) + data_len);
 	if (!buf) {
 		return;
 	}
@@ -1046,8 +1016,7 @@ static void le_conn_param_rsp(struct bt_l2cap *l2cap, struct net_buf *buf)
 	LOG_DBG("LE conn param rsp result %u", sys_le16_to_cpu(rsp->result));
 }
 
-static void le_conn_param_update_req(struct bt_l2cap *l2cap, uint8_t ident,
-				     struct net_buf *buf)
+static void le_conn_param_update_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_le_conn_param param;
@@ -1066,8 +1035,7 @@ static void le_conn_param_update_req(struct bt_l2cap *l2cap, uint8_t ident,
 	}
 
 	if (conn->role != BT_HCI_ROLE_CENTRAL) {
-		l2cap_send_reject(conn, ident, BT_L2CAP_REJ_NOT_UNDERSTOOD,
-				  NULL, 0);
+		l2cap_send_reject(conn, ident, BT_L2CAP_REJ_NOT_UNDERSTOOD, NULL, 0);
 		return;
 	}
 
@@ -1079,8 +1047,7 @@ static void le_conn_param_update_req(struct bt_l2cap *l2cap, uint8_t ident,
 	LOG_DBG("min 0x%04x max 0x%04x latency: 0x%04x timeout: 0x%04x", param.interval_min,
 		param.interval_max, param.latency, param.timeout);
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_CONN_PARAM_RSP, ident,
-				      sizeof(*rsp));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_CONN_PARAM_RSP, ident, sizeof(*rsp));
 	if (!buf) {
 		return;
 	}
@@ -1101,8 +1068,7 @@ static void le_conn_param_update_req(struct bt_l2cap *l2cap, uint8_t ident,
 	}
 }
 
-struct bt_l2cap_chan *bt_l2cap_le_lookup_tx_cid(struct bt_conn *conn,
-						uint16_t cid)
+struct bt_l2cap_chan *bt_l2cap_le_lookup_tx_cid(struct bt_conn *conn, uint16_t cid)
 {
 	struct bt_l2cap_chan *chan;
 
@@ -1115,8 +1081,7 @@ struct bt_l2cap_chan *bt_l2cap_le_lookup_tx_cid(struct bt_conn *conn,
 	return NULL;
 }
 
-struct bt_l2cap_chan *bt_l2cap_le_lookup_rx_cid(struct bt_conn *conn,
-						uint16_t cid)
+struct bt_l2cap_chan *bt_l2cap_le_lookup_rx_cid(struct bt_conn *conn, uint16_t cid)
 {
 	struct bt_l2cap_chan *chan;
 
@@ -1150,8 +1115,7 @@ int bt_l2cap_server_register(struct bt_l2cap_server *server)
 	}
 
 	if (server->psm) {
-		if (server->psm < L2CAP_LE_PSM_FIXED_START ||
-		    server->psm > L2CAP_LE_PSM_DYN_END) {
+		if (server->psm < L2CAP_LE_PSM_FIXED_START || server->psm > L2CAP_LE_PSM_DYN_END) {
 			return -EINVAL;
 		}
 
@@ -1163,8 +1127,7 @@ int bt_l2cap_server_register(struct bt_l2cap_server *server)
 	} else {
 		uint16_t psm;
 
-		for (psm = L2CAP_LE_PSM_DYN_START;
-		     psm <= L2CAP_LE_PSM_DYN_END; psm++) {
+		for (psm = L2CAP_LE_PSM_DYN_START; psm <= L2CAP_LE_PSM_DYN_END; psm++) {
 			if (!bt_l2cap_server_lookup_psm(psm)) {
 				break;
 			}
@@ -1229,14 +1192,12 @@ static void l2cap_chan_rx_init(struct bt_l2cap_le_chan *chan)
 	/* MPS shall not be bigger than MTU + BT_L2CAP_SDU_HDR_SIZE as the
 	 * remaining bytes cannot be used.
 	 */
-	chan->rx.mps = MIN(chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE,
-			   BT_L2CAP_RX_MTU);
+	chan->rx.mps = MIN(chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE, BT_L2CAP_RX_MTU);
 
 	/* Truncate MTU if channel have disabled segmentation but still have
 	 * set an MTU which requires it.
 	 */
-	if (!chan->chan.ops->alloc_buf &&
-	    (chan->rx.mps < chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE)) {
+	if (!chan->chan.ops->alloc_buf && (chan->rx.mps < chan->rx.mtu + BT_L2CAP_SDU_HDR_SIZE)) {
 		LOG_WRN("Segmentation disabled but MTU > MPS, truncating MTU");
 		chan->rx.mtu = chan->rx.mps - BT_L2CAP_SDU_HDR_SIZE;
 	}
@@ -1269,8 +1230,7 @@ static void l2cap_chan_tx_init(struct bt_l2cap_le_chan *chan)
 	k_fifo_init(&chan->tx_queue);
 }
 
-static void l2cap_chan_tx_give_credits(struct bt_l2cap_le_chan *chan,
-				       uint16_t credits)
+static void l2cap_chan_tx_give_credits(struct bt_l2cap_le_chan *chan, uint16_t credits)
 {
 	LOG_DBG("chan %p credits %u", chan, credits);
 
@@ -1342,10 +1302,9 @@ static uint16_t le_err_to_result(int err)
 	}
 }
 
-static uint16_t l2cap_chan_accept(struct bt_conn *conn,
-			       struct bt_l2cap_server *server, uint16_t scid,
-			       uint16_t mtu, uint16_t mps, uint16_t credits,
-			       struct bt_l2cap_chan **chan)
+static uint16_t l2cap_chan_accept(struct bt_conn *conn, struct bt_l2cap_server *server,
+				  uint16_t scid, uint16_t mtu, uint16_t mps, uint16_t credits,
+				  struct bt_l2cap_chan **chan)
 {
 	struct bt_l2cap_le_chan *le_chan;
 	int err;
@@ -1408,8 +1367,7 @@ static uint16_t l2cap_chan_accept(struct bt_conn *conn,
 	return BT_L2CAP_LE_SUCCESS;
 }
 
-static uint16_t l2cap_check_security(struct bt_conn *conn,
-				 struct bt_l2cap_server *server)
+static uint16_t l2cap_check_security(struct bt_conn *conn, struct bt_l2cap_server *server)
 {
 	if (IS_ENABLED(CONFIG_BT_CONN_DISABLE_SECURITY)) {
 		return BT_L2CAP_LE_SUCCESS;
@@ -1435,8 +1393,7 @@ static uint16_t l2cap_check_security(struct bt_conn *conn,
 	return BT_L2CAP_LE_ERR_AUTHENTICATION;
 }
 
-static void le_conn_req(struct bt_l2cap *l2cap, uint8_t ident,
-			struct net_buf *buf)
+static void le_conn_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan;
@@ -1465,8 +1422,7 @@ static void le_conn_req(struct bt_l2cap *l2cap, uint8_t ident,
 		return;
 	}
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_LE_CONN_RSP, ident,
-				      sizeof(*rsp));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_LE_CONN_RSP, ident, sizeof(*rsp));
 	if (!buf) {
 		return;
 	}
@@ -1487,8 +1443,7 @@ static void le_conn_req(struct bt_l2cap *l2cap, uint8_t ident,
 		goto rsp;
 	}
 
-	result = l2cap_chan_accept(conn, server, scid, mtu, mps, credits,
-				   &chan);
+	result = l2cap_chan_accept(conn, server, scid, mtu, mps, credits, &chan);
 	if (result != BT_L2CAP_LE_SUCCESS) {
 		goto rsp;
 	}
@@ -1517,8 +1472,7 @@ rsp:
 }
 
 #if defined(CONFIG_BT_L2CAP_ECRED)
-static void le_ecred_conn_req(struct bt_l2cap *l2cap, uint8_t ident,
-			      struct net_buf *buf)
+static void le_ecred_conn_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan[BT_L2CAP_ECRED_CHAN_MAX_PER_REQ];
@@ -1582,8 +1536,7 @@ static void le_ecred_conn_req(struct bt_l2cap *l2cap, uint8_t ident,
 		uint16_t rc;
 		scid = net_buf_pull_le16(buf);
 
-		rc = l2cap_chan_accept(conn, server, scid, mtu, mps,
-				credits, &chan[i]);
+		rc = l2cap_chan_accept(conn, server, scid, mtu, mps, credits, &chan[i]);
 		if (rc != BT_L2CAP_LE_SUCCESS) {
 			result = rc;
 		}
@@ -1608,8 +1561,7 @@ static void le_ecred_conn_req(struct bt_l2cap *l2cap, uint8_t ident,
 
 response:
 	buf = l2cap_create_le_sig_pdu(BT_L2CAP_ECRED_CONN_RSP, ident,
-				      sizeof(*rsp) +
-				      (sizeof(scid) * req_cid_count));
+				      sizeof(*rsp) + (sizeof(scid) * req_cid_count));
 	if (!buf) {
 		goto callback;
 	}
@@ -1645,8 +1597,7 @@ callback:
 	}
 }
 
-static void le_ecred_reconf_req(struct bt_l2cap *l2cap, uint8_t ident,
-				struct net_buf *buf)
+static void le_ecred_reconf_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chans[BT_L2CAP_ECRED_CHAN_MAX_PER_REQ];
@@ -1728,8 +1679,7 @@ static void le_ecred_reconf_req(struct bt_l2cap *l2cap, uint8_t ident,
 	LOG_DBG("mtu %u mps %u", mtu, mps);
 
 response:
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_ECRED_RECONF_RSP, ident,
-				      sizeof(*rsp));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_ECRED_RECONF_RSP, ident, sizeof(*rsp));
 	if (!buf) {
 		return;
 	}
@@ -1740,8 +1690,7 @@ response:
 	l2cap_send_sig(conn, buf);
 }
 
-static void le_ecred_reconf_rsp(struct bt_l2cap *l2cap, uint8_t ident,
-				struct net_buf *buf)
+static void le_ecred_reconf_rsp(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_ecred_reconf_rsp *rsp;
@@ -1777,8 +1726,7 @@ static void le_ecred_reconf_rsp(struct bt_l2cap *l2cap, uint8_t ident,
 }
 #endif /* defined(CONFIG_BT_L2CAP_ECRED) */
 
-static struct bt_l2cap_le_chan *l2cap_remove_rx_cid(struct bt_conn *conn,
-						    uint16_t cid)
+static struct bt_l2cap_le_chan *l2cap_remove_rx_cid(struct bt_conn *conn, uint16_t cid)
 {
 	struct bt_l2cap_chan *chan;
 	sys_snode_t *prev = NULL;
@@ -1800,8 +1748,7 @@ static struct bt_l2cap_le_chan *l2cap_remove_rx_cid(struct bt_conn *conn,
 	return NULL;
 }
 
-static void le_disconn_req(struct bt_l2cap *l2cap, uint8_t ident,
-			   struct net_buf *buf)
+static void le_disconn_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_le_chan *chan;
@@ -1825,13 +1772,11 @@ static void le_disconn_req(struct bt_l2cap *l2cap, uint8_t ident,
 		data.scid = req->scid;
 		data.dcid = req->dcid;
 
-		l2cap_send_reject(conn, ident, BT_L2CAP_REJ_INVALID_CID, &data,
-				  sizeof(data));
+		l2cap_send_reject(conn, ident, BT_L2CAP_REJ_INVALID_CID, &data, sizeof(data));
 		return;
 	}
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_DISCONN_RSP, ident,
-				      sizeof(*rsp));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_DISCONN_RSP, ident, sizeof(*rsp));
 	if (!buf) {
 		return;
 	}
@@ -1851,8 +1796,7 @@ static int l2cap_change_security(struct bt_l2cap_le_chan *chan, uint16_t err)
 	bt_security_t sec;
 	int ret;
 
-	if (atomic_test_bit(chan->chan.status,
-			    BT_L2CAP_STATUS_ENCRYPT_PENDING)) {
+	if (atomic_test_bit(chan->chan.status, BT_L2CAP_STATUS_ENCRYPT_PENDING)) {
 		return -EINPROGRESS;
 	}
 
@@ -1890,8 +1834,7 @@ static int l2cap_change_security(struct bt_l2cap_le_chan *chan, uint16_t err)
 }
 
 #if defined(CONFIG_BT_L2CAP_ECRED)
-static void le_ecred_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
-			      struct net_buf *buf)
+static void le_ecred_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_le_chan *chan;
@@ -1993,8 +1936,7 @@ static void le_ecred_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
 			chan->tx.mps = mps;
 
 			/* Update state */
-			bt_l2cap_chan_set_state(&chan->chan,
-						BT_L2CAP_CONNECTED);
+			bt_l2cap_chan_set_state(&chan->chan, BT_L2CAP_CONNECTED);
 
 			if (chan->chan.ops->connected) {
 				chan->chan.ops->connected(&chan->chan);
@@ -2020,8 +1962,7 @@ static void le_ecred_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
 }
 #endif /* CONFIG_BT_L2CAP_ECRED */
 
-static void le_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
-			struct net_buf *buf)
+static void le_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_le_chan *chan;
@@ -2043,8 +1984,7 @@ static void le_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
 		result);
 
 	/* Keep the channel in case of security errors */
-	if (result == BT_L2CAP_LE_SUCCESS ||
-	    result == BT_L2CAP_LE_ERR_AUTHENTICATION ||
+	if (result == BT_L2CAP_LE_SUCCESS || result == BT_L2CAP_LE_ERR_AUTHENTICATION ||
 	    result == BT_L2CAP_LE_ERR_ENCRYPTION) {
 		chan = l2cap_lookup_ident(conn, ident);
 	} else {
@@ -2092,8 +2032,7 @@ static void le_conn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
 	}
 }
 
-static void le_disconn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
-			   struct net_buf *buf)
+static void le_disconn_rsp(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_le_chan *chan;
@@ -2117,8 +2056,7 @@ static void le_disconn_rsp(struct bt_l2cap *l2cap, uint8_t ident,
 	bt_l2cap_chan_del(&chan->chan);
 }
 
-static void le_credits(struct bt_l2cap *l2cap, uint8_t ident,
-		       struct net_buf *buf)
+static void le_credits(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_chan *chan;
@@ -2155,8 +2093,7 @@ static void le_credits(struct bt_l2cap *l2cap, uint8_t ident,
 	LOG_DBG("chan %p total credits %lu", le_chan, atomic_get(&le_chan->tx.credits));
 }
 
-static void reject_cmd(struct bt_l2cap *l2cap, uint8_t ident,
-		       struct net_buf *buf)
+static void reject_cmd(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf)
 {
 	struct bt_conn *conn = l2cap->chan.chan.conn;
 	struct bt_l2cap_le_chan *chan;
@@ -2244,8 +2181,7 @@ static int l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 		__fallthrough;
 	default:
 		LOG_WRN("Rejecting unknown L2CAP PDU code 0x%02x", hdr->code);
-		l2cap_send_reject(chan->conn, hdr->ident,
-				  BT_L2CAP_REJ_NOT_UNDERSTOOD, NULL, 0);
+		l2cap_send_reject(chan->conn, hdr->ident, BT_L2CAP_REJ_NOT_UNDERSTOOD, NULL, 0);
 		break;
 	}
 
@@ -2285,16 +2221,14 @@ static void l2cap_chan_shutdown(struct bt_l2cap_chan *chan)
 	}
 }
 
-static void l2cap_chan_send_credits(struct bt_l2cap_le_chan *chan,
-				    uint16_t credits)
+static void l2cap_chan_send_credits(struct bt_l2cap_le_chan *chan, uint16_t credits)
 {
 	struct bt_l2cap_le_credits *ev;
 	struct net_buf *buf;
 
 	__ASSERT_NO_MSG(bt_l2cap_chan_get_state(&chan->chan) == BT_L2CAP_CONNECTED);
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_LE_CREDITS, get_ident(),
-				      sizeof(*ev));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_LE_CREDITS, get_ident(), sizeof(*ev));
 	if (!buf) {
 		LOG_ERR("Unable to send credits update");
 		/* Disconnect would probably not work either so the only
@@ -2440,8 +2374,7 @@ static struct net_buf *l2cap_alloc_frag(k_timeout_t timeout, void *user_data)
 	return frag;
 }
 
-static void l2cap_chan_le_recv_sdu(struct bt_l2cap_le_chan *chan,
-				   struct net_buf *buf, uint16_t seg)
+static void l2cap_chan_le_recv_sdu(struct bt_l2cap_le_chan *chan, struct net_buf *buf, uint16_t seg)
 {
 	int err;
 
@@ -2466,8 +2399,7 @@ static void l2cap_chan_le_recv_sdu(struct bt_l2cap_le_chan *chan,
 	net_buf_unref(buf);
 }
 
-static void l2cap_chan_le_recv_seg(struct bt_l2cap_le_chan *chan,
-				   struct net_buf *buf)
+static void l2cap_chan_le_recv_seg(struct bt_l2cap_le_chan *chan, struct net_buf *buf)
 {
 	uint16_t len;
 	uint16_t seg = 0U;
@@ -2490,8 +2422,8 @@ static void l2cap_chan_le_recv_seg(struct bt_l2cap_le_chan *chan,
 	LOG_DBG("chan %p seg %d len %zu", chan, seg, buf->len);
 
 	/* Append received segment to SDU */
-	len = net_buf_append_bytes(chan->_sdu, buf->len, buf->data, K_NO_WAIT,
-				   l2cap_alloc_frag, chan);
+	len = net_buf_append_bytes(chan->_sdu, buf->len, buf->data, K_NO_WAIT, l2cap_alloc_frag,
+				   chan);
 	if (len != buf->len) {
 		LOG_ERR("Unable to store SDU");
 		bt_l2cap_chan_disconnect(&chan->chan);
@@ -2567,8 +2499,7 @@ static void l2cap_chan_le_recv_seg_direct(struct bt_l2cap_le_chan *chan, struct
 }
 #endif /* CONFIG_BT_L2CAP_SEG_RECV */
 
-static void l2cap_chan_le_recv(struct bt_l2cap_le_chan *chan,
-			       struct net_buf *buf)
+static void l2cap_chan_le_recv(struct bt_l2cap_le_chan *chan, struct net_buf *buf)
 {
 	struct net_buf *owned_ref;
 	uint16_t sdu_len;
@@ -2628,15 +2559,11 @@ static void l2cap_chan_le_recv(struct bt_l2cap_le_chan *chan,
 
 		/* Send sdu_len/mps worth of credits */
 		uint16_t credits = DIV_ROUND_UP(
-			MIN(sdu_len - buf->len, net_buf_tailroom(chan->_sdu)),
-			chan->rx.mps);
+			MIN(sdu_len - buf->len, net_buf_tailroom(chan->_sdu)), chan->rx.mps);
 
 		if (credits) {
-			LOG_DBG("sending %d extra credits (sdu_len %d buf_len %d mps %d)",
-				credits,
-				sdu_len,
-				buf->len,
-				chan->rx.mps);
+			LOG_DBG("sending %d extra credits (sdu_len %d buf_len %d mps %d)", credits,
+				sdu_len, buf->len, chan->rx.mps);
 			l2cap_chan_send_credits(chan, credits);
 		}
 
@@ -2667,8 +2594,7 @@ static void l2cap_chan_le_recv(struct bt_l2cap_le_chan *chan,
 	}
 }
 
-static void l2cap_chan_recv_queue(struct bt_l2cap_le_chan *chan,
-				  struct net_buf *buf)
+static void l2cap_chan_recv_queue(struct bt_l2cap_le_chan *chan, struct net_buf *buf)
 {
 	if (chan->state == BT_L2CAP_DISCONNECTING) {
 		LOG_WRN("Ignoring data received while disconnecting");
@@ -2693,8 +2619,7 @@ static void l2cap_chan_recv_queue(struct bt_l2cap_le_chan *chan,
 }
 #endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
 
-static void l2cap_chan_recv(struct bt_l2cap_chan *chan, struct net_buf *buf,
-			    bool complete)
+static void l2cap_chan_recv(struct bt_l2cap_chan *chan, struct net_buf *buf, bool complete)
 {
 #if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
 	struct bt_l2cap_le_chan *le_chan = BT_L2CAP_LE_CHAN(chan);
@@ -2726,8 +2651,7 @@ void bt_l2cap_recv(struct bt_conn *conn, struct net_buf *buf, bool complete)
 	struct bt_l2cap_chan *chan;
 	uint16_t cid;
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		bt_l2cap_br_recv(conn, buf);
 		return;
 	}
@@ -2753,14 +2677,12 @@ void bt_l2cap_recv(struct bt_conn *conn, struct net_buf *buf, bool complete)
 	l2cap_chan_recv(chan, buf, complete);
 }
 
-int bt_l2cap_update_conn_param(struct bt_conn *conn,
-			       const struct bt_le_conn_param *param)
+int bt_l2cap_update_conn_param(struct bt_conn *conn, const struct bt_le_conn_param *param)
 {
 	struct bt_l2cap_conn_param_req *req;
 	struct net_buf *buf;
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_CONN_PARAM_REQ,
-				      get_ident(), sizeof(*req));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_CONN_PARAM_REQ, get_ident(), sizeof(*req));
 	if (!buf) {
 		return -ENOMEM;
 	}
@@ -2833,8 +2755,7 @@ void bt_l2cap_init(void)
 }
 
 #if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
-static int l2cap_le_connect(struct bt_conn *conn, struct bt_l2cap_le_chan *ch,
-			    uint16_t psm)
+static int l2cap_le_connect(struct bt_conn *conn, struct bt_l2cap_le_chan *ch, uint16_t psm)
 {
 	int err;
 
@@ -2857,8 +2778,7 @@ static int l2cap_le_connect(struct bt_conn *conn, struct bt_l2cap_le_chan *ch,
 			goto fail;
 		}
 
-		atomic_set_bit(ch->chan.status,
-			       BT_L2CAP_STATUS_ENCRYPT_PENDING);
+		atomic_set_bit(ch->chan.status, BT_L2CAP_STATUS_ENCRYPT_PENDING);
 
 		return 0;
 	}
@@ -2877,8 +2797,7 @@ fail:
 }
 
 #if defined(CONFIG_BT_L2CAP_ECRED)
-static int l2cap_ecred_init(struct bt_conn *conn,
-			       struct bt_l2cap_le_chan *ch, uint16_t psm)
+static int l2cap_ecred_init(struct bt_conn *conn, struct bt_l2cap_le_chan *ch, uint16_t psm)
 {
 
 	if (psm < L2CAP_LE_PSM_FIXED_START || psm > L2CAP_LE_PSM_DYN_END) {
@@ -2899,8 +2818,7 @@ static int l2cap_ecred_init(struct bt_conn *conn,
 	return 0;
 }
 
-int bt_l2cap_ecred_chan_connect(struct bt_conn *conn,
-				struct bt_l2cap_chan **chan, uint16_t psm)
+int bt_l2cap_ecred_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan **chan, uint16_t psm)
 {
 	int i, err;
 
@@ -3004,8 +2922,7 @@ int bt_l2cap_ecred_chan_reconfigure(struct bt_l2cap_chan **chans, uint16_t mtu)
 
 	ident = get_ident();
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_ECRED_RECONF_REQ,
-				      ident,
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_ECRED_RECONF_REQ, ident,
 				      sizeof(*req) + (i * sizeof(uint16_t)));
 	if (!buf) {
 		return -ENOMEM;
@@ -3017,8 +2934,7 @@ int bt_l2cap_ecred_chan_reconfigure(struct bt_l2cap_chan **chans, uint16_t mtu)
 	/* MPS shall not be bigger than MTU + BT_L2CAP_SDU_HDR_SIZE
 	 * as the remaining bytes cannot be used.
 	 */
-	req->mps = sys_cpu_to_le16(MIN(mtu + BT_L2CAP_SDU_HDR_SIZE,
-				       BT_L2CAP_RX_MTU));
+	req->mps = sys_cpu_to_le16(MIN(mtu + BT_L2CAP_SDU_HDR_SIZE, BT_L2CAP_RX_MTU));
 
 	for (int j = 0; j < i; j++) {
 		ch = BT_L2CAP_LE_CHAN(chans[j]);
@@ -3128,8 +3044,7 @@ int bt_l2cap_ecred_chan_reconfigure_explicit(struct bt_l2cap_chan **chans, size_
 
 #endif /* defined(CONFIG_BT_L2CAP_ECRED) */
 
-int bt_l2cap_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
-			  uint16_t psm)
+int bt_l2cap_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan, uint16_t psm)
 {
 	struct bt_l2cap_le_chan *le_chan = BT_L2CAP_LE_CHAN(chan);
 
@@ -3143,8 +3058,7 @@ int bt_l2cap_chan_connect(struct bt_conn *conn, struct bt_l2cap_chan *chan,
 		return -EINVAL;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		return bt_l2cap_br_chan_connect(conn, chan, psm);
 	}
 
@@ -3168,8 +3082,7 @@ int bt_l2cap_chan_disconnect(struct bt_l2cap_chan *chan)
 		return -ENOTCONN;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && conn->type == BT_CONN_TYPE_BR) {
 		return bt_l2cap_br_chan_disconnect(chan);
 	}
 
@@ -3179,8 +3092,7 @@ int bt_l2cap_chan_disconnect(struct bt_l2cap_chan *chan)
 
 	le_chan->ident = get_ident();
 
-	buf = l2cap_create_le_sig_pdu(BT_L2CAP_DISCONN_REQ,
-				      le_chan->ident, sizeof(*req));
+	buf = l2cap_create_le_sig_pdu(BT_L2CAP_DISCONN_REQ, le_chan->ident, sizeof(*req));
 	if (!buf) {
 		return -ENOMEM;
 	}
@@ -3219,8 +3131,7 @@ static int bt_l2cap_dyn_chan_send(struct bt_l2cap_le_chan *le_chan, struct net_b
 	__ASSERT_NO_MSG(buf->frags == NULL);
 
 	if (sdu_len > le_chan->tx.mtu) {
-		LOG_ERR("attempt to send %u bytes on %u MTU chan",
-			sdu_len, le_chan->tx.mtu);
+		LOG_ERR("attempt to send %u bytes on %u MTU chan", sdu_len, le_chan->tx.mtu);
 		return -EMSGSIZE;
 	}
 
@@ -3298,8 +3209,7 @@ int bt_l2cap_chan_send(struct bt_l2cap_chan *chan, struct net_buf *buf)
 		return -ESHUTDOWN;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CLASSIC) &&
-	    chan->conn->type == BT_CONN_TYPE_BR) {
+	if (IS_ENABLED(CONFIG_BT_CLASSIC) && chan->conn->type == BT_CONN_TYPE_BR) {
 		return bt_l2cap_br_chan_send_cb(chan, buf, NULL, NULL);
 	}
 
diff --git a/subsys/bluetooth/host/l2cap_internal.h b/subsys/bluetooth/host/l2cap_internal.h
index 60f614b7caa..daab43c7e84 100644
--- a/subsys/bluetooth/host/l2cap_internal.h
+++ b/subsys/bluetooth/host/l2cap_internal.h
@@ -17,13 +17,13 @@ enum l2cap_conn_list_action {
 	BT_L2CAP_CHAN_DETACH,
 };
 
-#define BT_L2CAP_CID_BR_SIG             0x0001
-#define BT_L2CAP_CID_ATT                0x0004
-#define BT_L2CAP_CID_LE_SIG             0x0005
-#define BT_L2CAP_CID_SMP                0x0006
-#define BT_L2CAP_CID_BR_SMP             0x0007
+#define BT_L2CAP_CID_BR_SIG 0x0001
+#define BT_L2CAP_CID_ATT    0x0004
+#define BT_L2CAP_CID_LE_SIG 0x0005
+#define BT_L2CAP_CID_SMP    0x0006
+#define BT_L2CAP_CID_BR_SMP 0x0007
 
-#define BT_L2CAP_PSM_RFCOMM             0x0003
+#define BT_L2CAP_PSM_RFCOMM 0x0003
 
 struct bt_l2cap_hdr {
 	uint16_t len;
@@ -31,19 +31,19 @@ struct bt_l2cap_hdr {
 } __packed;
 
 struct bt_l2cap_sig_hdr {
-	uint8_t  code;
-	uint8_t  ident;
+	uint8_t code;
+	uint8_t ident;
 	uint16_t len;
 } __packed;
 
-#define BT_L2CAP_REJ_NOT_UNDERSTOOD     0x0000
-#define BT_L2CAP_REJ_MTU_EXCEEDED       0x0001
-#define BT_L2CAP_REJ_INVALID_CID        0x0002
+#define BT_L2CAP_REJ_NOT_UNDERSTOOD 0x0000
+#define BT_L2CAP_REJ_MTU_EXCEEDED   0x0001
+#define BT_L2CAP_REJ_INVALID_CID    0x0002
 
-#define BT_L2CAP_CMD_REJECT             0x01
+#define BT_L2CAP_CMD_REJECT 0x01
 struct bt_l2cap_cmd_reject {
 	uint16_t reason;
-	uint8_t  data[0];
+	uint8_t data[0];
 } __packed;
 
 struct bt_l2cap_cmd_reject_cid_data {
@@ -51,19 +51,19 @@ struct bt_l2cap_cmd_reject_cid_data {
 	uint16_t dcid;
 } __packed;
 
-#define BT_L2CAP_DISCONN_REQ            0x06
+#define BT_L2CAP_DISCONN_REQ 0x06
 struct bt_l2cap_disconn_req {
 	uint16_t dcid;
 	uint16_t scid;
 } __packed;
 
-#define BT_L2CAP_DISCONN_RSP            0x07
+#define BT_L2CAP_DISCONN_RSP 0x07
 struct bt_l2cap_disconn_rsp {
 	uint16_t dcid;
 	uint16_t scid;
 } __packed;
 
-#define BT_L2CAP_CONN_PARAM_REQ         0x12
+#define BT_L2CAP_CONN_PARAM_REQ 0x12
 struct bt_l2cap_conn_param_req {
 	uint16_t min_interval;
 	uint16_t max_interval;
@@ -71,15 +71,15 @@ struct bt_l2cap_conn_param_req {
 	uint16_t timeout;
 } __packed;
 
-#define BT_L2CAP_CONN_PARAM_ACCEPTED    0x0000
-#define BT_L2CAP_CONN_PARAM_REJECTED    0x0001
+#define BT_L2CAP_CONN_PARAM_ACCEPTED 0x0000
+#define BT_L2CAP_CONN_PARAM_REJECTED 0x0001
 
-#define BT_L2CAP_CONN_PARAM_RSP         0x13
+#define BT_L2CAP_CONN_PARAM_RSP 0x13
 struct bt_l2cap_conn_param_rsp {
 	uint16_t result;
 } __packed;
 
-#define BT_L2CAP_LE_CONN_REQ            0x14
+#define BT_L2CAP_LE_CONN_REQ 0x14
 struct bt_l2cap_le_conn_req {
 	uint16_t psm;
 	uint16_t scid;
@@ -101,7 +101,7 @@ struct bt_l2cap_le_conn_req {
 #define BT_L2CAP_LE_ERR_UNACCEPT_PARAMS 0x000B
 #define BT_L2CAP_LE_ERR_INVALID_PARAMS  0x000C
 
-#define BT_L2CAP_LE_CONN_RSP            0x15
+#define BT_L2CAP_LE_CONN_RSP 0x15
 struct bt_l2cap_le_conn_rsp {
 	uint16_t dcid;
 	uint16_t mtu;
@@ -110,13 +110,13 @@ struct bt_l2cap_le_conn_rsp {
 	uint16_t result;
 } __packed;
 
-#define BT_L2CAP_LE_CREDITS             0x16
+#define BT_L2CAP_LE_CREDITS 0x16
 struct bt_l2cap_le_credits {
 	uint16_t cid;
 	uint16_t credits;
 } __packed;
 
-#define BT_L2CAP_ECRED_CONN_REQ         0x17
+#define BT_L2CAP_ECRED_CONN_REQ 0x17
 struct bt_l2cap_ecred_conn_req {
 	uint16_t psm;
 	uint16_t mtu;
@@ -125,7 +125,7 @@ struct bt_l2cap_ecred_conn_req {
 	uint16_t scid[0];
 } __packed;
 
-#define BT_L2CAP_ECRED_CONN_RSP         0x18
+#define BT_L2CAP_ECRED_CONN_RSP 0x18
 struct bt_l2cap_ecred_conn_rsp {
 	uint16_t mtu;
 	uint16_t mps;
@@ -134,36 +134,36 @@ struct bt_l2cap_ecred_conn_rsp {
 	uint16_t dcid[0];
 } __packed;
 
-#define BT_L2CAP_ECRED_RECONF_REQ       0x19
+#define BT_L2CAP_ECRED_RECONF_REQ 0x19
 struct bt_l2cap_ecred_reconf_req {
 	uint16_t mtu;
 	uint16_t mps;
 	uint16_t scid[0];
 } __packed;
 
-#define BT_L2CAP_RECONF_SUCCESS         0x0000
-#define BT_L2CAP_RECONF_INVALID_MTU     0x0001
-#define BT_L2CAP_RECONF_INVALID_MPS     0x0002
-#define BT_L2CAP_RECONF_INVALID_CID     0x0003
-#define BT_L2CAP_RECONF_OTHER_UNACCEPT  0x0004
+#define BT_L2CAP_RECONF_SUCCESS        0x0000
+#define BT_L2CAP_RECONF_INVALID_MTU    0x0001
+#define BT_L2CAP_RECONF_INVALID_MPS    0x0002
+#define BT_L2CAP_RECONF_INVALID_CID    0x0003
+#define BT_L2CAP_RECONF_OTHER_UNACCEPT 0x0004
 
-#define BT_L2CAP_ECRED_RECONF_RSP       0x1a
+#define BT_L2CAP_ECRED_RECONF_RSP 0x1a
 struct bt_l2cap_ecred_reconf_rsp {
 	uint16_t result;
 } __packed;
 
 struct bt_l2cap_fixed_chan {
-	uint16_t		cid;
+	uint16_t cid;
 	int (*accept)(struct bt_conn *conn, struct bt_l2cap_chan **chan);
 	bt_l2cap_chan_destroy_t destroy;
 };
 
-#define BT_L2CAP_CHANNEL_DEFINE(_name, _cid, _accept, _destroy)         \
-	const STRUCT_SECTION_ITERABLE(bt_l2cap_fixed_chan, _name) = {   \
-				.cid = _cid,                            \
-				.accept = _accept,                      \
-				.destroy = _destroy,                    \
-			}
+#define BT_L2CAP_CHANNEL_DEFINE(_name, _cid, _accept, _destroy)                                    \
+	const STRUCT_SECTION_ITERABLE(bt_l2cap_fixed_chan, _name) = {                              \
+		.cid = _cid,                                                                       \
+		.accept = _accept,                                                                 \
+		.destroy = _destroy,                                                               \
+	}
 
 /* Notify L2CAP channels of a new connection */
 void bt_l2cap_connected(struct bt_conn *conn);
@@ -184,14 +184,12 @@ void bt_l2cap_chan_del(struct bt_l2cap_chan *chan);
 const char *bt_l2cap_chan_state_str(bt_l2cap_chan_state_t state);
 
 #if defined(CONFIG_BT_L2CAP_LOG_LEVEL_DBG)
-void bt_l2cap_chan_set_state_debug(struct bt_l2cap_chan *chan,
-				   bt_l2cap_chan_state_t state,
+void bt_l2cap_chan_set_state_debug(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state,
 				   const char *func, int line);
-#define bt_l2cap_chan_set_state(_chan, _state) \
+#define bt_l2cap_chan_set_state(_chan, _state)                                                     \
 	bt_l2cap_chan_set_state_debug(_chan, _state, __func__, __LINE__)
 #else
-void bt_l2cap_chan_set_state(struct bt_l2cap_chan *chan,
-			     bt_l2cap_chan_state_t state);
+void bt_l2cap_chan_set_state(struct bt_l2cap_chan *chan, bt_l2cap_chan_state_t state);
 #endif /* CONFIG_BT_L2CAP_LOG_LEVEL_DBG */
 
 /*
@@ -201,37 +199,32 @@ void bt_l2cap_chan_set_state(struct bt_l2cap_chan *chan,
 void bt_l2cap_security_changed(struct bt_conn *conn, uint8_t hci_status);
 
 /* Prepare an L2CAP PDU to be sent over a connection */
-struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool,
-					    size_t reserve,
+struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool, size_t reserve,
 					    k_timeout_t timeout);
 
-#define bt_l2cap_create_pdu(_pool, _reserve) \
-	bt_l2cap_create_pdu_timeout(_pool, _reserve, K_FOREVER)
+#define bt_l2cap_create_pdu(_pool, _reserve) bt_l2cap_create_pdu_timeout(_pool, _reserve, K_FOREVER)
 
 /* Send L2CAP PDU over a connection
  *
  * Buffer ownership is transferred to stack in case of success.
  */
-int bt_l2cap_send_pdu(struct bt_l2cap_le_chan *le_chan, struct net_buf *pdu,
-		      bt_conn_tx_cb_t cb, void *user_data);
+int bt_l2cap_send_pdu(struct bt_l2cap_le_chan *le_chan, struct net_buf *pdu, bt_conn_tx_cb_t cb,
+		      void *user_data);
 
 /* Receive a new L2CAP PDU from a connection */
 void bt_l2cap_recv(struct bt_conn *conn, struct net_buf *buf, bool complete);
 
 /* Perform connection parameter update request */
-int bt_l2cap_update_conn_param(struct bt_conn *conn,
-			       const struct bt_le_conn_param *param);
+int bt_l2cap_update_conn_param(struct bt_conn *conn, const struct bt_le_conn_param *param);
 
 /* Initialize L2CAP and supported channels */
 void bt_l2cap_init(void);
 
 /* Lookup channel by Transmission CID */
-struct bt_l2cap_chan *bt_l2cap_le_lookup_tx_cid(struct bt_conn *conn,
-						uint16_t cid);
+struct bt_l2cap_chan *bt_l2cap_le_lookup_tx_cid(struct bt_conn *conn, uint16_t cid);
 
 /* Lookup channel by Receiver CID */
-struct bt_l2cap_chan *bt_l2cap_le_lookup_rx_cid(struct bt_conn *conn,
-						uint16_t cid);
+struct bt_l2cap_chan *bt_l2cap_le_lookup_rx_cid(struct bt_conn *conn, uint16_t cid);
 
 struct bt_l2cap_ecred_cb {
 	void (*ecred_conn_rsp)(struct bt_conn *conn, uint16_t result, uint8_t attempted,
@@ -246,6 +239,4 @@ void bt_l2cap_register_ecred_cb(const struct bt_l2cap_ecred_cb *cb);
 struct bt_l2cap_server *bt_l2cap_server_lookup_psm(uint16_t psm);
 
 /* Pull data from the L2CAP layer */
-struct net_buf *l2cap_data_pull(struct bt_conn *conn,
-				size_t amount,
-				size_t *length);
+struct net_buf *l2cap_data_pull(struct bt_conn *conn, size_t amount, size_t *length);
diff --git a/subsys/bluetooth/host/long_wq.c b/subsys/bluetooth/host/long_wq.c
index b7b6e3dc03b..c6c287b28b7 100644
--- a/subsys/bluetooth/host/long_wq.c
+++ b/subsys/bluetooth/host/long_wq.c
@@ -33,8 +33,7 @@ static int long_wq_init(void)
 
 	k_work_queue_init(&bt_long_wq);
 
-	k_work_queue_start(&bt_long_wq, bt_lw_stack_area,
-			   K_THREAD_STACK_SIZEOF(bt_lw_stack_area),
+	k_work_queue_start(&bt_long_wq, bt_lw_stack_area, K_THREAD_STACK_SIZEOF(bt_lw_stack_area),
 			   CONFIG_BT_LONG_WQ_PRIO, &cfg);
 
 	return 0;
diff --git a/subsys/bluetooth/host/monitor.c b/subsys/bluetooth/host/monitor.c
index a02f115c966..14ae2427ccd 100644
--- a/subsys/bluetooth/host/monitor.c
+++ b/subsys/bluetooth/host/monitor.c
@@ -36,10 +36,10 @@
 #define MONITOR_INIT_PRIORITY 60
 
 /* These defines follow the values used by syslog(2) */
-#define BT_LOG_ERR      3
-#define BT_LOG_WARN     4
-#define BT_LOG_INFO     6
-#define BT_LOG_DBG      7
+#define BT_LOG_ERR  3
+#define BT_LOG_WARN 4
+#define BT_LOG_INFO 6
+#define BT_LOG_DBG  7
 
 /* TS resolution is 1/10th of a millisecond */
 #define MONITOR_TS_FREQ 10000
@@ -101,7 +101,7 @@ static void drop_add(uint16_t opcode)
 static bool panic_mode;
 
 #define RTT_BUFFER_NAME CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER_NAME
-#define RTT_BUF_SIZE CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER_SIZE
+#define RTT_BUF_SIZE    CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER_SIZE
 
 static void monitor_send(const void *data, size_t len)
 {
@@ -129,8 +129,8 @@ static void monitor_send(const void *data, size_t len)
 		if (!panic_mode) {
 			SEGGER_RTT_LOCK();
 		}
-		cnt = SEGGER_RTT_WriteNoLock(CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER,
-					     rtt_buf, rtt_buf_offset);
+		cnt = SEGGER_RTT_WriteNoLock(CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER, rtt_buf,
+					     rtt_buf_offset);
 		if (!panic_mode) {
 			SEGGER_RTT_UNLOCK();
 		}
@@ -175,8 +175,7 @@ static void monitor_send(const void *data, size_t len)
 }
 #endif /* CONFIG_BT_DEBUG_MONITOR_UART */
 
-static void encode_drops(struct bt_monitor_hdr *hdr, uint8_t type,
-			 atomic_t *val)
+static void encode_drops(struct bt_monitor_hdr *hdr, uint8_t type, atomic_t *val)
 {
 	atomic_val_t count;
 
@@ -200,13 +199,13 @@ static uint32_t monitor_ts_get(void)
 	return (cycle / (sys_clock_hw_cycles_per_sec() / MONITOR_TS_FREQ));
 }
 
-static inline void encode_hdr(struct bt_monitor_hdr *hdr, uint32_t timestamp,
-			      uint16_t opcode, uint16_t len)
+static inline void encode_hdr(struct bt_monitor_hdr *hdr, uint32_t timestamp, uint16_t opcode,
+			      uint16_t len)
 {
 	struct bt_monitor_ts32 *ts;
 
-	hdr->opcode   = sys_cpu_to_le16(opcode);
-	hdr->flags    = 0U;
+	hdr->opcode = sys_cpu_to_le16(opcode);
+	hdr->flags = 0U;
 
 	ts = (void *)hdr->ext;
 	ts->type = BT_MONITOR_TS32;
@@ -243,8 +242,7 @@ void bt_monitor_send(uint16_t opcode, const void *data, size_t len)
 	atomic_clear_bit(&flags, BT_LOG_BUSY);
 }
 
-void bt_monitor_new_index(uint8_t type, uint8_t bus, const bt_addr_t *addr,
-			  const char *name)
+void bt_monitor_new_index(uint8_t type, uint8_t bus, const bt_addr_t *addr, const char *name)
 {
 	struct bt_monitor_new_index pkt;
 
@@ -299,8 +297,7 @@ static int monitor_log_out(uint8_t *data, size_t length, void *user_data)
 		/* With CONFIG_LOG_PRINTK the line terminator will come as
 		 * as part of messages.
 		 */
-		if (IS_ENABLED(CONFIG_LOG_PRINTK) &&
-		    (data[i] == '\r' || data[i] == '\n')) {
+		if (IS_ENABLED(CONFIG_LOG_PRINTK) && (data[i] == '\r' || data[i] == '\n')) {
 			break;
 		}
 
@@ -317,11 +314,9 @@ LOG_OUTPUT_DEFINE(monitor_log_output, monitor_log_out, &buf, 1);
 static inline uint8_t monitor_priority_get(uint8_t log_level)
 {
 	static const uint8_t prios[] = {
-		[LOG_LEVEL_NONE]  = 0,
-		[LOG_LEVEL_ERR]   = BT_LOG_ERR,
-		[LOG_LEVEL_WRN]   = BT_LOG_WARN,
-		[LOG_LEVEL_INF]   = BT_LOG_INFO,
-		[LOG_LEVEL_DBG]   = BT_LOG_DBG,
+		[LOG_LEVEL_NONE] = 0,          [LOG_LEVEL_ERR] = BT_LOG_ERR,
+		[LOG_LEVEL_WRN] = BT_LOG_WARN, [LOG_LEVEL_INF] = BT_LOG_INFO,
+		[LOG_LEVEL_DBG] = BT_LOG_DBG,
 	};
 
 	if (log_level < ARRAY_SIZE(prios)) {
@@ -331,8 +326,7 @@ static inline uint8_t monitor_priority_get(uint8_t log_level)
 	return BT_LOG_DBG;
 }
 
-static void monitor_log_process(const struct log_backend *const backend,
-				union log_msg_generic *msg)
+static void monitor_log_process(const struct log_backend *const backend, union log_msg_generic *msg)
 {
 	struct bt_monitor_user_logging user_log;
 	struct monitor_log_ctx ctx;
@@ -342,16 +336,14 @@ static void monitor_log_process(const struct log_backend *const backend,
 	log_output_ctx_set(&monitor_log_output, &ctx);
 
 	ctx.total_len = 0;
-	log_output_msg_process(&monitor_log_output, &msg->log,
-			       LOG_OUTPUT_FLAG_CRLF_NONE);
+	log_output_msg_process(&monitor_log_output, &msg->log, LOG_OUTPUT_FLAG_CRLF_NONE);
 
 	if (atomic_test_and_set_bit(&flags, BT_LOG_BUSY)) {
 		drop_add(BT_MONITOR_USER_LOGGING);
 		return;
 	}
 
-	encode_hdr(&hdr, (uint32_t)log_msg_get_timestamp(&msg->log),
-		   BT_MONITOR_USER_LOGGING,
+	encode_hdr(&hdr, (uint32_t)log_msg_get_timestamp(&msg->log), BT_MONITOR_USER_LOGGING,
 		   sizeof(user_log) + sizeof(id) + ctx.total_len + 1);
 
 	user_log.priority = monitor_priority_get(log_msg_get_level(&msg->log));
@@ -395,9 +387,8 @@ static int bt_monitor_init(void)
 #if defined(CONFIG_BT_DEBUG_MONITOR_RTT)
 	static uint8_t rtt_up_buf[RTT_BUF_SIZE];
 
-	SEGGER_RTT_ConfigUpBuffer(CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER,
-				  RTT_BUFFER_NAME, rtt_up_buf, RTT_BUF_SIZE,
-				  SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+	SEGGER_RTT_ConfigUpBuffer(CONFIG_BT_DEBUG_MONITOR_RTT_BUFFER, RTT_BUFFER_NAME, rtt_up_buf,
+				  RTT_BUF_SIZE, SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 #elif defined(CONFIG_BT_DEBUG_MONITOR_UART)
 	__ASSERT_NO_MSG(device_is_ready(monitor_dev));
 
diff --git a/subsys/bluetooth/host/monitor.h b/subsys/bluetooth/host/monitor.h
index e5a6422bfd8..08dd0d6be11 100644
--- a/subsys/bluetooth/host/monitor.h
+++ b/subsys/bluetooth/host/monitor.h
@@ -28,8 +28,8 @@
 #define BT_MONITOR_ISO_RX_PKT   19
 #define BT_MONITOR_NOP          255
 
-#define BT_MONITOR_TYPE_PRIMARY	0
-#define BT_MONITOR_TYPE_AMP	1
+#define BT_MONITOR_TYPE_PRIMARY 0
+#define BT_MONITOR_TYPE_AMP     1
 
 /* Extended header types */
 #define BT_MONITOR_COMMAND_DROPS 1
@@ -41,7 +41,7 @@
 #define BT_MONITOR_OTHER_DROPS   7
 #define BT_MONITOR_TS32          8
 
-#define BT_MONITOR_BASE_HDR_LEN  6
+#define BT_MONITOR_BASE_HDR_LEN 6
 
 #if defined(CONFIG_BT_CLASSIC)
 #define BT_MONITOR_EXT_HDR_MAX 19
@@ -50,29 +50,29 @@
 #endif
 
 struct bt_monitor_hdr {
-	uint16_t  data_len;
-	uint16_t  opcode;
-	uint8_t   flags;
-	uint8_t   hdr_len;
+	uint16_t data_len;
+	uint16_t opcode;
+	uint8_t flags;
+	uint8_t hdr_len;
 
-	uint8_t   ext[BT_MONITOR_EXT_HDR_MAX];
+	uint8_t ext[BT_MONITOR_EXT_HDR_MAX];
 } __packed;
 
 struct bt_monitor_ts32 {
-	uint8_t   type;
-	uint32_t  ts32;
+	uint8_t type;
+	uint32_t ts32;
 } __packed;
 
 struct bt_monitor_new_index {
-	uint8_t  type;
-	uint8_t  bus;
-	uint8_t  bdaddr[6];
-	char  name[8];
+	uint8_t type;
+	uint8_t bus;
+	uint8_t bdaddr[6];
+	char name[8];
 } __packed;
 
 struct bt_monitor_user_logging {
-	uint8_t  priority;
-	uint8_t  ident_len;
+	uint8_t priority;
+	uint8_t ident_len;
 } __packed;
 
 static inline uint8_t bt_monitor_opcode(struct net_buf *buf)
@@ -97,8 +97,7 @@ static inline uint8_t bt_monitor_opcode(struct net_buf *buf)
 
 void bt_monitor_send(uint16_t opcode, const void *data, size_t len);
 
-void bt_monitor_new_index(uint8_t type, uint8_t bus, const bt_addr_t *addr,
-			  const char *name);
+void bt_monitor_new_index(uint8_t type, uint8_t bus, const bt_addr_t *addr, const char *name);
 
 #else /* !CONFIG_BT_MONITOR */
 
diff --git a/subsys/bluetooth/host/scan.c b/subsys/bluetooth/host/scan.c
index 05ad120fb38..18de83959e5 100644
--- a/subsys/bluetooth/host/scan.c
+++ b/subsys/bluetooth/host/scan.c
@@ -242,9 +242,8 @@ static int start_le_scan_ext(struct bt_le_scan_param *scan_param)
 	}
 
 	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EXT_SCAN_PARAM,
-				sizeof(*set_param) +
-				(phy_1m ? sizeof(*phy_1m) : 0) +
-				(phy_coded ? sizeof(*phy_coded) : 0));
+				sizeof(*set_param) + (phy_1m ? sizeof(*phy_1m) : 0) +
+					(phy_coded ? sizeof(*phy_coded) : 0));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -450,8 +449,7 @@ static int scan_update(void)
 			LOG_DBG("Could not stop scanner: %d", err);
 			break;
 		}
-		memset(&scan_state.used_scan_param, 0x0,
-		       sizeof(scan_state.used_scan_param));
+		memset(&scan_state.used_scan_param, 0x0, sizeof(scan_state.used_scan_param));
 		break;
 	case SCAN_ACTION_UPDATE:
 		err = cmd_le_set_scan_enable(BT_HCI_LE_SCAN_DISABLE,
@@ -531,8 +529,8 @@ int bt_le_scan_user_remove(enum bt_le_scan_user flag)
 }
 
 #if defined(CONFIG_BT_CENTRAL)
-static void check_pending_conn(const bt_addr_le_t *id_addr,
-			       const bt_addr_le_t *addr, uint8_t adv_props)
+static void check_pending_conn(const bt_addr_le_t *id_addr, const bt_addr_le_t *addr,
+			       uint8_t adv_props)
 {
 	struct bt_conn *conn;
 	int err;
@@ -550,8 +548,7 @@ static void check_pending_conn(const bt_addr_le_t *id_addr,
 		return;
 	}
 
-	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, id_addr,
-				       BT_CONN_SCAN_BEFORE_INITIATING);
+	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, id_addr, BT_CONN_SCAN_BEFORE_INITIATING);
 	if (!conn) {
 		return;
 	}
@@ -592,12 +589,10 @@ static uint8_t get_adv_props_legacy(uint8_t evt_type)
 {
 	switch (evt_type) {
 	case BT_GAP_ADV_TYPE_ADV_IND:
-		return BT_GAP_ADV_PROP_CONNECTABLE |
-		       BT_GAP_ADV_PROP_SCANNABLE;
+		return BT_GAP_ADV_PROP_CONNECTABLE | BT_GAP_ADV_PROP_SCANNABLE;
 
 	case BT_GAP_ADV_TYPE_ADV_DIRECT_IND:
-		return BT_GAP_ADV_PROP_CONNECTABLE |
-		       BT_GAP_ADV_PROP_DIRECTED;
+		return BT_GAP_ADV_PROP_CONNECTABLE | BT_GAP_ADV_PROP_DIRECTED;
 
 	case BT_GAP_ADV_TYPE_ADV_SCAN_IND:
 		return BT_GAP_ADV_PROP_SCANNABLE;
@@ -610,8 +605,7 @@ static uint8_t get_adv_props_legacy(uint8_t evt_type)
 	 * set connectable property bit.
 	 */
 	case BT_GAP_ADV_TYPE_SCAN_RSP:
-		return BT_GAP_ADV_PROP_SCAN_RESPONSE |
-		       BT_GAP_ADV_PROP_SCANNABLE;
+		return BT_GAP_ADV_PROP_SCAN_RESPONSE | BT_GAP_ADV_PROP_SCANNABLE;
 
 	default:
 		return 0;
@@ -640,8 +634,7 @@ static void le_adv_recv(bt_addr_le_t *addr, struct bt_le_scan_recv_info *info,
 	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
 		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
 	} else {
-		bt_addr_le_copy(&id_addr,
-				bt_lookup_id_addr(BT_ID_DEFAULT, addr));
+		bt_addr_le_copy(&id_addr, bt_lookup_id_addr(BT_ID_DEFAULT, addr));
 	}
 
 	if (scan_dev_found_cb) {
@@ -708,29 +701,23 @@ void bt_hci_le_scan_timeout(struct net_buf *buf)
 static uint8_t get_adv_type(uint8_t evt_type)
 {
 	switch (evt_type) {
-	case (BT_HCI_LE_ADV_EVT_TYPE_CONN |
-	      BT_HCI_LE_ADV_EVT_TYPE_SCAN |
+	case (BT_HCI_LE_ADV_EVT_TYPE_CONN | BT_HCI_LE_ADV_EVT_TYPE_SCAN |
 	      BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
 		return BT_GAP_ADV_TYPE_ADV_IND;
 
-	case (BT_HCI_LE_ADV_EVT_TYPE_CONN |
-	      BT_HCI_LE_ADV_EVT_TYPE_DIRECT |
+	case (BT_HCI_LE_ADV_EVT_TYPE_CONN | BT_HCI_LE_ADV_EVT_TYPE_DIRECT |
 	      BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
 		return BT_GAP_ADV_TYPE_ADV_DIRECT_IND;
 
-	case (BT_HCI_LE_ADV_EVT_TYPE_SCAN |
-	      BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
+	case (BT_HCI_LE_ADV_EVT_TYPE_SCAN | BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
 		return BT_GAP_ADV_TYPE_ADV_SCAN_IND;
 
 	case BT_HCI_LE_ADV_EVT_TYPE_LEGACY:
 		return BT_GAP_ADV_TYPE_ADV_NONCONN_IND;
 
-	case (BT_HCI_LE_ADV_EVT_TYPE_SCAN_RSP |
-	      BT_HCI_LE_ADV_EVT_TYPE_CONN |
-	      BT_HCI_LE_ADV_EVT_TYPE_SCAN |
-	      BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
-	case (BT_HCI_LE_ADV_EVT_TYPE_SCAN_RSP |
-	      BT_HCI_LE_ADV_EVT_TYPE_SCAN |
+	case (BT_HCI_LE_ADV_EVT_TYPE_SCAN_RSP | BT_HCI_LE_ADV_EVT_TYPE_CONN |
+	      BT_HCI_LE_ADV_EVT_TYPE_SCAN | BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
+	case (BT_HCI_LE_ADV_EVT_TYPE_SCAN_RSP | BT_HCI_LE_ADV_EVT_TYPE_SCAN |
 	      BT_HCI_LE_ADV_EVT_TYPE_LEGACY):
 		/* Scan response from connectable or non-connectable advertiser.
 		 */
@@ -927,8 +914,7 @@ static struct bt_le_per_adv_sync *per_adv_sync_new(void)
 	struct bt_le_per_adv_sync *per_adv_sync = NULL;
 
 	for (int i = 0; i < ARRAY_SIZE(per_adv_sync_pool); i++) {
-		if (!atomic_test_bit(per_adv_sync_pool[i].flags,
-				     BT_PER_ADV_SYNC_CREATED)) {
+		if (!atomic_test_bit(per_adv_sync_pool[i].flags, BT_PER_ADV_SYNC_CREATED)) {
 			per_adv_sync = &per_adv_sync_pool[i];
 			break;
 		}
@@ -942,8 +928,7 @@ static struct bt_le_per_adv_sync *per_adv_sync_new(void)
 	atomic_set_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_CREATED);
 
 #if CONFIG_BT_PER_ADV_SYNC_BUF_SIZE > 0
-	net_buf_simple_init_with_data(&per_adv_sync->reassembly,
-				      per_adv_sync->reassembly_data,
+	net_buf_simple_init_with_data(&per_adv_sync->reassembly, per_adv_sync->reassembly_data,
 				      CONFIG_BT_PER_ADV_SYNC_BUF_SIZE);
 	net_buf_simple_reset(&per_adv_sync->reassembly);
 #endif /* CONFIG_BT_PER_ADV_SYNC_BUF_SIZE > 0 */
@@ -954,8 +939,7 @@ static struct bt_le_per_adv_sync *per_adv_sync_new(void)
 static struct bt_le_per_adv_sync *get_pending_per_adv_sync(void)
 {
 	for (int i = 0; i < ARRAY_SIZE(per_adv_sync_pool); i++) {
-		if (atomic_test_bit(per_adv_sync_pool[i].flags,
-				    BT_PER_ADV_SYNC_SYNCING)) {
+		if (atomic_test_bit(per_adv_sync_pool[i].flags, BT_PER_ADV_SYNC_SYNCING)) {
 			return &per_adv_sync_pool[i];
 		}
 	}
@@ -974,8 +958,7 @@ struct bt_le_per_adv_sync *bt_hci_per_adv_sync_lookup_handle(uint16_t handle)
 {
 	for (int i = 0; i < ARRAY_SIZE(per_adv_sync_pool); i++) {
 		if (per_adv_sync_pool[i].handle == handle &&
-		    atomic_test_bit(per_adv_sync_pool[i].flags,
-				    BT_PER_ADV_SYNC_SYNCED)) {
+		    atomic_test_bit(per_adv_sync_pool[i].flags, BT_PER_ADV_SYNC_SYNCED)) {
 			return &per_adv_sync_pool[i];
 		}
 	}
@@ -1001,7 +984,7 @@ void bt_hci_le_per_adv_report_recv(struct bt_le_per_adv_sync *per_adv_sync,
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_RSP) && (CONFIG_BT_PER_ADV_SYNC_BUF_SIZE > 0)
 static void bt_hci_le_per_adv_report_recv_failure(struct bt_le_per_adv_sync *per_adv_sync,
-				   const struct bt_le_per_adv_sync_recv_info *info)
+						  const struct bt_le_per_adv_sync_recv_info *info)
 {
 	struct bt_le_per_adv_sync_cb *listener;
 
@@ -1039,8 +1022,7 @@ static void bt_hci_le_per_adv_report_common(struct net_buf *buf)
 		return;
 	}
 
-	if (atomic_test_bit(per_adv_sync->flags,
-			    BT_PER_ADV_SYNC_RECV_DISABLED)) {
+	if (atomic_test_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED)) {
 		LOG_ERR("Received PA adv report when receive disabled");
 		return;
 	}
@@ -1076,8 +1058,8 @@ static void bt_hci_le_per_adv_report_common(struct net_buf *buf)
 				 */
 				bt_hci_le_per_adv_report_recv(per_adv_sync, &buf->b, &info);
 			} else {
-				net_buf_simple_add_mem(&per_adv_sync->reassembly,
-						       buf->data, evt->length);
+				net_buf_simple_add_mem(&per_adv_sync->reassembly, buf->data,
+						       evt->length);
 				bt_hci_le_per_adv_report_recv(per_adv_sync,
 							      &per_adv_sync->reassembly, &info);
 				net_buf_simple_reset(&per_adv_sync->reassembly);
@@ -1098,7 +1080,7 @@ static void bt_hci_le_per_adv_report_common(struct net_buf *buf)
 		} else {
 			__ASSERT(false, "Invalid data status 0x%02X", evt->data_status);
 		}
-#else /* CONFIG_BT_PER_ADV_SYNC_BUF_SIZE > 0 */
+#else  /* CONFIG_BT_PER_ADV_SYNC_BUF_SIZE > 0 */
 		if (evt->data_status == BT_HCI_LE_ADV_EVT_TYPE_DATA_STATUS_COMPLETE) {
 			bt_hci_le_per_adv_report_recv(per_adv_sync, &buf->b, &info);
 		} else {
@@ -1126,8 +1108,7 @@ static int per_adv_sync_terminate(uint16_t handle)
 	struct bt_hci_cp_le_per_adv_terminate_sync *cp;
 	struct net_buf *buf;
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_PER_ADV_TERMINATE_SYNC,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_PER_ADV_TERMINATE_SYNC, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -1137,12 +1118,10 @@ static int per_adv_sync_terminate(uint16_t handle)
 
 	cp->handle = sys_cpu_to_le16(handle);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_TERMINATE_SYNC, buf,
-				    NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_TERMINATE_SYNC, buf, NULL);
 }
 
-static void per_adv_sync_terminated(struct bt_le_per_adv_sync *per_adv_sync,
-				    uint8_t reason)
+static void per_adv_sync_terminated(struct bt_le_per_adv_sync *per_adv_sync, uint8_t reason)
 {
 	/* Terminate the PA sync and notify app */
 	const struct bt_le_per_adv_sync_term_info term_info = {
@@ -1206,14 +1185,11 @@ static void bt_hci_le_per_adv_sync_established_common(struct net_buf *buf)
 	if (bt_addr_le_is_resolved(&evt->adv_addr)) {
 		bt_addr_le_copy_resolved(&id_addr, &evt->adv_addr);
 	} else {
-		bt_addr_le_copy(&id_addr,
-				bt_lookup_id_addr(BT_ID_DEFAULT,
-						  &evt->adv_addr));
+		bt_addr_le_copy(&id_addr, bt_lookup_id_addr(BT_ID_DEFAULT, &evt->adv_addr));
 	}
 
 	if (!pending_per_adv_sync ||
-	    (!atomic_test_bit(pending_per_adv_sync->flags,
-			      BT_PER_ADV_SYNC_SYNCING_USE_LIST) &&
+	    (!atomic_test_bit(pending_per_adv_sync->flags, BT_PER_ADV_SYNC_SYNCING_USE_LIST) &&
 	     ((pending_per_adv_sync->sid != evt->sid) ||
 	      !bt_addr_le_eq(&pending_per_adv_sync->addr, &id_addr)))) {
 		LOG_ERR("Unexpected per adv sync established event");
@@ -1227,16 +1203,15 @@ static void bt_hci_le_per_adv_sync_established_common(struct net_buf *buf)
 
 	if (unexpected_evt || evt->status != BT_HCI_ERR_SUCCESS) {
 		if (pending_per_adv_sync) {
-			const uint8_t reason = unexpected_evt ? BT_HCI_ERR_UNSPECIFIED
-							      : evt->status;
+			const uint8_t reason =
+				unexpected_evt ? BT_HCI_ERR_UNSPECIFIED : evt->status;
 
 			if (atomic_test_bit(pending_per_adv_sync->flags,
 					    BT_PER_ADV_SYNC_SYNCING_USE_LIST)) {
 				/* Update the addr and sid for the callback
 				 * Already set if not using the sync list
 				 */
-				bt_addr_le_copy(&pending_per_adv_sync->addr,
-						&id_addr);
+				bt_addr_le_copy(&pending_per_adv_sync->addr, &id_addr);
 				pending_per_adv_sync->sid = evt->sid;
 			}
 
@@ -1251,22 +1226,19 @@ static void bt_hci_le_per_adv_sync_established_common(struct net_buf *buf)
 
 	pending_per_adv_sync->handle = sys_le16_to_cpu(evt->handle);
 	pending_per_adv_sync->interval = sys_le16_to_cpu(evt->interval);
-	pending_per_adv_sync->clock_accuracy =
-		sys_le16_to_cpu(evt->clock_accuracy);
+	pending_per_adv_sync->clock_accuracy = sys_le16_to_cpu(evt->clock_accuracy);
 	pending_per_adv_sync->phy = bt_get_phy(evt->phy);
 
 	memset(&sync_info, 0, sizeof(sync_info));
 	sync_info.interval = pending_per_adv_sync->interval;
 	sync_info.phy = pending_per_adv_sync->phy;
 
-	if (atomic_test_bit(pending_per_adv_sync->flags,
-			    BT_PER_ADV_SYNC_SYNCING_USE_LIST)) {
+	if (atomic_test_bit(pending_per_adv_sync->flags, BT_PER_ADV_SYNC_SYNCING_USE_LIST)) {
 		/* Now we know which address and SID we synchronized to. */
 		pending_per_adv_sync->sid = evt->sid;
 
 		if (bt_addr_le_is_resolved(&pending_per_adv_sync->addr)) {
-			bt_addr_le_copy_resolved(&pending_per_adv_sync->addr,
-						 &id_addr);
+			bt_addr_le_copy_resolved(&pending_per_adv_sync->addr, &id_addr);
 		} else {
 			bt_addr_le_copy(&pending_per_adv_sync->addr, &id_addr);
 		}
@@ -1287,8 +1259,7 @@ static void bt_hci_le_per_adv_sync_established_common(struct net_buf *buf)
 #endif /* CONFIG_BT_PER_ADV_SYNC_RSP */
 
 	sync_info.recv_enabled =
-		!atomic_test_bit(pending_per_adv_sync->flags,
-				 BT_PER_ADV_SYNC_RECV_DISABLED);
+		!atomic_test_bit(pending_per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED);
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&pa_sync_cbs, listener, node) {
 		if (listener->synced) {
@@ -1359,8 +1330,7 @@ int bt_le_per_adv_set_response_data(struct bt_le_per_adv_sync *per_adv_sync,
 		return -EINVAL;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PER_ADV_RESPONSE_DATA,
-				sizeof(*cp) + data->len);
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PER_ADV_RESPONSE_DATA, sizeof(*cp) + data->len);
 
 	if (!buf) {
 		return -ENOBUFS;
@@ -1421,8 +1391,7 @@ static void bt_hci_le_past_received_common(struct net_buf *buf)
 	struct bt_hci_evt_le_past_received_v2 *evt =
 		(struct bt_hci_evt_le_past_received_v2 *)buf->data;
 #else
-	struct bt_hci_evt_le_past_received *evt =
-		(struct bt_hci_evt_le_past_received *)buf->data;
+	struct bt_hci_evt_le_past_received *evt = (struct bt_hci_evt_le_past_received *)buf->data;
 #endif /* defined(CONFIG_BT_PER_ADV_SYNC_RSP) */
 
 	struct bt_le_per_adv_sync_synced_info sync_info;
@@ -1432,14 +1401,12 @@ static void bt_hci_le_past_received_common(struct net_buf *buf)
 
 	if (evt->status) {
 		/* No sync created, don't notify app */
-		LOG_DBG("PAST receive failed with status 0x%02X %s",
-			evt->status, bt_hci_err_to_str(evt->status));
+		LOG_DBG("PAST receive failed with status 0x%02X %s", evt->status,
+			bt_hci_err_to_str(evt->status));
 		return;
 	}
 
-	sync_info.conn = bt_conn_lookup_handle(
-				sys_le16_to_cpu(evt->conn_handle),
-				BT_CONN_TYPE_LE);
+	sync_info.conn = bt_conn_lookup_handle(sys_le16_to_cpu(evt->conn_handle), BT_CONN_TYPE_LE);
 
 	if (!sync_info.conn) {
 		LOG_ERR("Could not lookup connection handle from PAST");
@@ -1460,8 +1427,7 @@ static void bt_hci_le_past_received_common(struct net_buf *buf)
 	if (bt_addr_le_is_resolved(&evt->addr)) {
 		bt_addr_le_copy_resolved(&id_addr, &evt->addr);
 	} else {
-		bt_addr_le_copy(&id_addr,
-				bt_lookup_id_addr(BT_ID_DEFAULT, &evt->addr));
+		bt_addr_le_copy(&id_addr, bt_lookup_id_addr(BT_ID_DEFAULT, &evt->addr));
 	}
 
 	per_adv_sync->handle = sys_le16_to_cpu(evt->sync_handle);
@@ -1497,10 +1463,10 @@ static void bt_hci_le_past_received_common(struct net_buf *buf)
 	}
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_RSP)
-	sync_info.num_subevents =  per_adv_sync->num_subevents;
-	sync_info.subevent_interval =  per_adv_sync->subevent_interval;
-	sync_info.response_slot_delay =  per_adv_sync->response_slot_delay;
-	sync_info.response_slot_spacing =  per_adv_sync->response_slot_spacing;
+	sync_info.num_subevents = per_adv_sync->num_subevents;
+	sync_info.subevent_interval = per_adv_sync->subevent_interval;
+	sync_info.response_slot_delay = per_adv_sync->response_slot_delay;
+	sync_info.response_slot_spacing = per_adv_sync->response_slot_spacing;
 #endif /* defined(CONFIG_BT_PER_ADV_SYNC_RSP) */
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&pa_sync_cbs, listener, node) {
@@ -1638,7 +1604,7 @@ void bt_hci_le_adv_report(struct net_buf *buf)
 	uint8_t num_reports = net_buf_pull_u8(buf);
 	struct bt_hci_evt_le_advertising_info *evt;
 
-	LOG_DBG("Adv number of reports %u",  num_reports);
+	LOG_DBG("Adv number of reports %u", num_reports);
 
 	while (num_reports--) {
 		struct bt_le_scan_recv_info adv_info;
@@ -1684,8 +1650,7 @@ void bt_hci_le_adv_report(struct net_buf *buf)
 
 static bool valid_le_scan_param(const struct bt_le_scan_param *param)
 {
-	if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    param->type == BT_LE_SCAN_TYPE_ACTIVE &&
+	if (IS_ENABLED(CONFIG_BT_PRIVACY) && param->type == BT_LE_SCAN_TYPE_ACTIVE &&
 	    param->timeout != 0) {
 		/* This is marked as not supported as a stopgap until the (scan,
 		 * adv, init) roles are reworked into proper state machines.
@@ -1702,15 +1667,12 @@ static bool valid_le_scan_param(const struct bt_le_scan_param *param)
 		return false;
 	}
 
-	if (param->type != BT_LE_SCAN_TYPE_PASSIVE &&
-	    param->type != BT_LE_SCAN_TYPE_ACTIVE) {
+	if (param->type != BT_LE_SCAN_TYPE_PASSIVE && param->type != BT_LE_SCAN_TYPE_ACTIVE) {
 		return false;
 	}
 
-	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE |
-			       BT_LE_SCAN_OPT_FILTER_ACCEPT_LIST |
-			       BT_LE_SCAN_OPT_CODED |
-			       BT_LE_SCAN_OPT_NO_1M)) {
+	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE | BT_LE_SCAN_OPT_FILTER_ACCEPT_LIST |
+			       BT_LE_SCAN_OPT_CODED | BT_LE_SCAN_OPT_NO_1M)) {
 		return false;
 	}
 
@@ -1763,8 +1725,7 @@ int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
 	}
 
 	/* store the parameters that were used to start the scanner */
-	memcpy(&scan_state.explicit_scan_param, param,
-	       sizeof(scan_state.explicit_scan_param));
+	memcpy(&scan_state.explicit_scan_param, param, sizeof(scan_state.explicit_scan_param));
 
 	scan_dev_found_cb = cb;
 	err = bt_le_scan_user_add(BT_LE_SCAN_USER_EXPLICIT_SCAN);
@@ -1840,14 +1801,12 @@ int bt_le_per_adv_sync_get_info(struct bt_le_per_adv_sync *per_adv_sync,
 	return 0;
 }
 
-struct bt_le_per_adv_sync *bt_le_per_adv_sync_lookup_addr(const bt_addr_le_t *adv_addr,
-							  uint8_t sid)
+struct bt_le_per_adv_sync *bt_le_per_adv_sync_lookup_addr(const bt_addr_le_t *adv_addr, uint8_t sid)
 {
 	for (int i = 0; i < ARRAY_SIZE(per_adv_sync_pool); i++) {
 		struct bt_le_per_adv_sync *sync = &per_adv_sync_pool[i];
 
-		if (!atomic_test_bit(per_adv_sync_pool[i].flags,
-				     BT_PER_ADV_SYNC_CREATED)) {
+		if (!atomic_test_bit(per_adv_sync_pool[i].flags, BT_PER_ADV_SYNC_CREATED)) {
 			continue;
 		}
 
@@ -1875,10 +1834,9 @@ int bt_le_per_adv_sync_create(const struct bt_le_per_adv_sync_param *param,
 		return -EBUSY;
 	}
 
-	if (param->sid > BT_GAP_SID_MAX ||
-		   param->skip > BT_GAP_PER_ADV_MAX_SKIP ||
-		   param->timeout > BT_GAP_PER_ADV_MAX_TIMEOUT ||
-		   param->timeout < BT_GAP_PER_ADV_MIN_TIMEOUT) {
+	if (param->sid > BT_GAP_SID_MAX || param->skip > BT_GAP_PER_ADV_MAX_SKIP ||
+	    param->timeout > BT_GAP_PER_ADV_MAX_TIMEOUT ||
+	    param->timeout < BT_GAP_PER_ADV_MIN_TIMEOUT) {
 		return -EINVAL;
 	}
 
@@ -1897,8 +1855,7 @@ int bt_le_per_adv_sync_create(const struct bt_le_per_adv_sync_param *param,
 	(void)memset(cp, 0, sizeof(*cp));
 
 	if (param->options & BT_LE_PER_ADV_SYNC_OPT_USE_PER_ADV_LIST) {
-		atomic_set_bit(per_adv_sync->flags,
-			       BT_PER_ADV_SYNC_SYNCING_USE_LIST);
+		atomic_set_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_SYNCING_USE_LIST);
 
 		cp->options |= BT_HCI_LE_PER_ADV_CREATE_SYNC_FP_USE_LIST;
 	} else {
@@ -1911,18 +1868,14 @@ int bt_le_per_adv_sync_create(const struct bt_le_per_adv_sync_param *param,
 		cp->sid = param->sid;
 	}
 
-	if (param->options &
-	    BT_LE_PER_ADV_SYNC_OPT_REPORTING_INITIALLY_DISABLED) {
-		cp->options |=
-			BT_HCI_LE_PER_ADV_CREATE_SYNC_FP_REPORTS_DISABLED;
+	if (param->options & BT_LE_PER_ADV_SYNC_OPT_REPORTING_INITIALLY_DISABLED) {
+		cp->options |= BT_HCI_LE_PER_ADV_CREATE_SYNC_FP_REPORTS_DISABLED;
 
-		atomic_set_bit(per_adv_sync->flags,
-			       BT_PER_ADV_SYNC_RECV_DISABLED);
+		atomic_set_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED);
 	}
 
 	if (param->options & BT_LE_PER_ADV_SYNC_OPT_FILTER_DUPLICATE) {
-		cp->options |=
-			BT_HCI_LE_PER_ADV_CREATE_SYNC_FP_FILTER_DUPLICATE;
+		cp->options |= BT_HCI_LE_PER_ADV_CREATE_SYNC_FP_FILTER_DUPLICATE;
 	}
 
 	if (param->options & BT_LE_PER_ADV_SYNC_OPT_DONT_SYNC_AOA) {
@@ -1930,13 +1883,11 @@ int bt_le_per_adv_sync_create(const struct bt_le_per_adv_sync_param *param,
 	}
 
 	if (param->options & BT_LE_PER_ADV_SYNC_OPT_DONT_SYNC_AOD_1US) {
-		cp->cte_type |=
-			BT_HCI_LE_PER_ADV_CREATE_SYNC_CTE_TYPE_NO_AOD_1US;
+		cp->cte_type |= BT_HCI_LE_PER_ADV_CREATE_SYNC_CTE_TYPE_NO_AOD_1US;
 	}
 
 	if (param->options & BT_LE_PER_ADV_SYNC_OPT_DONT_SYNC_AOD_2US) {
-		cp->cte_type |=
-			BT_HCI_LE_PER_ADV_CREATE_SYNC_CTE_TYPE_NO_AOD_2US;
+		cp->cte_type |= BT_HCI_LE_PER_ADV_CREATE_SYNC_CTE_TYPE_NO_AOD_2US;
 	}
 
 	if (param->options & BT_LE_PER_ADV_SYNC_OPT_SYNC_ONLY_CONST_TONE_EXT) {
@@ -1978,8 +1929,7 @@ int bt_le_per_adv_sync_create(const struct bt_le_per_adv_sync_param *param,
 	return 0;
 }
 
-static int bt_le_per_adv_sync_create_cancel(
-	struct bt_le_per_adv_sync *per_adv_sync)
+static int bt_le_per_adv_sync_create_cancel(struct bt_le_per_adv_sync *per_adv_sync)
 {
 	struct net_buf *buf;
 	int err;
@@ -1999,8 +1949,7 @@ static int bt_le_per_adv_sync_create_cancel(
 		return -ENOBUFS;
 	}
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_CREATE_SYNC_CANCEL, buf,
-				   NULL);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_CREATE_SYNC_CANCEL, buf, NULL);
 	if (err) {
 		return err;
 	}
@@ -2037,8 +1986,7 @@ int bt_le_per_adv_sync_delete(struct bt_le_per_adv_sync *per_adv_sync)
 		err = bt_le_per_adv_sync_terminate(per_adv_sync);
 
 		if (!err) {
-			per_adv_sync_terminated(per_adv_sync,
-						BT_HCI_ERR_LOCALHOST_TERM_CONN);
+			per_adv_sync_terminated(per_adv_sync, BT_HCI_ERR_LOCALHOST_TERM_CONN);
 		}
 	} else if (get_pending_per_adv_sync() == per_adv_sync) {
 		err = bt_le_per_adv_sync_create_cancel(per_adv_sync);
@@ -2061,8 +2009,7 @@ int bt_le_per_adv_sync_cb_register(struct bt_le_per_adv_sync_cb *cb)
 	return 0;
 }
 
-static int bt_le_set_per_adv_recv_enable(
-	struct bt_le_per_adv_sync *per_adv_sync, bool enable)
+static int bt_le_set_per_adv_recv_enable(struct bt_le_per_adv_sync *per_adv_sync, bool enable)
 {
 	struct bt_hci_cp_le_set_per_adv_recv_enable *cp;
 	struct bt_le_per_adv_sync_cb *listener;
@@ -2083,15 +2030,12 @@ static int bt_le_set_per_adv_recv_enable(
 		return -EINVAL;
 	}
 
-	if ((enable && !atomic_test_bit(per_adv_sync->flags,
-					BT_PER_ADV_SYNC_RECV_DISABLED)) ||
-	    (!enable && atomic_test_bit(per_adv_sync->flags,
-					BT_PER_ADV_SYNC_RECV_DISABLED))) {
+	if ((enable && !atomic_test_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED)) ||
+	    (!enable && atomic_test_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED))) {
 		return -EALREADY;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PER_ADV_RECV_ENABLE,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PER_ADV_RECV_ENABLE, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -2102,18 +2046,16 @@ static int bt_le_set_per_adv_recv_enable(
 	cp->handle = sys_cpu_to_le16(per_adv_sync->handle);
 	cp->enable = enable ? 1 : 0;
 
-	bt_hci_cmd_state_set_init(buf, &state, per_adv_sync->flags,
-				  BT_PER_ADV_SYNC_RECV_DISABLED, !enable);
+	bt_hci_cmd_state_set_init(buf, &state, per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED,
+				  !enable);
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PER_ADV_RECV_ENABLE,
-				   buf, NULL);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PER_ADV_RECV_ENABLE, buf, NULL);
 
 	if (err) {
 		return err;
 	}
 
-	info.recv_enabled = !atomic_test_bit(per_adv_sync->flags,
-					     BT_PER_ADV_SYNC_RECV_DISABLED);
+	info.recv_enabled = !atomic_test_bit(per_adv_sync->flags, BT_PER_ADV_SYNC_RECV_DISABLED);
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&pa_sync_cbs, listener, node) {
 		if (listener->state_changed) {
@@ -2136,21 +2078,18 @@ int bt_le_per_adv_sync_recv_disable(struct bt_le_per_adv_sync *per_adv_sync)
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER)
 int bt_le_per_adv_sync_transfer(const struct bt_le_per_adv_sync *per_adv_sync,
-				const struct bt_conn *conn,
-				uint16_t service_data)
+				const struct bt_conn *conn, uint16_t service_data)
 {
 	struct bt_hci_cp_le_per_adv_sync_transfer *cp;
 	struct net_buf *buf;
 
-
 	if (!BT_FEAT_LE_EXT_PER_ADV(bt_dev.le.features)) {
 		return -ENOTSUP;
 	} else if (!BT_FEAT_LE_PAST_SEND(bt_dev.le.features)) {
 		return -ENOTSUP;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_PER_ADV_SYNC_TRANSFER,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_PER_ADV_SYNC_TRANSFER, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -2162,18 +2101,14 @@ int bt_le_per_adv_sync_transfer(const struct bt_le_per_adv_sync *per_adv_sync,
 	cp->sync_handle = sys_cpu_to_le16(per_adv_sync->handle);
 	cp->service_data = sys_cpu_to_le16(service_data);
 
-	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_SYNC_TRANSFER, buf,
-				    NULL);
+	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PER_ADV_SYNC_TRANSFER, buf, NULL);
 }
 #endif /* CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER */
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER)
-static bool valid_past_param(
-	const struct bt_le_per_adv_sync_transfer_param *param)
+static bool valid_past_param(const struct bt_le_per_adv_sync_transfer_param *param)
 {
-	if (param->skip > 0x01f3 ||
-	    param->timeout < 0x000A ||
-	    param->timeout > 0x4000) {
+	if (param->skip > 0x01f3 || param->timeout < 0x000A || param->timeout > 0x4000) {
 		return false;
 	}
 	if ((param->options & BT_LE_PER_ADV_SYNC_TRANSFER_OPT_REPORTING_INITIALLY_DISABLED) &&
@@ -2184,8 +2119,8 @@ static bool valid_past_param(
 	return true;
 }
 
-static int past_param_set(const struct bt_conn *conn, uint8_t mode,
-			  uint16_t skip, uint16_t timeout, uint8_t cte_type)
+static int past_param_set(const struct bt_conn *conn, uint8_t mode, uint16_t skip, uint16_t timeout,
+			  uint8_t cte_type)
 {
 	struct bt_hci_cp_le_past_param *cp;
 	struct net_buf *buf;
@@ -2207,8 +2142,7 @@ static int past_param_set(const struct bt_conn *conn, uint8_t mode,
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_PAST_PARAM, buf, NULL);
 }
 
-static int default_past_param_set(uint8_t mode, uint16_t skip, uint16_t timeout,
-				  uint8_t cte_type)
+static int default_past_param_set(uint8_t mode, uint16_t skip, uint16_t timeout, uint8_t cte_type)
 {
 	struct bt_hci_cp_le_default_past_param *cp;
 	struct net_buf *buf;
@@ -2229,9 +2163,8 @@ static int default_past_param_set(uint8_t mode, uint16_t skip, uint16_t timeout,
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_DEFAULT_PAST_PARAM, buf, NULL);
 }
 
-int bt_le_per_adv_sync_transfer_subscribe(
-	const struct bt_conn *conn,
-	const struct bt_le_per_adv_sync_transfer_param *param)
+int bt_le_per_adv_sync_transfer_subscribe(const struct bt_conn *conn,
+					  const struct bt_le_per_adv_sync_transfer_param *param)
 {
 	uint8_t cte_type = 0;
 	uint8_t mode = BT_HCI_LE_PAST_MODE_SYNC;
@@ -2341,8 +2274,7 @@ int bt_le_per_adv_list_add(const bt_addr_le_t *addr, uint8_t sid)
 		return -EAGAIN;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_ADD_DEV_TO_PER_ADV_LIST,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_ADD_DEV_TO_PER_ADV_LIST, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -2351,8 +2283,7 @@ int bt_le_per_adv_list_add(const bt_addr_le_t *addr, uint8_t sid)
 	bt_addr_le_copy(&cp->addr, addr);
 	cp->sid = sid;
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_PER_ADV_LIST, buf,
-				   NULL);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_PER_ADV_LIST, buf, NULL);
 	if (err) {
 		LOG_ERR("Failed to add device to periodic advertiser list");
 
@@ -2372,8 +2303,7 @@ int bt_le_per_adv_list_remove(const bt_addr_le_t *addr, uint8_t sid)
 		return -EAGAIN;
 	}
 
-	buf = bt_hci_cmd_create(BT_HCI_OP_LE_REM_DEV_FROM_PER_ADV_LIST,
-				sizeof(*cp));
+	buf = bt_hci_cmd_create(BT_HCI_OP_LE_REM_DEV_FROM_PER_ADV_LIST, sizeof(*cp));
 	if (!buf) {
 		return -ENOBUFS;
 	}
@@ -2382,8 +2312,7 @@ int bt_le_per_adv_list_remove(const bt_addr_le_t *addr, uint8_t sid)
 	bt_addr_le_copy(&cp->addr, addr);
 	cp->sid = sid;
 
-	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_REM_DEV_FROM_PER_ADV_LIST, buf,
-				   NULL);
+	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_REM_DEV_FROM_PER_ADV_LIST, buf, NULL);
 	if (err) {
 		LOG_ERR("Failed to remove device from periodic advertiser list");
 		return err;
@@ -2418,13 +2347,13 @@ bool bt_le_explicit_scanner_running(void)
 bool bt_le_explicit_scanner_uses_same_params(const struct bt_conn_le_create_param *create_param)
 {
 	if (scan_state.explicit_scan_param.window != create_param->window ||
-	    scan_state.explicit_scan_param.interval != create_param->interval){
+	    scan_state.explicit_scan_param.interval != create_param->interval) {
 		return false;
 	}
 
 	if (scan_state.explicit_scan_param.options & BT_LE_SCAN_OPT_CODED) {
 		if (scan_state.explicit_scan_param.window_coded != create_param->window_coded ||
-		    scan_state.explicit_scan_param.interval_coded != create_param->interval_coded){
+		    scan_state.explicit_scan_param.interval_coded != create_param->interval_coded) {
 			return false;
 		}
 	}
diff --git a/subsys/bluetooth/host/settings.c b/subsys/bluetooth/host/settings.c
index 4cc2b56f6a0..0371b8c7595 100644
--- a/subsys/bluetooth/host/settings.c
+++ b/subsys/bluetooth/host/settings.c
@@ -27,17 +27,13 @@ void bt_settings_encode_key(char *path, size_t path_size, const char *subsys,
 			    const bt_addr_le_t *addr, const char *key)
 {
 	if (key) {
-		snprintk(path, path_size,
-			 "bt/%s/%02x%02x%02x%02x%02x%02x%u/%s", subsys,
-			 addr->a.val[5], addr->a.val[4], addr->a.val[3],
-			 addr->a.val[2], addr->a.val[1], addr->a.val[0],
-			 addr->type, key);
+		snprintk(path, path_size, "bt/%s/%02x%02x%02x%02x%02x%02x%u/%s", subsys,
+			 addr->a.val[5], addr->a.val[4], addr->a.val[3], addr->a.val[2],
+			 addr->a.val[1], addr->a.val[0], addr->type, key);
 	} else {
-		snprintk(path, path_size,
-			 "bt/%s/%02x%02x%02x%02x%02x%02x%u", subsys,
-			 addr->a.val[5], addr->a.val[4], addr->a.val[3],
-			 addr->a.val[2], addr->a.val[1], addr->a.val[0],
-			 addr->type);
+		snprintk(path, path_size, "bt/%s/%02x%02x%02x%02x%02x%02x%u", subsys,
+			 addr->a.val[5], addr->a.val[4], addr->a.val[3], addr->a.val[2],
+			 addr->a.val[1], addr->a.val[0], addr->type);
 	}
 
 	LOG_DBG("Encoded path %s", path);
@@ -62,8 +58,7 @@ void bt_settings_encode_key(char *path, size_t path_size, const char *subsys,
 		}
 
 		for (int8_t i = 5; i >= 0 && len < path_size; i--) {
-			len += bin2hex(&addr->a.val[i], 1, &path[len],
-				       path_size - len);
+			len += bin2hex(&addr->a.val[i], 1, &path[len], path_size - len);
 		}
 
 		if (len < path_size) {
@@ -116,8 +111,7 @@ int bt_settings_decode_key(const char *key, bt_addr_le_t *addr)
 	return 0;
 }
 
-static int set_setting(const char *name, size_t len_rd, settings_read_cb read_cb,
-	       void *cb_arg)
+static int set_setting(const char *name, size_t len_rd, settings_read_cb read_cb, void *cb_arg)
 {
 	ssize_t len;
 	const char *next;
@@ -150,13 +144,13 @@ static int set_setting(const char *name, size_t len_rd, settings_read_cb read_cb
 		if (len < sizeof(bt_dev.id_addr[0])) {
 			if (len < 0) {
 				LOG_ERR("Failed to read ID address from storage"
-				       " (err %zd)", len);
+					" (err %zd)",
+					len);
 			} else {
 				LOG_ERR("Invalid length ID address in storage");
 				LOG_HEXDUMP_DBG(&bt_dev.id_addr, len, "data read");
 			}
-			(void)memset(bt_dev.id_addr, 0,
-				     sizeof(bt_dev.id_addr));
+			(void)memset(bt_dev.id_addr, 0, sizeof(bt_dev.id_addr));
 			bt_dev.id_count = 0U;
 		} else {
 			int i;
@@ -175,7 +169,8 @@ static int set_setting(const char *name, size_t len_rd, settings_read_cb read_cb
 		len = read_cb(cb_arg, &bt_dev.name, sizeof(bt_dev.name) - 1);
 		if (len < 0) {
 			LOG_ERR("Failed to read device name from storage"
-			       " (err %zd)", len);
+				" (err %zd)",
+				len);
 		} else {
 			bt_dev.name[len] = '\0';
 
@@ -207,7 +202,8 @@ static int set_setting(const char *name, size_t len_rd, settings_read_cb read_cb
 		if (len < sizeof(bt_dev.irk[0])) {
 			if (len < 0) {
 				LOG_ERR("Failed to read IRK from storage"
-				       " (err %zd)", len);
+					" (err %zd)",
+					len);
 			} else {
 				LOG_ERR("Invalid length IRK in storage");
 				(void)memset(bt_dev.irk, 0, sizeof(bt_dev.irk));
diff --git a/subsys/bluetooth/host/shell/bt.c b/subsys/bluetooth/host/shell/bt.c
index 50847d3c7b9..21955abc631 100644
--- a/subsys/bluetooth/host/shell/bt.c
+++ b/subsys/bluetooth/host/shell/bt.c
@@ -102,7 +102,8 @@ static ATOMIC_DEFINE(adv_set_opt, SHELL_ADV_OPT_NUM)[CONFIG_BT_EXT_ADV_MAX_ADV_S
 static const char *phy2str(uint8_t phy)
 {
 	switch (phy) {
-	case 0: return "No packets";
+	case 0:
+		return "No packets";
 	case BT_GAP_LE_PHY_1M:
 		return "LE 1M";
 	case BT_GAP_LE_PHY_2M:
@@ -120,9 +121,9 @@ static void print_le_addr(const char *desc, const bt_addr_le_t *addr)
 {
 	char addr_str[BT_ADDR_LE_STR_LEN];
 
-	const char *addr_desc = bt_addr_le_is_identity(addr) ? "identity" :
-				bt_addr_le_is_rpa(addr) ? "resolvable" :
-				"non-resolvable";
+	const char *addr_desc = bt_addr_le_is_identity(addr) ? "identity"
+				: bt_addr_le_is_rpa(addr)    ? "resolvable"
+							     : "non-resolvable";
 
 	bt_addr_le_to_str(addr, addr_str, sizeof(addr_str));
 
@@ -333,8 +334,7 @@ static void print_data_hex(const uint8_t *data, uint8_t len, enum shell_vt100_co
 	}
 }
 
-static void print_data_set(uint8_t set_value_len,
-			   const uint8_t *scan_data, uint8_t scan_data_len)
+static void print_data_set(uint8_t set_value_len, const uint8_t *scan_data, uint8_t scan_data_len)
 {
 	uint8_t idx = 0;
 
@@ -557,20 +557,17 @@ static void scan_recv(const struct bt_le_scan_recv_info *info, struct net_buf_si
 	bt_shell_print("%s%s, AD evt type %u, RSSI %i %s "
 		       "C:%u S:%u D:%d SR:%u E:%u Prim: %s, Secn: %s, "
 		       "Interval: 0x%04x (%u us), SID: 0x%x",
-		       scan_response_label,
-		       le_addr, info->adv_type, info->rssi, name,
+		       scan_response_label, le_addr, info->adv_type, info->rssi, name,
 		       (info->adv_props & BT_GAP_ADV_PROP_CONNECTABLE) != 0,
 		       (info->adv_props & BT_GAP_ADV_PROP_SCANNABLE) != 0,
 		       (info->adv_props & BT_GAP_ADV_PROP_DIRECTED) != 0,
 		       (info->adv_props & BT_GAP_ADV_PROP_SCAN_RESPONSE) != 0,
-		       (info->adv_props & BT_GAP_ADV_PROP_EXT_ADV) != 0,
-		       phy2str(info->primary_phy), phy2str(info->secondary_phy),
-		       info->interval, BT_CONN_INTERVAL_TO_US(info->interval),
-		       info->sid);
+		       (info->adv_props & BT_GAP_ADV_PROP_EXT_ADV) != 0, phy2str(info->primary_phy),
+		       phy2str(info->secondary_phy), info->interval,
+		       BT_CONN_INTERVAL_TO_US(info->interval), info->sid);
 
 	if (scan_verbose_output) {
-		bt_shell_info("%*s[SCAN DATA START - %s]",
-			      strlen(scan_response_label), "",
+		bt_shell_info("%*s[SCAN DATA START - %s]", strlen(scan_response_label), "",
 			      scan_response_type_txt(info->adv_type));
 		bt_data_parse(&buf_copy, data_verbose_cb, NULL);
 		bt_shell_info("%*s[SCAN DATA END]", strlen(scan_response_label), "");
@@ -614,15 +611,13 @@ static void scan_timeout(void)
 
 #if defined(CONFIG_BT_EXT_ADV)
 #if defined(CONFIG_BT_BROADCASTER)
-static void adv_sent(struct bt_le_ext_adv *adv,
-		     struct bt_le_ext_adv_sent_info *info)
+static void adv_sent(struct bt_le_ext_adv *adv, struct bt_le_ext_adv_sent_info *info)
 {
 	bt_shell_print("Advertiser[%d] %p sent %d", bt_le_ext_adv_get_index(adv), adv,
 		       info->num_sent);
 }
 
-static void adv_scanned(struct bt_le_ext_adv *adv,
-			struct bt_le_ext_adv_scanned_info *info)
+static void adv_scanned(struct bt_le_ext_adv *adv, struct bt_le_ext_adv_scanned_info *info)
 {
 	char str[BT_ADDR_LE_STR_LEN];
 
@@ -633,8 +628,7 @@ static void adv_scanned(struct bt_le_ext_adv *adv,
 #endif /* CONFIG_BT_BROADCASTER */
 
 #if defined(CONFIG_BT_PERIPHERAL)
-static void adv_connected(struct bt_le_ext_adv *adv,
-			  struct bt_le_ext_adv_connected_info *info)
+static void adv_connected(struct bt_le_ext_adv *adv, struct bt_le_ext_adv_connected_info *info)
 {
 	char str[BT_ADDR_LE_STR_LEN];
 
@@ -823,18 +817,17 @@ static void disconnected(struct bt_conn *conn, uint8_t reason)
 
 static bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param)
 {
-	bt_shell_print("LE conn  param req: int (0x%04x, 0x%04x) lat %d to %d",
-		       param->interval_min, param->interval_max,
-		       param->latency, param->timeout);
+	bt_shell_print("LE conn  param req: int (0x%04x, 0x%04x) lat %d to %d", param->interval_min,
+		       param->interval_max, param->latency, param->timeout);
 
 	return true;
 }
 
-static void le_param_updated(struct bt_conn *conn, uint16_t interval,
-			     uint16_t latency, uint16_t timeout)
+static void le_param_updated(struct bt_conn *conn, uint16_t interval, uint16_t latency,
+			     uint16_t timeout)
 {
-	bt_shell_print("LE conn param updated: int 0x%04x lat %d to %d",
-		       interval, latency, timeout);
+	bt_shell_print("LE conn param updated: int 0x%04x lat %d to %d", interval, latency,
+		       timeout);
 }
 
 #if defined(CONFIG_BT_SMP)
@@ -878,8 +871,7 @@ static const char *security_err_str(enum bt_security_err err)
 	}
 }
 
-static void security_changed(struct bt_conn *conn, bt_security_t level,
-			     enum bt_security_err err)
+static void security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
 {
 	char addr[BT_ADDR_LE_STR_LEN];
 
@@ -896,8 +888,7 @@ static void security_changed(struct bt_conn *conn, bt_security_t level,
 #endif
 
 #if defined(CONFIG_BT_REMOTE_INFO)
-static void remote_info_available(struct bt_conn *conn,
-				  struct bt_conn_remote_info *remote_info)
+static void remote_info_available(struct bt_conn *conn, struct bt_conn_remote_info *remote_info)
 {
 	struct bt_conn_info info;
 
@@ -905,46 +896,40 @@ static void remote_info_available(struct bt_conn *conn,
 
 	if (IS_ENABLED(CONFIG_BT_REMOTE_VERSION)) {
 		bt_shell_print("Remote LMP version %s (0x%02x) subversion 0x%04x "
-			       "manufacturer 0x%04x", bt_hci_get_ver_str(remote_info->version),
-			       remote_info->version, remote_info->subversion,
-			       remote_info->manufacturer);
+			       "manufacturer 0x%04x",
+			       bt_hci_get_ver_str(remote_info->version), remote_info->version,
+			       remote_info->subversion, remote_info->manufacturer);
 	}
 
 	if (info.type == BT_CONN_TYPE_LE) {
 		uint8_t features[8];
 		char features_str[2 * sizeof(features) + 1];
 
-		sys_memcpy_swap(features, remote_info->le.features,
-				sizeof(features));
-		bin2hex(features, sizeof(features),
-			features_str, sizeof(features_str));
+		sys_memcpy_swap(features, remote_info->le.features, sizeof(features));
+		bin2hex(features, sizeof(features), features_str, sizeof(features_str));
 		bt_shell_print("LE Features: 0x%s ", features_str);
 	}
 }
 #endif /* defined(CONFIG_BT_REMOTE_INFO) */
 
 #if defined(CONFIG_BT_USER_DATA_LEN_UPDATE)
-void le_data_len_updated(struct bt_conn *conn,
-			 struct bt_conn_le_data_len_info *info)
+void le_data_len_updated(struct bt_conn *conn, struct bt_conn_le_data_len_info *info)
 {
 	bt_shell_print("LE data len updated: TX (len: %d time: %d) RX (len: %d time: %d)",
-		       info->tx_max_len, info->tx_max_time,
-		       info->rx_max_len, info->rx_max_time);
+		       info->tx_max_len, info->tx_max_time, info->rx_max_len, info->rx_max_time);
 }
 #endif
 
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
-void le_phy_updated(struct bt_conn *conn,
-		    struct bt_conn_le_phy_info *info)
+void le_phy_updated(struct bt_conn *conn, struct bt_conn_le_phy_info *info)
 {
-	bt_shell_print("LE PHY updated: TX PHY %s, RX PHY %s",
-		       phy2str(info->tx_phy), phy2str(info->rx_phy));
+	bt_shell_print("LE PHY updated: TX PHY %s, RX PHY %s", phy2str(info->tx_phy),
+		       phy2str(info->rx_phy));
 }
 #endif
 
 #if defined(CONFIG_BT_TRANSMIT_POWER_CONTROL)
-void tx_power_report(struct bt_conn *conn,
-		     const struct bt_conn_le_tx_power_report *report)
+void tx_power_report(struct bt_conn *conn, const struct bt_conn_le_tx_power_report *report)
 {
 	bt_shell_print("Tx Power Report: Reason: %s, PHY: %s, Tx Power Level: %d",
 		       tx_power_report_reason2str(report->reason), tx_pwr_ctrl_phy2str(report->phy),
@@ -964,8 +949,7 @@ void path_loss_threshold_report(struct bt_conn *conn,
 #endif
 
 #if defined(CONFIG_BT_SUBRATING)
-void subrate_changed(struct bt_conn *conn,
-		     const struct bt_conn_le_subrate_changed *params)
+void subrate_changed(struct bt_conn *conn, const struct bt_conn_le_subrate_changed *params)
 {
 	if (params->status == BT_HCI_ERR_SUCCESS) {
 		bt_shell_print("Subrate parameters changed: "
@@ -973,10 +957,8 @@ void subrate_changed(struct bt_conn *conn,
 			       "Continuation Number: %d "
 			       "Peripheral latency: 0x%04x "
 			       "Supervision timeout: 0x%04x (%d ms)",
-			       params->factor,
-			       params->continuation_number,
-			       params->peripheral_latency,
-			       params->supervision_timeout,
+			       params->factor, params->continuation_number,
+			       params->peripheral_latency, params->supervision_timeout,
 			       params->supervision_timeout * 10);
 	} else {
 		bt_shell_print("Subrate change failed (HCI status 0x%02x)", params->status);
@@ -1076,35 +1058,34 @@ static void le_cs_config_created(struct bt_conn *conn, struct bt_conn_le_cs_conf
 	uint8_t chsel_type_idx = MIN(config->channel_selection_type, 2);
 	uint8_t ch3c_shape_idx = MIN(config->ch3c_shape, 2);
 
-	bt_shell_print(
-		"New CS config created:\n"
-		"- ID: %d\n"
-		"- Role: %s\n"
-		"- Main mode: %s\n"
-		"- Sub mode: %s\n"
-		"- RTT type: %s\n"
-		"- Main mode steps: %d - %d\n"
-		"- Main mode repetition: %d\n"
-		"- Mode 0 steps: %d\n"
-		"- CS sync PHY: %s\n"
-		"- T_IP1 time: %d\n"
-		"- T_IP2 time: %d\n"
-		"- T_FCS time: %d\n"
-		"- T_PM time: %d\n"
-		"- Channel map: 0x%08X%08X%04X\n"
-		"- Channel map repetition: %d\n"
-		"- Channel selection type: %s\n"
-		"- Ch3c shape: %s\n"
-		"- Ch3c jump: %d\n",
-		config->id, role_str[role_idx], mode_str[main_mode_idx], mode_str[sub_mode_idx],
-		rtt_type_str[rtt_type_idx], config->min_main_mode_steps,
-		config->max_main_mode_steps, config->main_mode_repetition, config->mode_0_steps,
-		phy_str[phy_idx], config->t_ip1_time_us, config->t_ip2_time_us,
-		config->t_fcs_time_us, config->t_pm_time_us,
-		sys_get_le32(&config->channel_map[6]), sys_get_le32(&config->channel_map[2]),
-		sys_get_le16(&config->channel_map[0]), config->channel_map_repetition,
-		chsel_type_str[chsel_type_idx], ch3c_shape_str[ch3c_shape_idx],
-		config->ch3c_jump);
+	bt_shell_print("New CS config created:\n"
+		       "- ID: %d\n"
+		       "- Role: %s\n"
+		       "- Main mode: %s\n"
+		       "- Sub mode: %s\n"
+		       "- RTT type: %s\n"
+		       "- Main mode steps: %d - %d\n"
+		       "- Main mode repetition: %d\n"
+		       "- Mode 0 steps: %d\n"
+		       "- CS sync PHY: %s\n"
+		       "- T_IP1 time: %d\n"
+		       "- T_IP2 time: %d\n"
+		       "- T_FCS time: %d\n"
+		       "- T_PM time: %d\n"
+		       "- Channel map: 0x%08X%08X%04X\n"
+		       "- Channel map repetition: %d\n"
+		       "- Channel selection type: %s\n"
+		       "- Ch3c shape: %s\n"
+		       "- Ch3c jump: %d\n",
+		       config->id, role_str[role_idx], mode_str[main_mode_idx],
+		       mode_str[sub_mode_idx], rtt_type_str[rtt_type_idx],
+		       config->min_main_mode_steps, config->max_main_mode_steps,
+		       config->main_mode_repetition, config->mode_0_steps, phy_str[phy_idx],
+		       config->t_ip1_time_us, config->t_ip2_time_us, config->t_fcs_time_us,
+		       config->t_pm_time_us, sys_get_le32(&config->channel_map[6]),
+		       sys_get_le32(&config->channel_map[2]), sys_get_le16(&config->channel_map[0]),
+		       config->channel_map_repetition, chsel_type_str[chsel_type_idx],
+		       ch3c_shape_str[ch3c_shape_idx], config->ch3c_jump);
 }
 
 static void le_cs_config_removed(struct bt_conn *conn, uint8_t config_id)
@@ -1193,10 +1174,9 @@ static void per_adv_sync_sync_cb(struct bt_le_per_adv_sync *sync,
 
 	bt_shell_print("PER_ADV_SYNC[%u]: [DEVICE]: %s synced, "
 		       "Interval 0x%04x (%u us), PHY %s, SD 0x%04X, PAST peer %s",
-		       bt_le_per_adv_sync_get_index(sync), le_addr,
-		       info->interval, BT_CONN_INTERVAL_TO_US(info->interval),
-		       phy2str(info->phy), info->service_data,
-		       is_past_peer ? past_peer : "not present");
+		       bt_le_per_adv_sync_get_index(sync), le_addr, info->interval,
+		       BT_CONN_INTERVAL_TO_US(info->interval), phy2str(info->phy),
+		       info->service_data, is_past_peer ? past_peer : "not present");
 
 	if (info->conn) { /* if from PAST */
 		for (int i = 0; i < ARRAY_SIZE(per_adv_syncs); i++) {
@@ -1208,9 +1188,8 @@ static void per_adv_sync_sync_cb(struct bt_le_per_adv_sync *sync,
 	}
 }
 
-static void per_adv_sync_terminated_cb(
-	struct bt_le_per_adv_sync *sync,
-	const struct bt_le_per_adv_sync_term_info *info)
+static void per_adv_sync_terminated_cb(struct bt_le_per_adv_sync *sync,
+				       const struct bt_le_per_adv_sync_term_info *info)
 {
 	char le_addr[BT_ADDR_LE_STR_LEN];
 
@@ -1226,18 +1205,17 @@ static void per_adv_sync_terminated_cb(
 		       bt_le_per_adv_sync_get_index(sync), le_addr);
 }
 
-static void per_adv_sync_recv_cb(
-	struct bt_le_per_adv_sync *sync,
-	const struct bt_le_per_adv_sync_recv_info *info,
-	struct net_buf_simple *buf)
+static void per_adv_sync_recv_cb(struct bt_le_per_adv_sync *sync,
+				 const struct bt_le_per_adv_sync_recv_info *info,
+				 struct net_buf_simple *buf)
 {
 	char le_addr[BT_ADDR_LE_STR_LEN];
 
 	bt_addr_le_to_str(info->addr, le_addr, sizeof(le_addr));
 	bt_shell_print("PER_ADV_SYNC[%u]: [DEVICE]: %s, tx_power %i, "
 		       "RSSI %i, CTE %u, data length %u",
-		       bt_le_per_adv_sync_get_index(sync), le_addr, info->tx_power,
-		       info->rssi, info->cte_type, buf->len);
+		       bt_le_per_adv_sync_get_index(sync), le_addr, info->tx_power, info->rssi,
+		       info->cte_type, buf->len);
 }
 
 static void per_adv_sync_biginfo_cb(struct bt_le_per_adv_sync *sync,
@@ -1246,16 +1224,17 @@ static void per_adv_sync_biginfo_cb(struct bt_le_per_adv_sync *sync,
 	char le_addr[BT_ADDR_LE_STR_LEN];
 
 	bt_addr_le_to_str(biginfo->addr, le_addr, sizeof(le_addr));
-	bt_shell_print("BIG_INFO PER_ADV_SYNC[%u]: [DEVICE]: %s, sid 0x%02x, num_bis %u, "
-		       "nse 0x%02x, interval 0x%04x (%u us), bn 0x%02x, pto 0x%02x, irc 0x%02x, "
-		       "max_pdu 0x%04x, sdu_interval 0x%04x, max_sdu 0x%04x, phy %s, framing 0x%02x, "
-		       "%sencrypted",
-		       bt_le_per_adv_sync_get_index(sync), le_addr, biginfo->sid, biginfo->num_bis,
-		       biginfo->sub_evt_count, biginfo->iso_interval,
-		       BT_CONN_INTERVAL_TO_US(biginfo->iso_interval), biginfo->burst_number,
-		       biginfo->offset, biginfo->rep_count, biginfo->max_pdu, biginfo->sdu_interval,
-		       biginfo->max_sdu, phy2str(biginfo->phy), biginfo->framing,
-		       biginfo->encryption ? "" : "not ");
+	bt_shell_print(
+		"BIG_INFO PER_ADV_SYNC[%u]: [DEVICE]: %s, sid 0x%02x, num_bis %u, "
+		"nse 0x%02x, interval 0x%04x (%u us), bn 0x%02x, pto 0x%02x, irc 0x%02x, "
+		"max_pdu 0x%04x, sdu_interval 0x%04x, max_sdu 0x%04x, phy %s, framing 0x%02x, "
+		"%sencrypted",
+		bt_le_per_adv_sync_get_index(sync), le_addr, biginfo->sid, biginfo->num_bis,
+		biginfo->sub_evt_count, biginfo->iso_interval,
+		BT_CONN_INTERVAL_TO_US(biginfo->iso_interval), biginfo->burst_number,
+		biginfo->offset, biginfo->rep_count, biginfo->max_pdu, biginfo->sdu_interval,
+		biginfo->max_sdu, phy2str(biginfo->phy), biginfo->framing,
+		biginfo->encryption ? "" : "not ");
 }
 
 static struct bt_le_per_adv_sync_cb per_adv_sync_cb = {
@@ -1344,8 +1323,7 @@ static int cmd_disable(const struct shell *sh, size_t argc, char *argv[])
 }
 
 #ifdef CONFIG_SETTINGS
-static int cmd_settings_load(const struct shell *sh, size_t argc,
-			     char *argv[])
+static int cmd_settings_load(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 
@@ -1590,16 +1568,16 @@ static int cmd_id_select(const struct shell *sh, size_t argc, char *argv[])
 }
 
 #if defined(CONFIG_BT_OBSERVER)
-static int cmd_active_scan_on(const struct shell *sh, uint32_t options,
-			      uint16_t timeout)
+static int cmd_active_scan_on(const struct shell *sh, uint32_t options, uint16_t timeout)
 {
 	int err;
 	struct bt_le_scan_param param = {
-			.type       = BT_LE_SCAN_TYPE_ACTIVE,
-			.options    = BT_LE_SCAN_OPT_NONE,
-			.interval   = BT_GAP_SCAN_FAST_INTERVAL,
-			.window     = BT_GAP_SCAN_FAST_WINDOW,
-			.timeout    = 0, };
+		.type = BT_LE_SCAN_TYPE_ACTIVE,
+		.options = BT_LE_SCAN_OPT_NONE,
+		.interval = BT_GAP_SCAN_FAST_INTERVAL,
+		.window = BT_GAP_SCAN_FAST_WINDOW,
+		.timeout = 0,
+	};
 
 	param.options |= options;
 
@@ -1619,15 +1597,15 @@ static int cmd_active_scan_on(const struct shell *sh, uint32_t options,
 	return 0;
 }
 
-static int cmd_passive_scan_on(const struct shell *sh, uint32_t options,
-			       uint16_t timeout)
+static int cmd_passive_scan_on(const struct shell *sh, uint32_t options, uint16_t timeout)
 {
 	struct bt_le_scan_param param = {
-			.type       = BT_LE_SCAN_TYPE_PASSIVE,
-			.options    = BT_LE_SCAN_OPT_NONE,
-			.interval   = 0x10,
-			.window     = 0x10,
-			.timeout    = timeout, };
+		.type = BT_LE_SCAN_TYPE_PASSIVE,
+		.options = BT_LE_SCAN_OPT_NONE,
+		.interval = 0x10,
+		.window = 0x10,
+		.timeout = timeout,
+	};
 	int err;
 
 	param.options |= options;
@@ -1735,14 +1713,13 @@ static int cmd_scan_verbose_output(const struct shell *sh, size_t argc, char *ar
 	return 0;
 }
 
-static int cmd_scan_filter_set_name(const struct shell *sh, size_t argc,
-				    char *argv[])
+static int cmd_scan_filter_set_name(const struct shell *sh, size_t argc, char *argv[])
 {
 	const char *name_arg = argv[1];
 
 	if (strlen(name_arg) >= sizeof(scan_filter.name)) {
-		shell_error(sh, "Name is too long (max %zu): %s\n",
-			    sizeof(scan_filter.name), name_arg);
+		shell_error(sh, "Name is too long (max %zu): %s\n", sizeof(scan_filter.name),
+			    name_arg);
 		return -ENOEXEC;
 	}
 
@@ -1752,8 +1729,7 @@ static int cmd_scan_filter_set_name(const struct shell *sh, size_t argc,
 	return 0;
 }
 
-static int cmd_scan_filter_set_addr(const struct shell *sh, size_t argc,
-				    char *argv[])
+static int cmd_scan_filter_set_addr(const struct shell *sh, size_t argc, char *argv[])
 {
 	const size_t max_cpy_len = sizeof(scan_filter.addr) - 1;
 	const char *addr_arg = argv[1];
@@ -1809,8 +1785,7 @@ static int cmd_scan_filter_set_rssi(const struct shell *sh, size_t argc, char *a
 	return SHELL_CMD_HELP_PRINTED;
 }
 
-static int cmd_scan_filter_set_pa_interval(const struct shell *sh, size_t argc,
-					   char *argv[])
+static int cmd_scan_filter_set_pa_interval(const struct shell *sh, size_t argc, char *argv[])
 {
 	unsigned long pa_interval;
 	int err = 0;
@@ -1818,19 +1793,16 @@ static int cmd_scan_filter_set_pa_interval(const struct shell *sh, size_t argc,
 	pa_interval = shell_strtoul(argv[1], 10, &err);
 
 	if (!err) {
-		if (IN_RANGE(pa_interval,
-			     BT_GAP_PER_ADV_MIN_INTERVAL,
+		if (IN_RANGE(pa_interval, BT_GAP_PER_ADV_MIN_INTERVAL,
 			     BT_GAP_PER_ADV_MAX_INTERVAL)) {
 			scan_filter.pa_interval = (uint16_t)pa_interval;
 			scan_filter.pa_interval_set = true;
-			shell_print(sh, "PA interval cutoff set at %u",
-				    scan_filter.pa_interval);
+			shell_print(sh, "PA interval cutoff set at %u", scan_filter.pa_interval);
 
 			return 0;
 		}
 
-		shell_print(sh, "value out of bounds (%d to %d)",
-			    BT_GAP_PER_ADV_MIN_INTERVAL,
+		shell_print(sh, "value out of bounds (%d to %d)", BT_GAP_PER_ADV_MIN_INTERVAL,
 			    BT_GAP_PER_ADV_MAX_INTERVAL);
 
 		err = -ERANGE;
@@ -1842,8 +1814,7 @@ static int cmd_scan_filter_set_pa_interval(const struct shell *sh, size_t argc,
 	return SHELL_CMD_HELP_PRINTED;
 }
 
-static int cmd_scan_filter_clear_all(const struct shell *sh, size_t argc,
-				     char *argv[])
+static int cmd_scan_filter_clear_all(const struct shell *sh, size_t argc, char *argv[])
 {
 	(void)memset(&scan_filter, 0, sizeof(scan_filter));
 
@@ -1856,8 +1827,7 @@ static void bt_do_scan_filter_clear_name(void)
 	scan_filter.name_set = false;
 }
 
-static int cmd_scan_filter_clear_name(const struct shell *sh, size_t argc,
-				      char *argv[])
+static int cmd_scan_filter_clear_name(const struct shell *sh, size_t argc, char *argv[])
 {
 	ARG_UNUSED(sh);
 	ARG_UNUSED(argc);
@@ -1868,8 +1838,7 @@ static int cmd_scan_filter_clear_name(const struct shell *sh, size_t argc,
 	return 0;
 }
 
-static int cmd_scan_filter_clear_addr(const struct shell *sh, size_t argc,
-				      char *argv[])
+static int cmd_scan_filter_clear_addr(const struct shell *sh, size_t argc, char *argv[])
 {
 	ARG_UNUSED(sh);
 	ARG_UNUSED(argc);
@@ -1900,8 +1869,7 @@ static ssize_t ad_init(struct bt_data *data_array, const size_t data_array_size,
 		/* A privacy-enabled Set Member should advertise RSI values only when in
 		 * the GAP Limited Discoverable mode.
 		 */
-		if (IS_ENABLED(CONFIG_BT_PRIVACY) &&
-		    IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER) &&
+		if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER) &&
 		    svc_inst != NULL) {
 			ad_flags |= BT_LE_AD_LIMITED;
 		} else {
@@ -1932,8 +1900,8 @@ static ssize_t ad_init(struct bt_data *data_array, const size_t data_array_size,
 	if (IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER)) {
 		ssize_t csis_ad_len;
 
-		csis_ad_len = csis_ad_data_add(&data_array[ad_len],
-					       data_array_size - ad_len, discoverable);
+		csis_ad_len = csis_ad_data_add(&data_array[ad_len], data_array_size - ad_len,
+					       discoverable);
 		if (csis_ad_len < 0) {
 			bt_shell_error("Failed to add CSIS data (err %d)", csis_ad_len);
 			return ad_len;
@@ -2082,8 +2050,7 @@ fail:
 }
 
 #if defined(CONFIG_BT_PERIPHERAL)
-static int cmd_directed_adv(const struct shell *sh,
-			     size_t argc, char *argv[])
+static int cmd_directed_adv(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 	bt_addr_le_t addr;
@@ -2132,8 +2099,7 @@ static int cmd_directed_adv(const struct shell *sh,
 #endif /* CONFIG_BT_PERIPHERAL */
 
 #if defined(CONFIG_BT_EXT_ADV)
-static bool adv_param_parse(size_t argc, char *argv[],
-			    struct bt_le_adv_param *param)
+static bool adv_param_parse(size_t argc, char *argv[], struct bt_le_adv_param *param)
 {
 	memset(param, 0, sizeof(struct bt_le_adv_param));
 
@@ -2204,8 +2170,7 @@ static bool adv_param_parse(size_t argc, char *argv[],
 
 	param->id = selected_id;
 	param->sid = 0;
-	if (param->peer &&
-	    !(param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY)) {
+	if (param->peer && !(param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY)) {
 		param->interval_min = 0;
 		param->interval_max = 0;
 	} else {
@@ -2302,7 +2267,7 @@ static int cmd_adv_data(const struct shell *sh, size_t argc, char *argv[])
 			if (*data_len == ARRAY_SIZE(ad)) {
 				/* Maximum entries limit reached. */
 				shell_print(sh, "Failed to set advertising data: "
-					    "Maximum entries limit reached");
+						"Maximum entries limit reached");
 
 				return -ENOEXEC;
 			}
@@ -2322,7 +2287,7 @@ static int cmd_adv_data(const struct shell *sh, size_t argc, char *argv[])
 		if (strcmp(arg, "scan-response") && *data_len == ARRAY_SIZE(ad)) {
 			/* Maximum entries limit reached. */
 			shell_print(sh, "Failed to set advertising data: "
-				    "Maximum entries limit reached");
+					"Maximum entries limit reached");
 
 			return -ENOEXEC;
 		}
@@ -2336,7 +2301,7 @@ static int cmd_adv_data(const struct shell *sh, size_t argc, char *argv[])
 		} else if (!strcmp(arg, "scan-response")) {
 			if (data == sd) {
 				shell_print(sh, "Failed to set advertising data: "
-					    "duplicate scan-response option");
+						"duplicate scan-response option");
 				return -ENOEXEC;
 			}
 
@@ -2353,7 +2318,7 @@ static int cmd_adv_data(const struct shell *sh, size_t argc, char *argv[])
 
 			if (!len || (len - 1) != (hex_data[hex_data_len])) {
 				shell_print(sh, "Failed to set advertising data: "
-					    "malformed hex data");
+						"malformed hex data");
 				return -ENOEXEC;
 			}
 
@@ -2374,7 +2339,7 @@ static int cmd_adv_data(const struct shell *sh, size_t argc, char *argv[])
 		if (*data_len == ARRAY_SIZE(ad)) {
 			/* Maximum entries limit reached. */
 			shell_print(sh, "Failed to set advertising data: "
-				    "Maximum entries limit reached");
+					"Maximum entries limit reached");
 
 			return -ENOEXEC;
 		}
@@ -2400,8 +2365,8 @@ static int cmd_adv_data(const struct shell *sh, size_t argc, char *argv[])
 		sd_len += len;
 	}
 
-	err = bt_le_ext_adv_set_data(adv, ad_len > 0 ? ad : NULL, ad_len,
-					  sd_len > 0 ? sd : NULL, sd_len);
+	err = bt_le_ext_adv_set_data(adv, ad_len > 0 ? ad : NULL, ad_len, sd_len > 0 ? sd : NULL,
+				     sd_len);
 	if (err) {
 		shell_print(sh, "Failed to set advertising set data (%d)", err);
 		return -ENOEXEC;
@@ -2615,8 +2580,7 @@ static int cmd_per_adv(const struct shell *sh, size_t argc, char *argv[])
 	return 0;
 }
 
-static int cmd_per_adv_param(const struct shell *sh, size_t argc,
-			     char *argv[])
+static int cmd_per_adv_param(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_le_ext_adv *adv = adv_sets[selected_adv];
 	struct bt_le_per_adv_param param;
@@ -2659,16 +2623,14 @@ static int cmd_per_adv_param(const struct shell *sh, size_t argc,
 	return 0;
 }
 
-static ssize_t pa_ad_init(struct bt_data *data_array,
-			  const size_t data_array_size)
+static ssize_t pa_ad_init(struct bt_data *data_array, const size_t data_array_size)
 {
 	size_t ad_len = 0;
 
 	if (IS_ENABLED(CONFIG_BT_AUDIO)) {
 		ssize_t audio_pa_ad_len;
 
-		audio_pa_ad_len = audio_pa_data_add(&data_array[ad_len],
-						    data_array_size - ad_len);
+		audio_pa_ad_len = audio_pa_data_add(&data_array[ad_len], data_array_size - ad_len);
 		if (audio_pa_ad_len < 0U) {
 			return audio_pa_ad_len;
 		}
@@ -2679,8 +2641,7 @@ static ssize_t pa_ad_init(struct bt_data *data_array,
 	return ad_len;
 }
 
-static int cmd_per_adv_data(const struct shell *sh, size_t argc,
-			    char *argv[])
+static int cmd_per_adv_data(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_le_ext_adv *adv = adv_sets[selected_adv];
 	static uint8_t hex_data[256];
@@ -2698,8 +2659,7 @@ static int cmd_per_adv_data(const struct shell *sh, size_t argc,
 		size_t hex_len = 0U;
 
 		(void)memset(hex_data, 0, sizeof(hex_data));
-		hex_len = hex2bin(argv[1U], strlen(argv[1U]), hex_data,
-				  sizeof(hex_data));
+		hex_len = hex2bin(argv[1U], strlen(argv[1U]), hex_data, sizeof(hex_data));
 
 		if (hex_len == 0U) {
 			shell_error(sh, "Could not parse adv data");
@@ -2735,12 +2695,11 @@ static int cmd_per_adv_data(const struct shell *sh, size_t argc,
 
 #if defined(CONFIG_BT_PER_ADV_SYNC)
 
-static int cmd_per_adv_sync_create(const struct shell *sh, size_t argc,
-				   char *argv[])
+static int cmd_per_adv_sync_create(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_le_per_adv_sync *per_adv_sync = per_adv_syncs[selected_per_adv_sync];
 	int err;
-	struct bt_le_per_adv_sync_param create_params = { 0 };
+	struct bt_le_per_adv_sync_param create_params = {0};
 	uint32_t options = 0;
 
 	if (per_adv_sync != NULL) {
@@ -2803,8 +2762,7 @@ static int cmd_per_adv_sync_create(const struct shell *sh, size_t argc,
 	return 0;
 }
 
-static int cmd_per_adv_sync_delete(const struct shell *sh, size_t argc,
-				   char *argv[])
+static int cmd_per_adv_sync_delete(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_le_per_adv_sync *per_adv_sync = per_adv_syncs[selected_per_adv_sync];
 	int err;
@@ -2857,8 +2815,7 @@ static int cmd_per_adv_sync_select(const struct shell *sh, size_t argc, char *ar
 }
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER)
-static int cmd_past_subscribe(const struct shell *sh, size_t argc,
-			      char *argv[])
+static int cmd_past_subscribe(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_le_per_adv_sync_transfer_param param;
 	int err;
@@ -2877,17 +2834,13 @@ static int cmd_past_subscribe(const struct shell *sh, size_t argc,
 
 	for (int j = 1; j < argc; j++) {
 		if (!strcmp(argv[j], "aoa")) {
-			param.options |=
-				BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_NO_AOA;
+			param.options |= BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_NO_AOA;
 		} else if (!strcmp(argv[j], "aod_1us")) {
-			param.options |=
-				BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_NO_AOD_1US;
+			param.options |= BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_NO_AOD_1US;
 		} else if (!strcmp(argv[j], "aod_2us")) {
-			param.options |=
-				BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_NO_AOD_2US;
+			param.options |= BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_NO_AOD_2US;
 		} else if (!strcmp(argv[j], "only_cte")) {
-			param.options |=
-				BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_ONLY_CTE;
+			param.options |= BT_LE_PER_ADV_SYNC_TRANSFER_OPT_SYNC_ONLY_CTE;
 		} else if (!strcmp(argv[j], "timeout")) {
 			if (++j == argc) {
 				shell_help(sh);
@@ -2916,8 +2869,7 @@ static int cmd_past_subscribe(const struct shell *sh, size_t argc,
 
 	bt_le_per_adv_sync_cb_register(&per_adv_sync_cb);
 
-	err = bt_le_per_adv_sync_transfer_subscribe(
-		global ? NULL : default_conn, &param);
+	err = bt_le_per_adv_sync_transfer_subscribe(global ? NULL : default_conn, &param);
 
 	if (err) {
 		shell_error(sh, "PAST subscribe failed (%d)", err);
@@ -2928,17 +2880,14 @@ static int cmd_past_subscribe(const struct shell *sh, size_t argc,
 	return 0;
 }
 
-static int cmd_past_unsubscribe(const struct shell *sh, size_t argc,
-				char *argv[])
+static int cmd_past_unsubscribe(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 
 	if (argc > 1) {
 		if (!strcmp(argv[1], "conn")) {
 			if (default_conn) {
-				err =
-					bt_le_per_adv_sync_transfer_unsubscribe(
-						default_conn);
+				err = bt_le_per_adv_sync_transfer_unsubscribe(default_conn);
 			} else {
 				shell_print(sh, "Not connected");
 				return -EINVAL;
@@ -2960,8 +2909,7 @@ static int cmd_past_unsubscribe(const struct shell *sh, size_t argc,
 #endif /* CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER */
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER)
-static int cmd_per_adv_sync_transfer(const struct shell *sh, size_t argc,
-				     char *argv[])
+static int cmd_per_adv_sync_transfer(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 	int index;
@@ -2994,8 +2942,7 @@ static int cmd_per_adv_sync_transfer(const struct shell *sh, size_t argc,
 #endif /* CONFIG_BT_PER_ADV_SYNC */
 
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER) && defined(CONFIG_BT_PER_ADV)
-static int cmd_per_adv_set_info_transfer(const struct shell *sh, size_t argc,
-					 char *argv[])
+static int cmd_per_adv_set_info_transfer(const struct shell *sh, size_t argc, char *argv[])
 {
 	const struct bt_le_ext_adv *adv = adv_sets[selected_adv];
 	int err;
@@ -3283,10 +3230,8 @@ static int bt_do_connect_le(int *ercd, size_t argc, char *argv[])
 	}
 #endif /* defined(CONFIG_BT_EXT_ADV) */
 
-	struct bt_conn_le_create_param *create_params =
-		BT_CONN_LE_CREATE_PARAM(options,
-					BT_GAP_SCAN_FAST_INTERVAL,
-					BT_GAP_SCAN_FAST_INTERVAL);
+	struct bt_conn_le_create_param *create_params = BT_CONN_LE_CREATE_PARAM(
+		options, BT_GAP_SCAN_FAST_INTERVAL, BT_GAP_SCAN_FAST_INTERVAL);
 
 	err = bt_conn_le_create(&addr, create_params, BT_LE_CONN_PARAM_DEFAULT, &conn);
 	if (err) {
@@ -3329,11 +3274,11 @@ static int cmd_connect_le(const struct shell *sh, size_t argc, char *argv[])
 static int cmd_connect_le_name(const struct shell *sh, size_t argc, char *argv[])
 {
 	const struct bt_le_scan_param param = {
-		.type       = BT_LE_SCAN_TYPE_ACTIVE,
-		.options    = BT_LE_SCAN_OPT_NONE,
-		.interval   = BT_GAP_SCAN_FAST_INTERVAL,
-		.window     = BT_GAP_SCAN_FAST_WINDOW,
-		.timeout    = 0,
+		.type = BT_LE_SCAN_TYPE_ACTIVE,
+		.options = BT_LE_SCAN_OPT_NONE,
+		.interval = BT_GAP_SCAN_FAST_INTERVAL,
+		.window = BT_GAP_SCAN_FAST_WINDOW,
+		.timeout = 0,
 	};
 	int err;
 
@@ -3342,8 +3287,8 @@ static int cmd_connect_le_name(const struct shell *sh, size_t argc, char *argv[]
 	 */
 	err = cmd_scan_filter_set_name(sh, argc, argv);
 	if (err) {
-		shell_error(sh, "Bluetooth set scan filter name to %s failed (err %d)",
-			    argv[1], err);
+		shell_error(sh, "Bluetooth set scan filter name to %s failed (err %d)", argv[1],
+			    err);
 		return err;
 	}
 
@@ -3439,19 +3384,26 @@ static int cmd_select(const struct shell *sh, size_t argc, char *argv[])
 static const char *get_conn_type_str(uint8_t type)
 {
 	switch (type) {
-	case BT_CONN_TYPE_LE: return "LE";
-	case BT_CONN_TYPE_BR: return "BR/EDR";
-	case BT_CONN_TYPE_SCO: return "SCO";
-	default: return "Invalid";
+	case BT_CONN_TYPE_LE:
+		return "LE";
+	case BT_CONN_TYPE_BR:
+		return "BR/EDR";
+	case BT_CONN_TYPE_SCO:
+		return "SCO";
+	default:
+		return "Invalid";
 	}
 }
 
 static const char *get_conn_role_str(uint8_t role)
 {
 	switch (role) {
-	case BT_CONN_ROLE_CENTRAL: return "central";
-	case BT_CONN_ROLE_PERIPHERAL: return "peripheral";
-	default: return "Invalid";
+	case BT_CONN_ROLE_CENTRAL:
+		return "central";
+	case BT_CONN_ROLE_PERIPHERAL:
+		return "peripheral";
+	default:
+		return "Invalid";
 	}
 }
 
@@ -3499,10 +3451,8 @@ static int cmd_info(const struct shell *sh, size_t argc, char *argv[])
 		goto done;
 	}
 
-	shell_print(sh, "Type: %s, Role: %s, Id: %u",
-		    get_conn_type_str(info.type),
-		    get_conn_role_str(info.role),
-		    info.id);
+	shell_print(sh, "Type: %s, Role: %s, Id: %u", get_conn_type_str(info.type),
+		    get_conn_role_str(info.role), info.id);
 
 	if (info.type == BT_CONN_TYPE_LE) {
 		print_le_addr("Remote", info.le.dst);
@@ -3510,16 +3460,13 @@ static int cmd_info(const struct shell *sh, size_t argc, char *argv[])
 		print_le_addr("Remote on-air", info.le.remote);
 		print_le_addr("Local on-air", info.le.local);
 
-		shell_print(sh, "Interval: 0x%04x (%u us)",
-			    info.le.interval,
+		shell_print(sh, "Interval: 0x%04x (%u us)", info.le.interval,
 			    BT_CONN_INTERVAL_TO_US(info.le.interval));
-		shell_print(sh, "Latency: 0x%04x",
-			    info.le.latency);
-		shell_print(sh, "Supervision timeout: 0x%04x (%d ms)",
-			    info.le.timeout, info.le.timeout * 10);
+		shell_print(sh, "Latency: 0x%04x", info.le.latency);
+		shell_print(sh, "Supervision timeout: 0x%04x (%d ms)", info.le.timeout,
+			    info.le.timeout * 10);
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
-		shell_print(sh, "LE PHY: TX PHY %s, RX PHY %s",
-			    phy2str(info.le.phy->tx_phy),
+		shell_print(sh, "LE PHY: TX PHY %s, RX PHY %s", phy2str(info.le.phy->tx_phy),
 			    phy2str(info.le.phy->rx_phy));
 #endif
 #if defined(CONFIG_BT_USER_DATA_LEN_UPDATE)
@@ -3595,8 +3542,7 @@ static uint16_t tx_time_calc(uint8_t phy, uint16_t max_len)
 	}
 }
 
-static int cmd_conn_data_len_update(const struct shell *sh, size_t argc,
-				    char *argv[])
+static int cmd_conn_data_len_update(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_conn_le_data_len_param param;
 	int err;
@@ -3639,8 +3585,7 @@ static int cmd_conn_data_len_update(const struct shell *sh, size_t argc,
 #endif
 
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
-static int cmd_conn_phy_update(const struct shell *sh, size_t argc,
-			       char *argv[])
+static int cmd_conn_phy_update(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_conn_le_phy_param param;
 	int err;
@@ -3717,8 +3662,7 @@ static int cmd_oob(const struct shell *sh, size_t argc, char *argv[])
 }
 
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
-static int cmd_oob_remote(const struct shell *sh, size_t argc,
-			     char *argv[])
+static int cmd_oob_remote(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 	bt_addr_le_t addr;
@@ -3818,14 +3762,12 @@ static int cmd_security(const struct shell *sh, size_t argc, char *argv[])
 
 	sec = *argv[1] - '0';
 
-	if ((info.type == BT_CONN_TYPE_BR &&
-	    (sec < BT_SECURITY_L0 || sec > BT_SECURITY_L3))) {
+	if ((info.type == BT_CONN_TYPE_BR && (sec < BT_SECURITY_L0 || sec > BT_SECURITY_L3))) {
 		shell_error(sh, "Invalid BR/EDR security level (%d)", sec);
 		return -ENOEXEC;
 	}
 
-	if ((info.type == BT_CONN_TYPE_LE &&
-	    (sec < BT_SECURITY_L1 || sec > BT_SECURITY_L4))) {
+	if ((info.type == BT_CONN_TYPE_LE && (sec < BT_SECURITY_L1 || sec > BT_SECURITY_L4))) {
 		shell_error(sh, "Invalid LE security level (%d)", sec);
 		return -ENOEXEC;
 	}
@@ -3987,8 +3929,7 @@ static void auth_passkey_display(struct bt_conn *conn, unsigned int passkey)
 }
 
 #if defined(CONFIG_BT_PASSKEY_KEYPRESS)
-static void auth_passkey_display_keypress(struct bt_conn *conn,
-					  enum bt_conn_auth_keypress type)
+static void auth_passkey_display_keypress(struct bt_conn *conn, enum bt_conn_auth_keypress type)
 {
 	char addr[BT_ADDR_LE_STR_LEN];
 
@@ -4060,8 +4001,7 @@ static const char *oob_config_str(int oob_config)
 }
 #endif /* !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) */
 
-static void auth_pairing_oob_data_request(struct bt_conn *conn,
-					  struct bt_conn_oob_info *oob_info)
+static void auth_pairing_oob_data_request(struct bt_conn *conn, struct bt_conn_oob_info *oob_info)
 {
 	char addr[BT_ADDR_LE_STR_LEN];
 	struct bt_conn_info info;
@@ -4075,24 +4015,20 @@ static void auth_pairing_oob_data_request(struct bt_conn *conn,
 #if !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)
 	if (oob_info->type == BT_CONN_OOB_LE_SC) {
 		struct bt_le_oob_sc_data *oobd_local =
-			oob_info->lesc.oob_config != BT_CONN_OOB_REMOTE_ONLY
-						  ? &oob_local.le_sc_data
-						  : NULL;
+			oob_info->lesc.oob_config != BT_CONN_OOB_REMOTE_ONLY ? &oob_local.le_sc_data
+									     : NULL;
 		struct bt_le_oob_sc_data *oobd_remote =
-			oob_info->lesc.oob_config != BT_CONN_OOB_LOCAL_ONLY
-						  ? &oob_remote.le_sc_data
-						  : NULL;
+			oob_info->lesc.oob_config != BT_CONN_OOB_LOCAL_ONLY ? &oob_remote.le_sc_data
+									    : NULL;
 
-		if (oobd_remote &&
-		    !bt_addr_le_eq(info.le.remote, &oob_remote.addr)) {
+		if (oobd_remote && !bt_addr_le_eq(info.le.remote, &oob_remote.addr)) {
 			bt_addr_le_to_str(info.le.remote, addr, sizeof(addr));
 			bt_shell_print("No OOB data available for remote %s", addr);
 			bt_conn_auth_cancel(conn);
 			return;
 		}
 
-		if (oobd_local &&
-		    !bt_addr_le_eq(info.le.local, &oob_local.addr)) {
+		if (oobd_local && !bt_addr_le_eq(info.le.local, &oob_local.addr)) {
 			bt_addr_le_to_str(info.le.local, addr, sizeof(addr));
 			bt_shell_print("No OOB data available for local %s", addr);
 			bt_conn_auth_cancel(conn);
@@ -4169,9 +4105,8 @@ enum bt_security_err pairing_accept(struct bt_conn *conn,
 	bt_shell_print("Remote pairing features: "
 		       "IO: 0x%02x, OOB: %d, AUTH: 0x%02x, Key: %d, "
 		       "Init Kdist: 0x%02x, Resp Kdist: 0x%02x",
-		       feat->io_capability, feat->oob_data_flag,
-		       feat->auth_req, feat->max_enc_key_size,
-		       feat->init_key_dist, feat->resp_key_dist);
+		       feat->io_capability, feat->oob_data_flag, feat->auth_req,
+		       feat->max_enc_key_size, feat->init_key_dist, feat->resp_key_dist);
 
 	return BT_SECURITY_ERR_SUCCESS;
 }
@@ -4319,8 +4254,7 @@ static int cmd_auth(const struct shell *sh, size_t argc, char *argv[])
 	return err;
 }
 
-static int cmd_auth_cancel(const struct shell *sh,
-			   size_t argc, char *argv[])
+static int cmd_auth_cancel(const struct shell *sh, size_t argc, char *argv[])
 {
 	struct bt_conn *conn;
 
@@ -4342,8 +4276,7 @@ static int cmd_auth_cancel(const struct shell *sh,
 	return 0;
 }
 
-static int cmd_auth_passkey_confirm(const struct shell *sh,
-				    size_t argc, char *argv[])
+static int cmd_auth_passkey_confirm(const struct shell *sh, size_t argc, char *argv[])
 {
 	if (!default_conn) {
 		shell_print(sh, "Not connected");
@@ -4354,8 +4287,7 @@ static int cmd_auth_passkey_confirm(const struct shell *sh,
 	return 0;
 }
 
-static int cmd_auth_pairing_confirm(const struct shell *sh,
-				    size_t argc, char *argv[])
+static int cmd_auth_pairing_confirm(const struct shell *sh, size_t argc, char *argv[])
 {
 	if (!default_conn) {
 		shell_print(sh, "Not connected");
@@ -4440,10 +4372,8 @@ static int cmd_fal_connect(const struct shell *sh, size_t argc, char *argv[])
 		}
 	}
 #endif /* defined(CONFIG_BT_EXT_ADV) */
-	struct bt_conn_le_create_param *create_params =
-		BT_CONN_LE_CREATE_PARAM(options,
-					BT_GAP_SCAN_FAST_INTERVAL,
-					BT_GAP_SCAN_FAST_WINDOW);
+	struct bt_conn_le_create_param *create_params = BT_CONN_LE_CREATE_PARAM(
+		options, BT_GAP_SCAN_FAST_INTERVAL, BT_GAP_SCAN_FAST_WINDOW);
 
 	if (!strcmp(action, "on")) {
 		err = bt_conn_le_create_auto(create_params, BT_LE_CONN_PARAM_DEFAULT);
@@ -4465,8 +4395,7 @@ static int cmd_fal_connect(const struct shell *sh, size_t argc, char *argv[])
 #endif /* defined(CONFIG_BT_FILTER_ACCEPT_LIST) */
 
 #if defined(CONFIG_BT_FIXED_PASSKEY)
-static int cmd_fixed_passkey(const struct shell *sh,
-			     size_t argc, char *argv[])
+static int cmd_fixed_passkey(const struct shell *sh, size_t argc, char *argv[])
 {
 	unsigned int passkey;
 	int err;
@@ -4492,8 +4421,7 @@ static int cmd_fixed_passkey(const struct shell *sh,
 }
 #endif
 
-static int cmd_auth_passkey(const struct shell *sh,
-			    size_t argc, char *argv[])
+static int cmd_auth_passkey(const struct shell *sh, size_t argc, char *argv[])
 {
 	unsigned int passkey;
 	int err;
@@ -4519,8 +4447,7 @@ static int cmd_auth_passkey(const struct shell *sh,
 }
 
 #if defined(CONFIG_BT_PASSKEY_KEYPRESS)
-static int cmd_auth_passkey_notify(const struct shell *sh,
-				   size_t argc, char *argv[])
+static int cmd_auth_passkey_notify(const struct shell *sh, size_t argc, char *argv[])
 {
 	unsigned long type;
 	int err;
@@ -4848,9 +4775,9 @@ static int cmd_default_handler(const struct shell *sh, size_t argc, char **argv)
 	return -EINVAL;
 }
 
-#define HELP_NONE "[none]"
-#define HELP_ONOFF "<on, off>"
-#define HELP_ADDR "<address: XX:XX:XX:XX:XX:XX>"
+#define HELP_NONE    "[none]"
+#define HELP_ONOFF   "<on, off>"
+#define HELP_ADDR    "<address: XX:XX:XX:XX:XX:XX>"
 #define HELP_ADDR_LE "<address: XX:XX:XX:XX:XX:XX> <type: (public|random)>"
 
 #if defined(CONFIG_BT_EXT_ADV)
@@ -4867,50 +4794,47 @@ static int cmd_default_handler(const struct shell *sh, size_t argc, char **argv)
 
 #if defined(CONFIG_BT_OBSERVER)
 SHELL_STATIC_SUBCMD_SET_CREATE(bt_scan_filter_set_cmds,
-	SHELL_CMD_ARG(name, NULL, "<name>", cmd_scan_filter_set_name, 2, 0),
-	SHELL_CMD_ARG(addr, NULL, HELP_ADDR, cmd_scan_filter_set_addr, 2, 0),
-	SHELL_CMD_ARG(rssi, NULL, "<rssi>", cmd_scan_filter_set_rssi, 2, 0),
-	SHELL_CMD_ARG(pa_interval, NULL, "<pa_interval>",
-		      cmd_scan_filter_set_pa_interval, 2, 0),
-	SHELL_SUBCMD_SET_END
-);
+			       SHELL_CMD_ARG(name, NULL, "<name>", cmd_scan_filter_set_name, 2, 0),
+			       SHELL_CMD_ARG(addr, NULL, HELP_ADDR, cmd_scan_filter_set_addr, 2, 0),
+			       SHELL_CMD_ARG(rssi, NULL, "<rssi>", cmd_scan_filter_set_rssi, 2, 0),
+			       SHELL_CMD_ARG(pa_interval, NULL, "<pa_interval>",
+					     cmd_scan_filter_set_pa_interval, 2, 0),
+			       SHELL_SUBCMD_SET_END);
 
 SHELL_STATIC_SUBCMD_SET_CREATE(bt_scan_filter_clear_cmds,
-	SHELL_CMD_ARG(all, NULL, "", cmd_scan_filter_clear_all, 1, 0),
-	SHELL_CMD_ARG(name, NULL, "", cmd_scan_filter_clear_name, 1, 0),
-	SHELL_CMD_ARG(addr, NULL, "", cmd_scan_filter_clear_addr, 1, 0),
-	SHELL_SUBCMD_SET_END
-);
+			       SHELL_CMD_ARG(all, NULL, "", cmd_scan_filter_clear_all, 1, 0),
+			       SHELL_CMD_ARG(name, NULL, "", cmd_scan_filter_clear_name, 1, 0),
+			       SHELL_CMD_ARG(addr, NULL, "", cmd_scan_filter_clear_addr, 1, 0),
+			       SHELL_SUBCMD_SET_END);
 #endif /* CONFIG_BT_OBSERVER */
 
 #if defined(CONFIG_BT_EAD)
 SHELL_STATIC_SUBCMD_SET_CREATE(
 	bt_encrypted_ad_cmds,
-	SHELL_CMD_ARG(set-keys, NULL, "<session key> <init vector>", cmd_encrypted_ad_set_keys, 3,
+	SHELL_CMD_ARG(set - keys, NULL, "<session key> <init vector>", cmd_encrypted_ad_set_keys, 3,
 		      0),
-	SHELL_CMD_ARG(add-ead, NULL, "<advertising data>", cmd_encrypted_ad_add_ead, 2, 0),
-	SHELL_CMD_ARG(add-ad, NULL, "<advertising data>", cmd_encrypted_ad_add_ad, 2, 0),
-	SHELL_CMD(clear-ad, NULL, HELP_NONE, cmd_encrypted_ad_clear_ad),
-	SHELL_CMD(commit-ad, NULL, HELP_NONE, cmd_encrypted_ad_commit_ad),
-	SHELL_CMD_ARG(decrypt-scan, NULL, HELP_ONOFF, cmd_encrypted_ad_decrypt_scan, 2, 0),
+	SHELL_CMD_ARG(add - ead, NULL, "<advertising data>", cmd_encrypted_ad_add_ead, 2, 0),
+	SHELL_CMD_ARG(add - ad, NULL, "<advertising data>", cmd_encrypted_ad_add_ad, 2, 0),
+	SHELL_CMD(clear - ad, NULL, HELP_NONE, cmd_encrypted_ad_clear_ad),
+	SHELL_CMD(commit - ad, NULL, HELP_NONE, cmd_encrypted_ad_commit_ad),
+	SHELL_CMD_ARG(decrypt - scan, NULL, HELP_ONOFF, cmd_encrypted_ad_decrypt_scan, 2, 0),
 	SHELL_SUBCMD_SET_END);
 #endif
 
-SHELL_STATIC_SUBCMD_SET_CREATE(bt_cmds,
-	SHELL_CMD_ARG(init, NULL, "[no-settings-load], [sync]",
-		      cmd_init, 1, 2),
+SHELL_STATIC_SUBCMD_SET_CREATE(
+	bt_cmds, SHELL_CMD_ARG(init, NULL, "[no-settings-load], [sync]", cmd_init, 1, 2),
 	SHELL_CMD_ARG(disable, NULL, HELP_NONE, cmd_disable, 1, 0),
 #if defined(CONFIG_SETTINGS)
-	SHELL_CMD_ARG(settings-load, NULL, HELP_NONE, cmd_settings_load, 1, 0),
+	SHELL_CMD_ARG(settings - load, NULL, HELP_NONE, cmd_settings_load, 1, 0),
 #endif
 #if defined(CONFIG_BT_HCI)
-	SHELL_CMD_ARG(hci-cmd, NULL, "<ogf> <ocf> [data]", cmd_hci_cmd, 3, 1),
+	SHELL_CMD_ARG(hci - cmd, NULL, "<ogf> <ocf> [data]", cmd_hci_cmd, 3, 1),
 #endif
-	SHELL_CMD_ARG(id-create, NULL, HELP_ADDR, cmd_id_create, 1, 1),
-	SHELL_CMD_ARG(id-reset, NULL, "<id> "HELP_ADDR, cmd_id_reset, 2, 1),
-	SHELL_CMD_ARG(id-delete, NULL, "<id>", cmd_id_delete, 2, 0),
-	SHELL_CMD_ARG(id-show, NULL, HELP_NONE, cmd_id_show, 1, 0),
-	SHELL_CMD_ARG(id-select, NULL, "<id>", cmd_id_select, 2, 0),
+	SHELL_CMD_ARG(id - create, NULL, HELP_ADDR, cmd_id_create, 1, 1),
+	SHELL_CMD_ARG(id - reset, NULL, "<id> " HELP_ADDR, cmd_id_reset, 2, 1),
+	SHELL_CMD_ARG(id - delete, NULL, "<id>", cmd_id_delete, 2, 0),
+	SHELL_CMD_ARG(id - show, NULL, HELP_NONE, cmd_id_show, 1, 0),
+	SHELL_CMD_ARG(id - select, NULL, "<id>", cmd_id_select, 2, 0),
 	SHELL_CMD_ARG(name, NULL, "[name]", cmd_name, 1, 1),
 #if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
 	SHELL_CMD_ARG(appearance, NULL, "[new appearance value]", cmd_appearance, 1, 1),
@@ -4919,38 +4843,38 @@ SHELL_STATIC_SUBCMD_SET_CREATE(bt_cmds,
 #endif /* CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC */
 #if defined(CONFIG_BT_OBSERVER)
 	SHELL_CMD_ARG(scan, NULL,
-		      "<value: on, passive, off> [filter: dups, nodups] [fal]"
-		      EXT_ADV_SCAN_OPT,
+		      "<value: on, passive, off> [filter: dups, nodups] [fal]" EXT_ADV_SCAN_OPT,
 		      cmd_scan, 2, 4),
-	SHELL_CMD(scan-filter-set, &bt_scan_filter_set_cmds,
-		      "Scan filter set commands",
-		      cmd_default_handler),
-	SHELL_CMD(scan-filter-clear, &bt_scan_filter_clear_cmds,
-		      "Scan filter clear commands",
-		      cmd_default_handler),
-	SHELL_CMD_ARG(scan-verbose-output, NULL, "<value: on, off>", cmd_scan_verbose_output, 2, 0),
+	SHELL_CMD(scan - filter - set, &bt_scan_filter_set_cmds, "Scan filter set commands",
+		  cmd_default_handler),
+	SHELL_CMD(scan - filter - clear, &bt_scan_filter_clear_cmds, "Scan filter clear commands",
+		  cmd_default_handler),
+	SHELL_CMD_ARG(scan - verbose - output, NULL, "<value: on, off>", cmd_scan_verbose_output, 2,
+		      0),
 #endif /* CONFIG_BT_OBSERVER */
 #if defined(CONFIG_BT_TRANSMIT_POWER_CONTROL)
-	SHELL_CMD_ARG(read-remote-tx-power, NULL, HELP_NONE, cmd_read_remote_tx_power, 2, 0),
-	SHELL_CMD_ARG(read-local-tx-power, NULL, HELP_NONE, cmd_read_local_tx_power, 2, 0),
-	SHELL_CMD_ARG(set-power-report-enable, NULL, HELP_NONE, cmd_set_power_report_enable, 3, 0),
+	SHELL_CMD_ARG(read - remote - tx - power, NULL, HELP_NONE, cmd_read_remote_tx_power, 2, 0),
+	SHELL_CMD_ARG(read - local - tx - power, NULL, HELP_NONE, cmd_read_local_tx_power, 2, 0),
+	SHELL_CMD_ARG(set - power - report - enable, NULL, HELP_NONE, cmd_set_power_report_enable,
+		      3, 0),
 #endif
 #if defined(CONFIG_BT_PATH_LOSS_MONITORING)
-	SHELL_CMD_ARG(path-loss-monitoring-set-params, NULL,
-		      "<high threshold> <high hysteresis> <low threshold> <low hysteresis> <min time spent>",
+	SHELL_CMD_ARG(path - loss - monitoring - set - params, NULL,
+		      "<high threshold> <high hysteresis> <low threshold> <low hysteresis> <min "
+		      "time spent>",
 		      cmd_set_path_loss_reporting_parameters, 6, 0),
-	SHELL_CMD_ARG(path-loss-monitoring-enable, NULL, "<enable: true, false>",
+	SHELL_CMD_ARG(path - loss - monitoring - enable, NULL, "<enable: true, false>",
 		      cmd_set_path_loss_reporting_enable, 2, 0),
 #endif
 #if defined(CONFIG_BT_SUBRATING)
-	SHELL_CMD_ARG(subrate-set-defaults, NULL,
-		"<min subrate factor> <max subrate factor> <max peripheral latency> "
-		"<min continuation number> <supervision timeout (seconds)>",
-		cmd_subrate_set_defaults, 6, 0),
-	SHELL_CMD_ARG(subrate-request, NULL,
-		"<min subrate factor> <max subrate factor> <max peripheral latency> "
-		"<min continuation number> <supervision timeout (seconds)>",
-		cmd_subrate_request, 6, 0),
+	SHELL_CMD_ARG(subrate - set - defaults, NULL,
+		      "<min subrate factor> <max subrate factor> <max peripheral latency> "
+		      "<min continuation number> <supervision timeout (seconds)>",
+		      cmd_subrate_set_defaults, 6, 0),
+	SHELL_CMD_ARG(subrate - request, NULL,
+		      "<min subrate factor> <max subrate factor> <max peripheral latency> "
+		      "<min continuation number> <supervision timeout (seconds)>",
+		      cmd_subrate_request, 6, 0),
 #endif
 #if defined(CONFIG_BT_BROADCASTER)
 	SHELL_CMD_ARG(advertise, NULL,
@@ -4960,103 +4884,98 @@ SHELL_STATIC_SUBCMD_SET_CREATE(bt_cmds,
 		      "[disable-37] [disable-38] [disable-39]",
 		      cmd_advertise, 2, 8),
 #if defined(CONFIG_BT_PERIPHERAL)
-	SHELL_CMD_ARG(directed-adv, NULL, HELP_ADDR_LE " [mode: low] "
-		      "[identity] [dir-rpa]",
+	SHELL_CMD_ARG(directed - adv, NULL,
+		      HELP_ADDR_LE " [mode: low] "
+				   "[identity] [dir-rpa]",
 		      cmd_directed_adv, 3, 6),
 #endif /* CONFIG_BT_PERIPHERAL */
 #if defined(CONFIG_BT_EXT_ADV)
-	SHELL_CMD_ARG(adv-create, NULL, EXT_ADV_PARAM, cmd_adv_create, 2, 11),
-	SHELL_CMD_ARG(adv-param, NULL, EXT_ADV_PARAM, cmd_adv_param, 2, 11),
-	SHELL_CMD_ARG(adv-data, NULL, "<data> [scan-response <data>] "
-				      "<type: discov, hex> [appearance] "
-				      "[name <str>] [dev-name]",
+	SHELL_CMD_ARG(adv - create, NULL, EXT_ADV_PARAM, cmd_adv_create, 2, 11),
+	SHELL_CMD_ARG(adv - param, NULL, EXT_ADV_PARAM, cmd_adv_param, 2, 11),
+	SHELL_CMD_ARG(adv - data, NULL,
+		      "<data> [scan-response <data>] "
+		      "<type: discov, hex> [appearance] "
+		      "[name <str>] [dev-name]",
 		      cmd_adv_data, 1, 16),
-	SHELL_CMD_ARG(adv-start, NULL,
-		"[timeout <timeout>] [num-events <num events>]",
-		cmd_adv_start, 1, 4),
-	SHELL_CMD_ARG(adv-stop, NULL, HELP_NONE, cmd_adv_stop, 1, 0),
-	SHELL_CMD_ARG(adv-delete, NULL, HELP_NONE, cmd_adv_delete, 1, 0),
-	SHELL_CMD_ARG(adv-select, NULL, "[adv]", cmd_adv_select, 1, 1),
-	SHELL_CMD_ARG(adv-info, NULL, HELP_NONE, cmd_adv_info, 1, 0),
+	SHELL_CMD_ARG(adv - start, NULL, "[timeout <timeout>] [num-events <num events>]",
+		      cmd_adv_start, 1, 4),
+	SHELL_CMD_ARG(adv - stop, NULL, HELP_NONE, cmd_adv_stop, 1, 0),
+	SHELL_CMD_ARG(adv - delete, NULL, HELP_NONE, cmd_adv_delete, 1, 0),
+	SHELL_CMD_ARG(adv - select, NULL, "[adv]", cmd_adv_select, 1, 1),
+	SHELL_CMD_ARG(adv - info, NULL, HELP_NONE, cmd_adv_info, 1, 0),
 #if defined(CONFIG_BT_PERIPHERAL)
-	SHELL_CMD_ARG(adv-oob, NULL, HELP_NONE, cmd_adv_oob, 1, 0),
+	SHELL_CMD_ARG(adv - oob, NULL, HELP_NONE, cmd_adv_oob, 1, 0),
 #endif /* CONFIG_BT_PERIPHERAL */
 #if defined(CONFIG_BT_PRIVACY)
-	SHELL_CMD_ARG(adv-rpa-expire, NULL, HELP_ONOFF, cmd_adv_rpa_expire, 2, 0),
+	SHELL_CMD_ARG(adv - rpa - expire, NULL, HELP_ONOFF, cmd_adv_rpa_expire, 2, 0),
 #endif
 #if defined(CONFIG_BT_PER_ADV)
-	SHELL_CMD_ARG(per-adv, NULL, HELP_ONOFF, cmd_per_adv, 2, 0),
-	SHELL_CMD_ARG(per-adv-param, NULL,
-		      "[<interval-min> [<interval-max> [tx_power]]]",
+	SHELL_CMD_ARG(per - adv, NULL, HELP_ONOFF, cmd_per_adv, 2, 0),
+	SHELL_CMD_ARG(per - adv - param, NULL, "[<interval-min> [<interval-max> [tx_power]]]",
 		      cmd_per_adv_param, 1, 3),
-	SHELL_CMD_ARG(per-adv-data, NULL, "[data]", cmd_per_adv_data, 1, 1),
+	SHELL_CMD_ARG(per - adv - data, NULL, "[data]", cmd_per_adv_data, 1, 1),
 #endif /* CONFIG_BT_PER_ADV */
 #endif /* CONFIG_BT_EXT_ADV */
 #endif /* CONFIG_BT_BROADCASTER */
 #if defined(CONFIG_BT_PER_ADV_SYNC)
-	SHELL_CMD_ARG(per-adv-sync-create, NULL,
+	SHELL_CMD_ARG(per - adv - sync - create, NULL,
 		      HELP_ADDR_LE " <sid> [skip <count>] [timeout <ms>] [aoa] "
-		      "[aod_1us] [aod_2us] [cte_only]",
+				   "[aod_1us] [aod_2us] [cte_only]",
 		      cmd_per_adv_sync_create, 4, 6),
-	SHELL_CMD_ARG(per-adv-sync-delete, NULL, "[<index>]",
-		      cmd_per_adv_sync_delete, 1, 1),
-	SHELL_CMD_ARG(per-adv-sync-select, NULL, "[adv]", cmd_per_adv_sync_select, 1, 1),
+	SHELL_CMD_ARG(per - adv - sync - delete, NULL, "[<index>]", cmd_per_adv_sync_delete, 1, 1),
+	SHELL_CMD_ARG(per - adv - sync - select, NULL, "[adv]", cmd_per_adv_sync_select, 1, 1),
 #endif /* defined(CONFIG_BT_PER_ADV_SYNC) */
 #if defined(CONFIG_BT_EAD)
-	SHELL_CMD(encrypted-ad, &bt_encrypted_ad_cmds, "Manage advertiser with encrypted data",
+	SHELL_CMD(encrypted - ad, &bt_encrypted_ad_cmds, "Manage advertiser with encrypted data",
 		  cmd_default_handler),
 #endif /* CONFIG_BT_EAD */
 #if defined(CONFIG_BT_CONN)
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER)
-	SHELL_CMD_ARG(past-subscribe, NULL, "[conn] [skip <count>] "
+	SHELL_CMD_ARG(past - subscribe, NULL,
+		      "[conn] [skip <count>] "
 		      "[timeout <ms>] [aoa] [aod_1us] [aod_2us] [cte_only]",
 		      cmd_past_subscribe, 1, 7),
-	SHELL_CMD_ARG(past-unsubscribe, NULL, "[conn]",
-		      cmd_past_unsubscribe, 1, 1),
+	SHELL_CMD_ARG(past - unsubscribe, NULL, "[conn]", cmd_past_unsubscribe, 1, 1),
 #endif /* CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER */
 #if defined(CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER)
 #if defined(CONFIG_BT_PER_ADV_SYNC)
-	SHELL_CMD_ARG(per-adv-sync-transfer, NULL, "[<index>]",
-		      cmd_per_adv_sync_transfer, 1, 1),
+	SHELL_CMD_ARG(per - adv - sync - transfer, NULL, "[<index>]", cmd_per_adv_sync_transfer, 1,
+		      1),
 #endif /* CONFIG_BT_PER_ADV_SYNC */
 #if defined(CONFIG_BT_PER_ADV)
-	SHELL_CMD_ARG(per-adv-set-info-transfer, NULL, "",
-		      cmd_per_adv_set_info_transfer, 1, 0),
+	SHELL_CMD_ARG(per - adv - set - info - transfer, NULL, "", cmd_per_adv_set_info_transfer, 1,
+		      0),
 #endif /* CONFIG_BT_PER_ADV */
 #endif /* CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER */
 #if defined(CONFIG_BT_CENTRAL)
-	SHELL_CMD_ARG(connect, NULL, HELP_ADDR_LE EXT_ADV_SCAN_OPT,
-		      cmd_connect_le, 1, 3),
-	SHELL_CMD_ARG(connect-name, NULL, "<name filter>",
-		      cmd_connect_le_name, 2, 0),
+	SHELL_CMD_ARG(connect, NULL, HELP_ADDR_LE EXT_ADV_SCAN_OPT, cmd_connect_le, 1, 3),
+	SHELL_CMD_ARG(connect - name, NULL, "<name filter>", cmd_connect_le_name, 2, 0),
 #endif /* CONFIG_BT_CENTRAL */
 	SHELL_CMD_ARG(disconnect, NULL, HELP_ADDR_LE, cmd_disconnect, 1, 2),
 	SHELL_CMD_ARG(select, NULL, HELP_ADDR_LE, cmd_select, 3, 0),
 	SHELL_CMD_ARG(info, NULL, HELP_ADDR_LE, cmd_info, 1, 2),
-	SHELL_CMD_ARG(conn-update, NULL, "<min> <max> <latency> <timeout>",
-		      cmd_conn_update, 5, 0),
+	SHELL_CMD_ARG(conn - update, NULL, "<min> <max> <latency> <timeout>", cmd_conn_update, 5,
+		      0),
 #if defined(CONFIG_BT_USER_DATA_LEN_UPDATE)
-	SHELL_CMD_ARG(data-len-update, NULL, "<tx_max_len> [tx_max_time]",
+	SHELL_CMD_ARG(data - len - update, NULL, "<tx_max_len> [tx_max_time]",
 		      cmd_conn_data_len_update, 2, 1),
 #endif
 #if defined(CONFIG_BT_USER_PHY_UPDATE)
-	SHELL_CMD_ARG(phy-update, NULL, "<tx_phy> [rx_phy] [s2] [s8]",
-		      cmd_conn_phy_update, 2, 3),
+	SHELL_CMD_ARG(phy - update, NULL, "<tx_phy> [rx_phy] [s2] [s8]", cmd_conn_phy_update, 2, 3),
 #endif
 #if defined(CONFIG_BT_CENTRAL) || defined(CONFIG_BT_BROADCASTER)
-	SHELL_CMD_ARG(channel-map, NULL, "<channel-map: XXXXXXXXXX> (36-0)",
-		      cmd_chan_map, 2, 1),
+	SHELL_CMD_ARG(channel - map, NULL, "<channel-map: XXXXXXXXXX> (36-0)", cmd_chan_map, 2, 1),
 #endif /* CONFIG_BT_CENTRAL */
 	SHELL_CMD_ARG(oob, NULL, HELP_NONE, cmd_oob, 1, 0),
-	SHELL_CMD_ARG(clear, NULL, "[all] ["HELP_ADDR_LE"]", cmd_clear, 2, 1),
+	SHELL_CMD_ARG(clear, NULL, "[all] [" HELP_ADDR_LE "]", cmd_clear, 2, 1),
 #if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CLASSIC)
-	SHELL_CMD_ARG(security, NULL, "<security level BR/EDR: 0 - 3, "
-				      "LE: 1 - 4> [force-pair]",
+	SHELL_CMD_ARG(security, NULL,
+		      "<security level BR/EDR: 0 - 3, "
+		      "LE: 1 - 4> [force-pair]",
 		      cmd_security, 1, 2),
-	SHELL_CMD_ARG(bondable, NULL, HELP_ONOFF, cmd_bondable,
-		      2, 0),
+	SHELL_CMD_ARG(bondable, NULL, HELP_ONOFF, cmd_bondable, 2, 0),
 #if defined(CONFIG_BT_BONDABLE_PER_CONNECTION)
-	SHELL_CMD_ARG(conn-bondable, NULL, HELP_ONOFF, cmd_conn_bondable, 2, 0),
+	SHELL_CMD_ARG(conn - bondable, NULL, HELP_ONOFF, cmd_conn_bondable, 2, 0),
 #endif /* CONFIG_BT_BONDABLE_PER_CONNECTION */
 	SHELL_CMD_ARG(bonds, NULL, HELP_NONE, cmd_bonds, 1, 0),
 	SHELL_CMD_ARG(connections, NULL, HELP_NONE, cmd_connections, 1, 0),
@@ -5064,36 +4983,30 @@ SHELL_STATIC_SUBCMD_SET_CREATE(bt_cmds,
 		      "<method: all, input, display, yesno, confirm, "
 		      "oob, status, none>",
 		      cmd_auth, 2, 0),
-	SHELL_CMD_ARG(auth-cancel, NULL, HELP_NONE, cmd_auth_cancel, 1, 0),
-	SHELL_CMD_ARG(auth-passkey, NULL, "<passkey>", cmd_auth_passkey, 2, 0),
+	SHELL_CMD_ARG(auth - cancel, NULL, HELP_NONE, cmd_auth_cancel, 1, 0),
+	SHELL_CMD_ARG(auth - passkey, NULL, "<passkey>", cmd_auth_passkey, 2, 0),
 #if defined(CONFIG_BT_PASSKEY_KEYPRESS)
-	SHELL_CMD_ARG(auth-passkey-notify, NULL, "<type>",
-		      cmd_auth_passkey_notify, 2, 0),
+	SHELL_CMD_ARG(auth - passkey - notify, NULL, "<type>", cmd_auth_passkey_notify, 2, 0),
 #endif /* CONFIG_BT_PASSKEY_KEYPRESS */
-	SHELL_CMD_ARG(auth-passkey-confirm, NULL, HELP_NONE,
-		      cmd_auth_passkey_confirm, 1, 0),
-	SHELL_CMD_ARG(auth-pairing-confirm, NULL, HELP_NONE,
-		      cmd_auth_pairing_confirm, 1, 0),
+	SHELL_CMD_ARG(auth - passkey - confirm, NULL, HELP_NONE, cmd_auth_passkey_confirm, 1, 0),
+	SHELL_CMD_ARG(auth - pairing - confirm, NULL, HELP_NONE, cmd_auth_pairing_confirm, 1, 0),
 #if !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
-	SHELL_CMD_ARG(auth-oob-tk, NULL, "<tk>", cmd_auth_oob_tk, 2, 0),
+	SHELL_CMD_ARG(auth - oob - tk, NULL, "<tk>", cmd_auth_oob_tk, 2, 0),
 #endif /* !defined(CONFIG_BT_SMP_SC_PAIR_ONLY) */
-	SHELL_CMD_ARG(oob-remote, NULL,
-		      HELP_ADDR_LE" <oob rand> <oob confirm>",
-		      cmd_oob_remote, 3, 2),
-	SHELL_CMD_ARG(oob-clear, NULL, HELP_NONE, cmd_oob_clear, 1, 0),
+	SHELL_CMD_ARG(oob - remote, NULL, HELP_ADDR_LE " <oob rand> <oob confirm>", cmd_oob_remote,
+		      3, 2),
+	SHELL_CMD_ARG(oob - clear, NULL, HELP_NONE, cmd_oob_clear, 1, 0),
 #if defined(CONFIG_BT_FILTER_ACCEPT_LIST)
-	SHELL_CMD_ARG(fal-add, NULL, HELP_ADDR_LE, cmd_fal_add, 3, 0),
-	SHELL_CMD_ARG(fal-rem, NULL, HELP_ADDR_LE, cmd_fal_rem, 3, 0),
-	SHELL_CMD_ARG(fal-clear, NULL, HELP_NONE, cmd_fal_clear, 1, 0),
+	SHELL_CMD_ARG(fal - add, NULL, HELP_ADDR_LE, cmd_fal_add, 3, 0),
+	SHELL_CMD_ARG(fal - rem, NULL, HELP_ADDR_LE, cmd_fal_rem, 3, 0),
+	SHELL_CMD_ARG(fal - clear, NULL, HELP_NONE, cmd_fal_clear, 1, 0),
 
 #if defined(CONFIG_BT_CENTRAL)
-	SHELL_CMD_ARG(fal-connect, NULL, HELP_ONOFF EXT_ADV_SCAN_OPT,
-		      cmd_fal_connect, 2, 3),
+	SHELL_CMD_ARG(fal - connect, NULL, HELP_ONOFF EXT_ADV_SCAN_OPT, cmd_fal_connect, 2, 3),
 #endif /* CONFIG_BT_CENTRAL */
 #endif /* defined(CONFIG_BT_FILTER_ACCEPT_LIST) */
 #if defined(CONFIG_BT_FIXED_PASSKEY)
-	SHELL_CMD_ARG(fixed-passkey, NULL, "[passkey]", cmd_fixed_passkey,
-		      1, 1),
+	SHELL_CMD_ARG(fixed - passkey, NULL, "[passkey]", cmd_fixed_passkey, 1, 1),
 #endif
 #endif /* CONFIG_BT_SMP || CONFIG_BT_CLASSIC) */
 #endif /* CONFIG_BT_CONN */
@@ -5102,28 +5015,22 @@ SHELL_STATIC_SUBCMD_SET_CREATE(bt_cmds,
 #endif /* CONFIG_BT_HCI_MESH_EXT */
 
 #if defined(CONFIG_BT_LL_SW_SPLIT)
-	SHELL_CMD(ll-addr, NULL, "<random|public>", cmd_ll_addr_read),
+	SHELL_CMD(ll - addr, NULL, "<random|public>", cmd_ll_addr_read),
 #if defined(CONFIG_BT_CTLR_ADV_EXT)
 #if defined(CONFIG_BT_BROADCASTER)
-	SHELL_CMD_ARG(advx, NULL,
-		      "<on hdcd ldcd off> [coded] [anon] [txp] [ad]",
-		      cmd_advx, 2, 4),
+	SHELL_CMD_ARG(advx, NULL, "<on hdcd ldcd off> [coded] [anon] [txp] [ad]", cmd_advx, 2, 4),
 #endif /* CONFIG_BT_BROADCASTER */
 #if defined(CONFIG_BT_OBSERVER)
-	SHELL_CMD_ARG(scanx, NULL, "<on passive off> [coded]", cmd_scanx,
-		      2, 1),
+	SHELL_CMD_ARG(scanx, NULL, "<on passive off> [coded]", cmd_scanx, 2, 1),
 #endif /* CONFIG_BT_OBSERVER */
 #endif /* CONFIG_BT_CTLR_ADV_EXT */
 #if defined(CONFIG_BT_CTLR_DTM)
-	SHELL_CMD_ARG(test_tx, NULL, "<chan> <len> <type> <phy>", cmd_test_tx,
-		      5, 0),
-	SHELL_CMD_ARG(test_rx, NULL, "<chan> <phy> <mod_idx>", cmd_test_rx,
-		      4, 0),
+	SHELL_CMD_ARG(test_tx, NULL, "<chan> <len> <type> <phy>", cmd_test_tx, 5, 0),
+	SHELL_CMD_ARG(test_rx, NULL, "<chan> <phy> <mod_idx>", cmd_test_rx, 4, 0),
 	SHELL_CMD_ARG(test_end, NULL, HELP_NONE, cmd_test_end, 1, 0),
 #endif /* CONFIG_BT_CTLR_DTM */
 #endif /* CONFIG_BT_LL_SW_SPLIT */
 
-	SHELL_SUBCMD_SET_END
-);
+	SHELL_SUBCMD_SET_END);
 
 SHELL_CMD_REGISTER(bt, &bt_cmds, "Bluetooth shell commands", cmd_default_handler);
diff --git a/subsys/bluetooth/host/shell/bt_shell_private.c b/subsys/bluetooth/host/shell/bt_shell_private.c
index a01b968a27a..358196d4a39 100644
--- a/subsys/bluetooth/host/shell/bt_shell_private.c
+++ b/subsys/bluetooth/host/shell/bt_shell_private.c
@@ -23,10 +23,10 @@ static void wall_vfprintf(enum shell_vt100_color color, const char *fmt, va_list
 	for (int i = 0; i < count; i++) {
 		va_list args_copy;
 
-		va_copy(args_copy, args);   /* Create a copy of 'args' to safely reuse */
+		va_copy(args_copy, args); /* Create a copy of 'args' to safely reuse */
 		sh = shell_backend_get(i);
 		shell_vfprintf(sh, color, fmt, args_copy);
-		va_end(args_copy);          /* Clean up to prevent resource leaks */
+		va_end(args_copy); /* Clean up to prevent resource leaks */
 	}
 }
 
@@ -42,8 +42,7 @@ void bt_shell_hexdump(const uint8_t *data, size_t len)
 	}
 }
 
-void bt_shell_fprintf(enum shell_vt100_color color,
-		      const char *fmt, ...)
+void bt_shell_fprintf(enum shell_vt100_color color, const char *fmt, ...)
 {
 	va_list args;
 
diff --git a/subsys/bluetooth/host/shell/bt_shell_private.h b/subsys/bluetooth/host/shell/bt_shell_private.h
index 69460797686..2214c75b245 100644
--- a/subsys/bluetooth/host/shell/bt_shell_private.h
+++ b/subsys/bluetooth/host/shell/bt_shell_private.h
@@ -20,8 +20,7 @@
  * @param[in] fmt   Format string.
  * @param[in] ...   List of parameters to print.
  */
-__printf_like(2, 3) void bt_shell_fprintf(enum shell_vt100_color color,
-					  const char *fmt, ...);
+__printf_like(2, 3) void bt_shell_fprintf(enum shell_vt100_color color, const char *fmt, ...);
 
 /**
  * @brief printf-like function which sends formatted data stream to the shell.
@@ -54,8 +53,7 @@ void bt_shell_hexdump(const uint8_t *data, size_t len);
  * @param[in] _ft Format string.
  * @param[in] ... List of parameters to print.
  */
-#define bt_shell_info(_ft, ...) \
-	bt_shell_fprintf_info(_ft "\n", ##__VA_ARGS__)
+#define bt_shell_info(_ft, ...) bt_shell_fprintf_info(_ft "\n", ##__VA_ARGS__)
 
 /**
  * @brief Print normal message to the shell.
@@ -64,8 +62,7 @@ void bt_shell_hexdump(const uint8_t *data, size_t len);
  * @param[in] _ft Format string.
  * @param[in] ... List of parameters to print.
  */
-#define bt_shell_print(_ft, ...) \
-	bt_shell_fprintf_print(_ft "\n", ##__VA_ARGS__)
+#define bt_shell_print(_ft, ...) bt_shell_fprintf_print(_ft "\n", ##__VA_ARGS__)
 
 /**
  * @brief Print warning message to the shell.
@@ -74,8 +71,7 @@ void bt_shell_hexdump(const uint8_t *data, size_t len);
  * @param[in] _ft Format string.
  * @param[in] ... List of parameters to print.
  */
-#define bt_shell_warn(_ft, ...) \
-	bt_shell_fprintf_warn(_ft "\n", ##__VA_ARGS__)
+#define bt_shell_warn(_ft, ...) bt_shell_fprintf_warn(_ft "\n", ##__VA_ARGS__)
 
 /**
  * @brief Print error message to the shell.
@@ -84,7 +80,6 @@ void bt_shell_hexdump(const uint8_t *data, size_t len);
  * @param[in] _ft Format string.
  * @param[in] ... List of parameters to print.
  */
-#define bt_shell_error(_ft, ...) \
-	bt_shell_fprintf_error(_ft "\n", ##__VA_ARGS__)
+#define bt_shell_error(_ft, ...) bt_shell_fprintf_error(_ft "\n", ##__VA_ARGS__)
 
 #endif /* __BT_SHELL_PRIVATE_H */
diff --git a/subsys/bluetooth/host/shell/cs.c b/subsys/bluetooth/host/shell/cs.c
index 2597063cbed..eee867f3853 100644
--- a/subsys/bluetooth/host/shell/cs.c
+++ b/subsys/bluetooth/host/shell/cs.c
@@ -141,10 +141,9 @@ static bool process_step_data(struct bt_le_cs_subevent_step *step, void *user_da
 {
 	bt_shell_print("Subevent results contained step data: ");
 	bt_shell_print("- Step mode %d\n"
-		"- Step channel %d\n"
-		"- Step data hexdump:",
-		step->mode,
-		step->channel);
+		       "- Step channel %d\n"
+		       "- Step data hexdump:",
+		       step->mode, step->channel);
 	bt_shell_hexdump(step->data, step->data_len);
 
 	return true;
@@ -154,24 +153,20 @@ static void cs_test_subevent_data_cb(struct bt_conn_le_cs_subevent_result *resul
 {
 	bt_shell_print("Received subevent results.");
 	bt_shell_print("Subevent Header:\n"
-		"- Procedure Counter: %d\n"
-		"- Frequency Compensation: 0x%04x\n"
-		"- Reference Power Level: %d\n"
-		"- Procedure Done Status: 0x%02x\n"
-		"- Subevent Done Status: 0x%02x\n"
-		"- Procedure Abort Reason: 0x%02x\n"
-		"- Subevent Abort Reason: 0x%02x\n"
-		"- Number of Antenna Paths: %d\n"
-		"- Number of Steps Reported: %d",
-		result->header.procedure_counter,
-		result->header.frequency_compensation,
-		result->header.reference_power_level,
-		result->header.procedure_done_status,
-		result->header.subevent_done_status,
-		result->header.procedure_abort_reason,
-		result->header.subevent_abort_reason,
-		result->header.num_antenna_paths,
-		result->header.num_steps_reported);
+		       "- Procedure Counter: %d\n"
+		       "- Frequency Compensation: 0x%04x\n"
+		       "- Reference Power Level: %d\n"
+		       "- Procedure Done Status: 0x%02x\n"
+		       "- Subevent Done Status: 0x%02x\n"
+		       "- Procedure Abort Reason: 0x%02x\n"
+		       "- Subevent Abort Reason: 0x%02x\n"
+		       "- Number of Antenna Paths: %d\n"
+		       "- Number of Steps Reported: %d",
+		       result->header.procedure_counter, result->header.frequency_compensation,
+		       result->header.reference_power_level, result->header.procedure_done_status,
+		       result->header.subevent_done_status, result->header.procedure_abort_reason,
+		       result->header.subevent_abort_reason, result->header.num_antenna_paths,
+		       result->header.num_steps_reported);
 
 	if (result->step_data_buf) {
 		bt_le_cs_step_data_parse(result->step_data_buf, process_step_data, NULL);
diff --git a/subsys/bluetooth/host/shell/gatt.c b/subsys/bluetooth/host/shell/gatt.c
index 080361cc29b..b324dbb2ac0 100644
--- a/subsys/bluetooth/host/shell/gatt.c
+++ b/subsys/bluetooth/host/shell/gatt.c
@@ -63,8 +63,7 @@ static void update_write_stats(uint16_t len)
 		cycle_stamp = k_cycle_get_32();
 	} else {
 		write_stats.len += len;
-		write_stats.rate = ((uint64_t)write_stats.len << 3) *
-			1000000000U / delta;
+		write_stats.rate = ((uint64_t)write_stats.len << 3) * 1000000000U / delta;
 	}
 }
 
@@ -76,8 +75,8 @@ static void update_write_stats(uint16_t len)
 
 static void print_write_stats(void)
 {
-	bt_shell_print("Write #%u: %u bytes (%u bps)",
-		       write_stats.count, write_stats.total, write_stats.rate);
+	bt_shell_print("Write #%u: %u bytes (%u bps)", write_stats.count, write_stats.total,
+		       write_stats.rate);
 }
 #endif /* CONFIG_BT_GATT_CLIENT || CONFIG_BT_GATT_DYNAMIC_DB */
 
@@ -92,8 +91,7 @@ static void reset_write_stats(void)
  */
 static struct bt_gatt_exchange_params exchange_params;
 
-static void exchange_func(struct bt_conn *conn, uint8_t err,
-			  struct bt_gatt_exchange_params *params)
+static void exchange_func(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params)
 {
 	bt_shell_print("Exchange %s", err == 0U ? "successful" : "failed");
 
@@ -102,8 +100,7 @@ static void exchange_func(struct bt_conn *conn, uint8_t err,
 	(void)memset(params, 0, sizeof(*params));
 }
 
-static int cmd_exchange_mtu(const struct shell *sh,
-			    size_t argc, char *argv[])
+static int cmd_exchange_mtu(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 
@@ -178,8 +175,7 @@ static void print_chrc_props(uint8_t properties)
 	bt_shell_print("");
 }
 
-static uint8_t discover_func(struct bt_conn *conn,
-			     const struct bt_gatt_attr *attr,
+static uint8_t discover_func(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 			     struct bt_gatt_discover_params *params)
 {
 	struct bt_gatt_service_val *gatt_service;
@@ -198,14 +194,13 @@ static uint8_t discover_func(struct bt_conn *conn,
 	case BT_GATT_DISCOVER_PRIMARY:
 		gatt_service = attr->user_data;
 		bt_uuid_to_str(gatt_service->uuid, str, sizeof(str));
-		bt_shell_print("Service %s found: start handle %x, end_handle %x",
-			       str, attr->handle, gatt_service->end_handle);
+		bt_shell_print("Service %s found: start handle %x, end_handle %x", str,
+			       attr->handle, gatt_service->end_handle);
 		break;
 	case BT_GATT_DISCOVER_CHARACTERISTIC:
 		gatt_chrc = attr->user_data;
 		bt_uuid_to_str(gatt_chrc->uuid, str, sizeof(str));
-		bt_shell_print("Characteristic %s found: handle %x",
-			       str, attr->handle);
+		bt_shell_print("Characteristic %s found: handle %x", str, attr->handle);
 		print_chrc_props(gatt_chrc->properties);
 		break;
 	case BT_GATT_DISCOVER_INCLUDE:
@@ -283,8 +278,7 @@ static int cmd_discover(const struct shell *sh, size_t argc, char *argv[])
 
 static struct bt_gatt_read_params read_params;
 
-static uint8_t read_func(struct bt_conn *conn, uint8_t err,
-			 struct bt_gatt_read_params *params,
+static uint8_t read_func(struct bt_conn *conn, uint8_t err, struct bt_gatt_read_params *params,
 			 const void *data, uint16_t length)
 {
 	bt_shell_print("Read complete: err 0x%02x length %u", err, length);
@@ -419,8 +413,7 @@ static int cmd_read_uuid(const struct shell *sh, size_t argc, char *argv[])
 static struct bt_gatt_write_params write_params;
 static uint8_t gatt_write_buf[BT_ATT_MAX_ATTRIBUTE_LEN];
 
-static void write_func(struct bt_conn *conn, uint8_t err,
-		       struct bt_gatt_write_params *params)
+static void write_func(struct bt_conn *conn, uint8_t err, struct bt_gatt_write_params *params)
 {
 	bt_shell_print("Write complete: err 0x%02x", err);
 
@@ -445,8 +438,8 @@ static int cmd_write(const struct shell *sh, size_t argc, char *argv[])
 	handle = strtoul(argv[1], NULL, 16);
 	offset = strtoul(argv[2], NULL, 16);
 
-	write_params.length = hex2bin(argv[3], strlen(argv[3]),
-				      gatt_write_buf, sizeof(gatt_write_buf));
+	write_params.length =
+		hex2bin(argv[3], strlen(argv[3]), gatt_write_buf, sizeof(gatt_write_buf));
 	if (write_params.length == 0) {
 		shell_error(sh, "No data set");
 		return -ENOEXEC;
@@ -478,8 +471,7 @@ static void write_without_rsp_cb(struct bt_conn *conn, void *user_data)
 	print_write_stats();
 }
 
-static int cmd_write_without_rsp(const struct shell *sh,
-				 size_t argc, char *argv[])
+static int cmd_write_without_rsp(const struct shell *sh, size_t argc, char *argv[])
 {
 	uint16_t handle;
 	uint16_t repeat;
@@ -527,10 +519,8 @@ static int cmd_write_without_rsp(const struct shell *sh,
 	}
 
 	while (repeat--) {
-		err = bt_gatt_write_without_response_cb(default_conn, handle,
-							gatt_write_buf, len,
-							sign, func,
-							UINT_TO_POINTER(len));
+		err = bt_gatt_write_without_response_cb(default_conn, handle, gatt_write_buf, len,
+							sign, func, UINT_TO_POINTER(len));
 		if (err) {
 			break;
 		}
@@ -544,9 +534,8 @@ static int cmd_write_without_rsp(const struct shell *sh,
 
 static struct bt_gatt_subscribe_params subscribe_params;
 
-static uint8_t notify_func(struct bt_conn *conn,
-			struct bt_gatt_subscribe_params *params,
-			const void *data, uint16_t length)
+static uint8_t notify_func(struct bt_conn *conn, struct bt_gatt_subscribe_params *params,
+			   const void *data, uint16_t length)
 {
 	if (!data) {
 		bt_shell_print("Unsubscribed");
@@ -554,8 +543,7 @@ static uint8_t notify_func(struct bt_conn *conn,
 		return BT_GATT_ITER_STOP;
 	}
 
-	bt_shell_print("Notification: value_handle %u, length %u",
-		       params->value_handle, length);
+	bt_shell_print("Notification: value_handle %u, length %u", params->value_handle, length);
 	bt_shell_hexdump(data, length);
 
 	return BT_GATT_ITER_CONTINUE;
@@ -606,8 +594,7 @@ static int cmd_subscribe(const struct shell *sh, size_t argc, char *argv[])
 	return err;
 }
 
-static int cmd_resubscribe(const struct shell *sh, size_t argc,
-				char *argv[])
+static int cmd_resubscribe(const struct shell *sh, size_t argc, char *argv[])
 {
 	bt_addr_le_t addr;
 	int err;
@@ -645,8 +632,7 @@ static int cmd_resubscribe(const struct shell *sh, size_t argc,
 	return err;
 }
 
-static int cmd_unsubscribe(const struct shell *sh,
-			   size_t argc, char *argv[])
+static int cmd_unsubscribe(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 
@@ -678,8 +664,7 @@ static struct db_stats {
 	uint16_t ccc_count;
 } stats;
 
-static uint8_t print_attr(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t print_attr(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	const struct shell *sh = user_data;
 	char str[BT_UUID_STR_LEN];
@@ -695,14 +680,12 @@ static uint8_t print_attr(const struct bt_gatt_attr *attr, uint16_t handle,
 		stats.chrc_count++;
 	}
 
-	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
-	    attr->write == bt_gatt_attr_write_ccc) {
+	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) && attr->write == bt_gatt_attr_write_ccc) {
 		stats.ccc_count++;
 	}
 
 	bt_uuid_to_str(attr->uuid, str, sizeof(str));
-	shell_print(sh, "attr %p handle 0x%04x uuid %s perm 0x%02x",
-		    attr, handle, str, attr->perm);
+	shell_print(sh, "attr %p handle 0x%04x uuid %s perm 0x%02x", attr, handle, str, attr->perm);
 
 	return BT_GATT_ITER_CONTINUE;
 }
@@ -724,9 +707,8 @@ static int cmd_show_db(const struct shell *sh, size_t argc, char *argv[])
 			num_matches = strtoul(argv[2], NULL, 10);
 		}
 
-		bt_gatt_foreach_attr_type(0x0001, 0xffff, &uuid16.uuid, NULL,
-					  num_matches, print_attr,
-					  (void *)sh);
+		bt_gatt_foreach_attr_type(0x0001, 0xffff, &uuid16.uuid, NULL, num_matches,
+					  print_attr, (void *)sh);
 		return 0;
 	}
 
@@ -743,8 +725,8 @@ static int cmd_show_db(const struct shell *sh, size_t argc, char *argv[])
 	total_len += stats.ccc_count * sizeof(struct _bt_gatt_ccc);
 
 	shell_print(sh, "=================================================");
-	shell_print(sh, "Total: %u services %u attributes (%zu bytes)",
-		    stats.svc_count, stats.attr_count, total_len);
+	shell_print(sh, "Total: %u services %u attributes (%zu bytes)", stats.svc_count,
+		    stats.attr_count, total_len);
 
 	return 0;
 }
@@ -752,25 +734,25 @@ static int cmd_show_db(const struct shell *sh, size_t argc, char *argv[])
 #if defined(CONFIG_BT_GATT_DYNAMIC_DB)
 /* Custom Service Variables */
 
-static const struct bt_uuid_128 vnd_uuid = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef0));
+static const struct bt_uuid_128 vnd_uuid =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef0));
 
-static const struct bt_uuid_128 vnd_auth_uuid = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef2));
+static const struct bt_uuid_128 vnd_auth_uuid =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef2));
 
-static const struct bt_uuid_128 vnd_long_uuid1 = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef3));
+static const struct bt_uuid_128 vnd_long_uuid1 =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef3));
 
-static const struct bt_uuid_128 vnd_long_uuid2 = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x12340, 0x5678cefaadde));
+static const struct bt_uuid_128 vnd_long_uuid2 =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x12340, 0x5678cefaadde));
 
-static uint8_t vnd_value[] = { 'V', 'e', 'n', 'd', 'o', 'r' };
+static uint8_t vnd_value[] = {'V', 'e', 'n', 'd', 'o', 'r'};
 
-static const struct bt_uuid_128 vnd1_uuid = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x12340, 0x56789abcdef4));
+static const struct bt_uuid_128 vnd1_uuid =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x12340, 0x56789abcdef4));
 
-static const struct bt_uuid_128 vnd1_echo_uuid = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x12340, 0x56789abcdef5));
+static const struct bt_uuid_128 vnd1_echo_uuid =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x12340, 0x56789abcdef5));
 
 static uint8_t echo_enabled;
 
@@ -779,9 +761,8 @@ static void vnd1_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value
 	echo_enabled = (value == BT_GATT_CCC_NOTIFY) ? 1 : 0;
 }
 
-static ssize_t write_vnd1(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			  const void *buf, uint16_t len, uint16_t offset,
-			  uint8_t flags)
+static ssize_t write_vnd1(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
+			  uint16_t len, uint16_t offset, uint8_t flags)
 {
 	if (echo_enabled) {
 		bt_shell_print("Echo attr len %u", len);
@@ -791,18 +772,16 @@ static ssize_t write_vnd1(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 	return len;
 }
 
-static ssize_t read_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			void *buf, uint16_t len, uint16_t offset)
+static ssize_t read_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+			uint16_t len, uint16_t offset)
 {
 	const char *value = attr->user_data;
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
-				 strlen(value));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, value, strlen(value));
 }
 
-static ssize_t write_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			 const void *buf, uint16_t len, uint16_t offset,
-			 uint8_t flags)
+static ssize_t write_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
+			 uint16_t len, uint16_t offset, uint8_t flags)
 {
 	uint8_t *value = attr->user_data;
 
@@ -816,22 +795,19 @@ static ssize_t write_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 }
 
 #define MAX_DATA 30
-static uint8_t vnd_long_value1[MAX_DATA] = { 'V', 'e', 'n', 'd', 'o', 'r' };
-static uint8_t vnd_long_value2[MAX_DATA] = { 'S', 't', 'r', 'i', 'n', 'g' };
+static uint8_t vnd_long_value1[MAX_DATA] = {'V', 'e', 'n', 'd', 'o', 'r'};
+static uint8_t vnd_long_value2[MAX_DATA] = {'S', 't', 'r', 'i', 'n', 'g'};
 
-static ssize_t read_long_vnd(struct bt_conn *conn,
-			     const struct bt_gatt_attr *attr, void *buf,
+static ssize_t read_long_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
 			     uint16_t len, uint16_t offset)
 {
 	uint8_t *value = attr->user_data;
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
-				 sizeof(vnd_long_value1));
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, value, sizeof(vnd_long_value1));
 }
 
-static ssize_t write_long_vnd(struct bt_conn *conn,
-			      const struct bt_gatt_attr *attr, const void *buf,
-			      uint16_t len, uint16_t offset, uint8_t flags)
+static ssize_t write_long_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr,
+			      const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
 {
 	uint8_t *value = attr->user_data;
 
@@ -853,25 +829,19 @@ static struct bt_gatt_attr vnd_attrs[] = {
 	/* Vendor Primary Service Declaration */
 	BT_GATT_PRIMARY_SERVICE(&vnd_uuid),
 
-	BT_GATT_CHARACTERISTIC(&vnd_auth_uuid.uuid,
-			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
-			       BT_GATT_PERM_READ_AUTHEN |
-			       BT_GATT_PERM_WRITE_AUTHEN,
-			       read_vnd, write_vnd, vnd_value),
-
-	BT_GATT_CHARACTERISTIC(&vnd_long_uuid1.uuid, BT_GATT_CHRC_READ |
-			       BT_GATT_CHRC_WRITE | BT_GATT_CHRC_EXT_PROP,
-			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE |
-			       BT_GATT_PERM_PREPARE_WRITE,
-			       read_long_vnd, write_long_vnd,
-			       &vnd_long_value1),
-
-	BT_GATT_CHARACTERISTIC(&vnd_long_uuid2.uuid, BT_GATT_CHRC_READ |
-			       BT_GATT_CHRC_WRITE | BT_GATT_CHRC_EXT_PROP,
-			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE |
-			       BT_GATT_PERM_PREPARE_WRITE,
-			       read_long_vnd, write_long_vnd,
-			       &vnd_long_value2),
+	BT_GATT_CHARACTERISTIC(&vnd_auth_uuid.uuid, BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
+			       BT_GATT_PERM_READ_AUTHEN | BT_GATT_PERM_WRITE_AUTHEN, read_vnd,
+			       write_vnd, vnd_value),
+
+	BT_GATT_CHARACTERISTIC(&vnd_long_uuid1.uuid,
+			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE | BT_GATT_CHRC_EXT_PROP,
+			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE | BT_GATT_PERM_PREPARE_WRITE,
+			       read_long_vnd, write_long_vnd, &vnd_long_value1),
+
+	BT_GATT_CHARACTERISTIC(&vnd_long_uuid2.uuid,
+			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE | BT_GATT_CHRC_EXT_PROP,
+			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE | BT_GATT_PERM_PREPARE_WRITE,
+			       read_long_vnd, write_long_vnd, &vnd_long_value2),
 };
 
 static struct bt_gatt_service vnd_svc = BT_GATT_SERVICE(vnd_attrs);
@@ -881,17 +851,14 @@ static struct bt_gatt_attr vnd1_attrs[] = {
 	BT_GATT_PRIMARY_SERVICE(&vnd1_uuid),
 
 	BT_GATT_CHARACTERISTIC(&vnd1_echo_uuid.uuid,
-			       BT_GATT_CHRC_WRITE_WITHOUT_RESP |
-			       BT_GATT_CHRC_NOTIFY,
+			       BT_GATT_CHRC_WRITE_WITHOUT_RESP | BT_GATT_CHRC_NOTIFY,
 			       BT_GATT_PERM_WRITE, NULL, write_vnd1, NULL),
-	BT_GATT_CCC(vnd1_ccc_cfg_changed,
-		    BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
+	BT_GATT_CCC(vnd1_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
 };
 
 static struct bt_gatt_service vnd1_svc = BT_GATT_SERVICE(vnd1_attrs);
 
-static int cmd_register_test_svc(const struct shell *sh,
-				  size_t argc, char *argv[])
+static int cmd_register_test_svc(const struct shell *sh, size_t argc, char *argv[])
 {
 	char str[BT_UUID_STR_LEN];
 	int err;
@@ -915,8 +882,7 @@ static int cmd_register_test_svc(const struct shell *sh,
 	return 0;
 }
 
-static int cmd_unregister_test_svc(const struct shell *sh,
-				    size_t argc, char *argv[])
+static int cmd_unregister_test_svc(const struct shell *sh, size_t argc, char *argv[])
 {
 	char str[BT_UUID_STR_LEN];
 	int err;
@@ -940,8 +906,7 @@ static int cmd_unregister_test_svc(const struct shell *sh,
 	return 0;
 }
 
-static uint8_t found_attr(const struct bt_gatt_attr *attr, uint16_t handle,
-			  void *user_data)
+static uint8_t found_attr(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	const struct bt_gatt_attr **found = user_data;
 
@@ -1045,8 +1010,8 @@ static int cmd_notify_mult(const struct shell *sh, size_t argc, char *argv[])
 	}
 
 	if (!IN_RANGE(cnt, min_cnt, max_cnt)) {
-		shell_error(sh, "Invalid count value %lu (range %zu to %zu)",
-			    cnt, min_cnt, max_cnt);
+		shell_error(sh, "Invalid count value %lu (range %zu to %zu)", cnt, min_cnt,
+			    max_cnt);
 
 		return -ENOEXEC;
 	}
@@ -1084,29 +1049,26 @@ static int cmd_notify_mult(const struct shell *sh, size_t argc, char *argv[])
 }
 #endif /* CONFIG_BT_GATT_NOTIFY_MULTIPLE */
 
-static const struct bt_uuid_128 met_svc_uuid = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcde01));
-static const struct bt_uuid_128 met_char_uuid = BT_UUID_INIT_128(
-	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcde02));
+static const struct bt_uuid_128 met_svc_uuid =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcde01));
+static const struct bt_uuid_128 met_char_uuid =
+	BT_UUID_INIT_128(BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcde02));
 
-static uint8_t met_char_value[BT_ATT_MAX_ATTRIBUTE_LEN] = {
-	'M', 'e', 't', 'r', 'i', 'c', 's' };
+static uint8_t met_char_value[BT_ATT_MAX_ATTRIBUTE_LEN] = {'M', 'e', 't', 'r', 'i', 'c', 's'};
 
-static ssize_t read_met(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			void *buf, uint16_t len, uint16_t offset)
+static ssize_t read_met(struct bt_conn *conn, const struct bt_gatt_attr *attr, void *buf,
+			uint16_t len, uint16_t offset)
 {
 	const char *value = attr->user_data;
 	uint16_t value_len;
 
 	value_len = MIN(strlen(value), BT_ATT_MAX_ATTRIBUTE_LEN);
 
-	return bt_gatt_attr_read(conn, attr, buf, len, offset, value,
-				 value_len);
+	return bt_gatt_attr_read(conn, attr, buf, len, offset, value, value_len);
 }
 
-static ssize_t write_met(struct bt_conn *conn, const struct bt_gatt_attr *attr,
-			 const void *buf, uint16_t len, uint16_t offset,
-			 uint8_t flags)
+static ssize_t write_met(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
+			 uint16_t len, uint16_t offset, uint8_t flags)
 {
 	uint8_t *value = attr->user_data;
 
@@ -1124,10 +1086,9 @@ static ssize_t write_met(struct bt_conn *conn, const struct bt_gatt_attr *attr,
 static struct bt_gatt_attr met_attrs[] = {
 	BT_GATT_PRIMARY_SERVICE(&met_svc_uuid),
 
-	BT_GATT_CHARACTERISTIC(&met_char_uuid.uuid,
-			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
-			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE,
-			       read_met, write_met, met_char_value),
+	BT_GATT_CHARACTERISTIC(&met_char_uuid.uuid, BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE,
+			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE, read_met, write_met,
+			       met_char_value),
 };
 
 static struct bt_gatt_service met_svc = BT_GATT_SERVICE(met_attrs);
@@ -1161,8 +1122,7 @@ static int cmd_metrics(const struct shell *sh, size_t argc, char *argv[])
 }
 #endif /* CONFIG_BT_GATT_DYNAMIC_DB */
 
-static uint8_t get_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-		      void *user_data)
+static uint8_t get_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct shell *sh = user_data;
 	uint8_t buf[256];
@@ -1170,8 +1130,7 @@ static uint8_t get_cb(const struct bt_gatt_attr *attr, uint16_t handle,
 	char str[BT_UUID_STR_LEN];
 
 	bt_uuid_to_str(attr->uuid, str, sizeof(str));
-	shell_print(sh, "attr %p uuid %s perm 0x%02x", attr, str,
-		    attr->perm);
+	shell_print(sh, "attr %p uuid %s perm 0x%02x", attr, str, attr->perm);
 
 	if (!attr->read) {
 		return BT_GATT_ITER_CONTINUE;
@@ -1211,8 +1170,7 @@ struct set_data {
 	int err;
 };
 
-static uint8_t set_cb(const struct bt_gatt_attr *attr, uint16_t handle,
-		      void *user_data)
+static uint8_t set_cb(const struct bt_gatt_attr *attr, uint16_t handle, void *user_data)
 {
 	struct set_data *data = user_data;
 	uint8_t buf[256];
@@ -1276,63 +1234,57 @@ int cmd_att_mtu(const struct shell *sh, size_t argc, char *argv[])
 	return 0;
 }
 
-#define HELP_NONE "[none]"
+#define HELP_NONE    "[none]"
 #define HELP_ADDR_LE "<address: XX:XX:XX:XX:XX:XX> <type: (public|random)>"
 
-SHELL_STATIC_SUBCMD_SET_CREATE(gatt_cmds,
+SHELL_STATIC_SUBCMD_SET_CREATE(
+	gatt_cmds,
 #if defined(CONFIG_BT_GATT_CLIENT)
-	SHELL_CMD_ARG(discover, NULL,
-		      "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
-	SHELL_CMD_ARG(discover-characteristic, NULL,
-		      "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
-	SHELL_CMD_ARG(discover-descriptor, NULL,
-		      "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
-	SHELL_CMD_ARG(discover-include, NULL,
-		      "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
-	SHELL_CMD_ARG(discover-primary, NULL,
-		      "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
-	SHELL_CMD_ARG(discover-secondary, NULL,
-		      "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
-	SHELL_CMD_ARG(exchange-mtu, NULL, HELP_NONE, cmd_exchange_mtu, 1, 0),
+	SHELL_CMD_ARG(discover, NULL, "[UUID] [start handle] [end handle]", cmd_discover, 1, 3),
+	SHELL_CMD_ARG(discover - characteristic, NULL, "[UUID] [start handle] [end handle]",
+		      cmd_discover, 1, 3),
+	SHELL_CMD_ARG(discover - descriptor, NULL, "[UUID] [start handle] [end handle]",
+		      cmd_discover, 1, 3),
+	SHELL_CMD_ARG(discover - include, NULL, "[UUID] [start handle] [end handle]", cmd_discover,
+		      1, 3),
+	SHELL_CMD_ARG(discover - primary, NULL, "[UUID] [start handle] [end handle]", cmd_discover,
+		      1, 3),
+	SHELL_CMD_ARG(discover - secondary, NULL, "[UUID] [start handle] [end handle]",
+		      cmd_discover, 1, 3),
+	SHELL_CMD_ARG(exchange - mtu, NULL, HELP_NONE, cmd_exchange_mtu, 1, 0),
 	SHELL_CMD_ARG(read, NULL, "<handle> [offset]", cmd_read, 2, 1),
-	SHELL_CMD_ARG(read-uuid, NULL, "<UUID> [start handle] [end handle]",
-		      cmd_read_uuid, 2, 2),
-	SHELL_CMD_ARG(read-multiple, NULL, "<handle 1> <handle 2> ...",
-		      cmd_mread, 2, -1),
-	SHELL_CMD_ARG(signed-write, NULL, "<handle> <data> [length] [repeat]",
+	SHELL_CMD_ARG(read - uuid, NULL, "<UUID> [start handle] [end handle]", cmd_read_uuid, 2, 2),
+	SHELL_CMD_ARG(read - multiple, NULL, "<handle 1> <handle 2> ...", cmd_mread, 2, -1),
+	SHELL_CMD_ARG(signed - write, NULL, "<handle> <data> [length] [repeat]",
 		      cmd_write_without_rsp, 3, 2),
-	SHELL_CMD_ARG(subscribe, NULL, "<CCC handle> <value handle> [ind]",
-		      cmd_subscribe, 3, 1),
-	SHELL_CMD_ARG(resubscribe, NULL, HELP_ADDR_LE" <CCC handle> "
-		      "<value handle> [ind]", cmd_resubscribe, 5, 1),
+	SHELL_CMD_ARG(subscribe, NULL, "<CCC handle> <value handle> [ind]", cmd_subscribe, 3, 1),
+	SHELL_CMD_ARG(resubscribe, NULL,
+		      HELP_ADDR_LE " <CCC handle> "
+				   "<value handle> [ind]",
+		      cmd_resubscribe, 5, 1),
 	SHELL_CMD_ARG(write, NULL, "<handle> <offset> <data>", cmd_write, 4, 0),
-	SHELL_CMD_ARG(write-without-response, NULL,
-		      "<handle> <data> [length] [repeat]",
+	SHELL_CMD_ARG(write - without - response, NULL, "<handle> <data> [length] [repeat]",
 		      cmd_write_without_rsp, 3, 2),
-	SHELL_CMD_ARG(write-without-response-cb, NULL,
-		      "<handle> <data> [length] [repeat]",
+	SHELL_CMD_ARG(write - without - response - cb, NULL, "<handle> <data> [length] [repeat]",
 		      cmd_write_without_rsp, 3, 2),
 	SHELL_CMD_ARG(unsubscribe, NULL, HELP_NONE, cmd_unsubscribe, 1, 0),
 #endif /* CONFIG_BT_GATT_CLIENT */
 	SHELL_CMD_ARG(get, NULL, "<start handle> [end handle]", cmd_get, 2, 1),
 	SHELL_CMD_ARG(set, NULL, "<handle> [data...]", cmd_set, 2, 255),
-	SHELL_CMD_ARG(show-db, NULL, "[uuid] [num_matches]", cmd_show_db, 1, 2),
+	SHELL_CMD_ARG(show - db, NULL, "[uuid] [num_matches]", cmd_show_db, 1, 2),
 	SHELL_CMD_ARG(att_mtu, NULL, "Output ATT MTU size", cmd_att_mtu, 1, 0),
 #if defined(CONFIG_BT_GATT_DYNAMIC_DB)
 	SHELL_CMD_ARG(metrics, NULL, "[value: on, off]", cmd_metrics, 1, 1),
-	SHELL_CMD_ARG(register, NULL,
-		      "register pre-predefined test service",
-		      cmd_register_test_svc, 1, 0),
-	SHELL_CMD_ARG(unregister, NULL,
-		      "unregister pre-predefined test service",
+	SHELL_CMD_ARG(register, NULL, "register pre-predefined test service", cmd_register_test_svc,
+		      1, 0),
+	SHELL_CMD_ARG(unregister, NULL, "unregister pre-predefined test service",
 		      cmd_unregister_test_svc, 1, 0),
 	SHELL_CMD_ARG(notify, NULL, "<handle> <data>", cmd_notify, 3, 0),
 #if defined(CONFIG_BT_GATT_NOTIFY_MULTIPLE)
-	SHELL_CMD_ARG(notify-mult, NULL, "count [data]", cmd_notify_mult, 2, 1),
+	SHELL_CMD_ARG(notify - mult, NULL, "count [data]", cmd_notify_mult, 2, 1),
 #endif /* CONFIG_BT_GATT_NOTIFY_MULTIPLE */
 #endif /* CONFIG_BT_GATT_DYNAMIC_DB */
-	SHELL_SUBCMD_SET_END
-);
+	SHELL_SUBCMD_SET_END);
 
 static int cmd_gatt(const struct shell *sh, size_t argc, char **argv)
 {
@@ -1347,5 +1299,4 @@ static int cmd_gatt(const struct shell *sh, size_t argc, char **argv)
 	return -EINVAL;
 }
 
-SHELL_CMD_ARG_REGISTER(gatt, &gatt_cmds, "Bluetooth GATT shell commands",
-		       cmd_gatt, 1, 1);
+SHELL_CMD_ARG_REGISTER(gatt, &gatt_cmds, "Bluetooth GATT shell commands", cmd_gatt, 1, 1);
diff --git a/subsys/bluetooth/host/shell/iso.c b/subsys/bluetooth/host/shell/iso.c
index 43e8fb80c26..49feedefa77 100644
--- a/subsys/bluetooth/host/shell/iso.c
+++ b/subsys/bluetooth/host/shell/iso.c
@@ -28,7 +28,9 @@
 #if defined(CONFIG_BT_ISO_TX)
 #define DEFAULT_IO_QOS                                                                             \
 	{                                                                                          \
-		.sdu = 40u, .phy = BT_GAP_LE_PHY_2M, .rtn = 2u,                                    \
+		.sdu = 40u,                                                                        \
+		.phy = BT_GAP_LE_PHY_2M,                                                           \
+		.rtn = 2u,                                                                         \
 	}
 
 #define TX_BUF_TIMEOUT K_SECONDS(1)
@@ -48,8 +50,7 @@ static int64_t bis_sn_last_updated_ticks;
  *
  * @return The next sequence number to use
  */
-static uint32_t get_next_sn(uint32_t last_sn, int64_t *last_ticks,
-			    uint32_t interval_us)
+static uint32_t get_next_sn(uint32_t last_sn, int64_t *last_ticks, uint32_t interval_us)
 {
 	int64_t uptime_ticks, delta_ticks;
 	uint64_t delta_us;
@@ -76,8 +77,8 @@ static void iso_recv(struct bt_iso_chan *chan, const struct bt_iso_recv_info *in
 		     struct net_buf *buf)
 {
 	if (info->flags & BT_ISO_FLAGS_VALID) {
-		bt_shell_print("Incoming data channel %p len %u, seq: %d, ts: %d",
-			       chan, buf->len, info->seq_num, info->ts);
+		bt_shell_print("Incoming data channel %p len %u, seq: %d, ts: %d", chan, buf->len,
+			       info->seq_num, info->ts);
 	}
 }
 #endif /* CONFIG_BT_ISO_RX */
@@ -108,8 +109,7 @@ static void iso_connected(struct bt_iso_chan *chan)
 
 static void iso_disconnected(struct bt_iso_chan *chan, uint8_t reason)
 {
-	bt_shell_print("ISO Channel %p disconnected with reason 0x%02x",
-		       chan, reason);
+	bt_shell_print("ISO Channel %p disconnected with reason 0x%02x", chan, reason);
 }
 
 static struct bt_iso_chan_ops iso_ops = {
@@ -156,9 +156,7 @@ static long parse_interval(const struct shell *sh, const char *interval_str)
 		return -ENOEXEC;
 	}
 
-	if (!IN_RANGE(interval,
-		      BT_ISO_SDU_INTERVAL_MIN,
-		      BT_ISO_SDU_INTERVAL_MAX)) {
+	if (!IN_RANGE(interval, BT_ISO_SDU_INTERVAL_MIN, BT_ISO_SDU_INTERVAL_MAX)) {
 		shell_error(sh, "Invalid interval %lu", interval);
 
 		return -ENOEXEC;
@@ -180,9 +178,7 @@ static long parse_latency(const struct shell *sh, const char *latency_str)
 		return -ENOEXEC;
 	}
 
-	if (!IN_RANGE(latency,
-		      BT_ISO_LATENCY_MIN,
-		      BT_ISO_LATENCY_MAX)) {
+	if (!IN_RANGE(latency, BT_ISO_LATENCY_MIN, BT_ISO_LATENCY_MAX)) {
 		shell_error(sh, "Invalid latency %lu", latency);
 
 		return -ENOEXEC;
@@ -358,8 +354,7 @@ static int cmd_cig_create(const struct shell *sh, size_t argc, char *argv[])
 			return -ENOEXEC;
 		}
 
-		if (phy != BT_GAP_LE_PHY_1M &&
-		    phy != BT_GAP_LE_PHY_2M &&
+		if (phy != BT_GAP_LE_PHY_1M && phy != BT_GAP_LE_PHY_2M &&
 		    phy != BT_GAP_LE_PHY_CODED) {
 			shell_error(sh, "Invalid phy %lu", phy);
 
@@ -438,10 +433,7 @@ static int cmd_cig_term(const struct shell *sh, size_t argc, char *argv[])
 
 static int cmd_connect(const struct shell *sh, size_t argc, char *argv[])
 {
-	struct bt_iso_connect_param connect_param = {
-		.acl = default_conn,
-		.iso_chan = &iso_chan
-	};
+	struct bt_iso_connect_param connect_param = {.acl = default_conn, .iso_chan = &iso_chan};
 	int err;
 
 	if (iso_chan.iso == NULL) {
@@ -469,11 +461,10 @@ static int cmd_connect(const struct shell *sh, size_t argc, char *argv[])
 
 #if defined(CONFIG_BT_ISO_PERIPHERAL)
 
-static int iso_accept(const struct bt_iso_accept_info *info,
-		      struct bt_iso_chan **chan)
+static int iso_accept(const struct bt_iso_accept_info *info, struct bt_iso_chan **chan)
 {
-	bt_shell_print("Incoming request from %p with CIG ID 0x%02X and CIS ID 0x%02X",
-		       info->acl, info->cig_id, info->cis_id);
+	bt_shell_print("Incoming request from %p with CIG ID 0x%02X and CIS ID 0x%02X", info->acl,
+		       info->cig_id, info->cis_id);
 
 	if (iso_chan.iso) {
 		bt_shell_print("No channels available");
@@ -542,9 +533,7 @@ static int cmd_listen(const struct shell *sh, size_t argc, char *argv[])
 
 static int cmd_send(const struct shell *sh, size_t argc, char *argv[])
 {
-	static uint8_t buf_data[CONFIG_BT_ISO_TX_MTU] = {
-		[0 ... (CONFIG_BT_ISO_TX_MTU - 1)] = 0xff
-	};
+	static uint8_t buf_data[CONFIG_BT_ISO_TX_MTU] = {[0 ...(CONFIG_BT_ISO_TX_MTU - 1)] = 0xff};
 	unsigned long count = 1;
 	struct net_buf *buf;
 	int ret = 0;
@@ -570,8 +559,7 @@ static int cmd_send(const struct shell *sh, size_t argc, char *argv[])
 	}
 
 	len = MIN(iso_chan.qos->tx->sdu, CONFIG_BT_ISO_TX_MTU);
-	cis_sn_last = get_next_sn(cis_sn_last, &cis_sn_last_updated_ticks,
-				  cis_sdu_interval_us);
+	cis_sn_last = get_next_sn(cis_sn_last, &cis_sn_last_updated_ticks, cis_sdu_interval_us);
 
 	while (count--) {
 		buf = net_buf_alloc(&tx_pool, TX_BUF_TIMEOUT);
@@ -597,8 +585,7 @@ static int cmd_send(const struct shell *sh, size_t argc, char *argv[])
 	return 0;
 }
 
-static int cmd_disconnect(const struct shell *sh, size_t argc,
-			  char *argv[])
+static int cmd_disconnect(const struct shell *sh, size_t argc, char *argv[])
 {
 	int err;
 
@@ -647,7 +634,7 @@ static struct bt_iso_chan bis_iso_chan = {
 	.qos = &bis_iso_qos,
 };
 
-static struct bt_iso_chan *bis_channels[BIS_ISO_CHAN_COUNT] = { &bis_iso_chan };
+static struct bt_iso_chan *bis_channels[BIS_ISO_CHAN_COUNT] = {&bis_iso_chan};
 
 #if defined(CONFIG_BT_ISO_BROADCASTER)
 static uint32_t bis_sdu_interval_us;
@@ -658,9 +645,7 @@ NET_BUF_POOL_FIXED_DEFINE(bis_tx_pool, BIS_ISO_CHAN_COUNT,
 
 static int cmd_broadcast(const struct shell *sh, size_t argc, char *argv[])
 {
-	static uint8_t buf_data[CONFIG_BT_ISO_TX_MTU] = {
-		[0 ... (CONFIG_BT_ISO_TX_MTU - 1)] = 0xff
-	};
+	static uint8_t buf_data[CONFIG_BT_ISO_TX_MTU] = {[0 ...(CONFIG_BT_ISO_TX_MTU - 1)] = 0xff};
 	unsigned long count = 1;
 	struct net_buf *buf;
 	int ret = 0;
@@ -686,8 +671,7 @@ static int cmd_broadcast(const struct shell *sh, size_t argc, char *argv[])
 	}
 
 	len = MIN(bis_iso_chan.qos->tx->sdu, CONFIG_BT_ISO_TX_MTU);
-	bis_sn_last = get_next_sn(bis_sn_last, &bis_sn_last_updated_ticks,
-				  bis_sdu_interval_us);
+	bis_sn_last = get_next_sn(bis_sn_last, &bis_sn_last_updated_ticks, bis_sdu_interval_us);
 
 	while (count--) {
 		buf = net_buf_alloc(&bis_tx_pool, TX_BUF_TIMEOUT);
@@ -730,8 +714,8 @@ static int cmd_big_create(const struct shell *sh, size_t argc, char *argv[])
 	bis_iso_qos.tx->rtn = 2;
 	bis_iso_qos.tx->sdu = CONFIG_BT_ISO_TX_MTU;
 
-	bis_sdu_interval_us = param.interval = 10000;      /* us */
-	param.latency = 20;          /* ms */
+	bis_sdu_interval_us = param.interval = 10000; /* us */
+	param.latency = 20;                           /* ms */
 	param.bis_channels = bis_channels;
 	param.num_bis = BIS_ISO_CHAN_COUNT;
 	param.encryption = false;
@@ -740,8 +724,8 @@ static int cmd_big_create(const struct shell *sh, size_t argc, char *argv[])
 
 	if (argc > 1) {
 		if (!strcmp(argv[1], "enc")) {
-			uint8_t bcode_len = hex2bin(argv[1], strlen(argv[1]), param.bcode,
-						    sizeof(param.bcode));
+			uint8_t bcode_len =
+				hex2bin(argv[1], strlen(argv[1]), param.bcode, sizeof(param.bcode));
 			if (!bcode_len || bcode_len != sizeof(param.bcode)) {
 				shell_error(sh, "Invalid Broadcast Code Length");
 				return -ENOEXEC;
@@ -868,8 +852,7 @@ static int cmd_big_sync(const struct shell *sh, size_t argc, char *argv[])
 				return -ENOEXEC;
 			}
 
-			if (!IN_RANGE(sync_timeout,
-				      BT_ISO_SYNC_TIMEOUT_MIN,
+			if (!IN_RANGE(sync_timeout, BT_ISO_SYNC_TIMEOUT_MIN,
 				      BT_ISO_SYNC_TIMEOUT_MAX)) {
 				shell_error(sh, "Invalid sync_timeout %lu", sync_timeout);
 
@@ -887,8 +870,8 @@ static int cmd_big_sync(const struct shell *sh, size_t argc, char *argv[])
 			}
 
 			memset(param.bcode, 0, sizeof(param.bcode));
-			bcode_len = hex2bin(argv[i], strlen(argv[i]), param.bcode,
-					    sizeof(param.bcode));
+			bcode_len =
+				hex2bin(argv[i], strlen(argv[i]), param.bcode, sizeof(param.bcode));
 
 			if (bcode_len == 0) {
 				shell_error(sh, "Invalid Broadcast Code");
@@ -931,7 +914,8 @@ static int cmd_big_term(const struct shell *sh, size_t argc, char *argv[])
 }
 #endif /* CONFIG_BT_ISO_BROADCAST*/
 
-SHELL_STATIC_SUBCMD_SET_CREATE(iso_cmds,
+SHELL_STATIC_SUBCMD_SET_CREATE(
+	iso_cmds,
 #if defined(CONFIG_BT_ISO_UNICAST)
 #if defined(CONFIG_BT_ISO_CENTRAL)
 	SHELL_CMD_ARG(cig_create, NULL,
@@ -941,14 +925,14 @@ SHELL_STATIC_SUBCMD_SET_CREATE(iso_cmds,
 	SHELL_CMD_ARG(cig_term, NULL, "Terminate the CIG", cmd_cig_term, 1, 0),
 #if defined(CONFIG_BT_SMP)
 	SHELL_CMD_ARG(connect, NULL, "Connect ISO Channel [security level]", cmd_connect, 1, 1),
-#else /* !CONFIG_BT_SMP */
+#else  /* !CONFIG_BT_SMP */
 	SHELL_CMD_ARG(connect, NULL, "Connect ISO Channel", cmd_connect, 1, 0),
 #endif /* CONFIG_BT_SMP */
 #endif /* CONFIG_BT_ISO_CENTRAL */
 #if defined(CONFIG_BT_ISO_PERIPHERAL)
 #if defined(CONFIG_BT_SMP)
 	SHELL_CMD_ARG(listen, NULL, "<dir=tx,rx,txrx> [security level]", cmd_listen, 2, 1),
-#else /* !CONFIG_BT_SMP */
+#else  /* !CONFIG_BT_SMP */
 	SHELL_CMD_ARG(listen, NULL, "<dir=tx,rx,txrx>", cmd_listen, 2, 0),
 #endif /* CONFIG_BT_SMP */
 #endif /* CONFIG_BT_ISO_PERIPHERAL */
@@ -959,22 +943,21 @@ SHELL_STATIC_SUBCMD_SET_CREATE(iso_cmds,
 	SHELL_CMD_ARG(tx_sync_read_cis, NULL, "Read CIS TX sync info", cmd_tx_sync_read_cis, 1, 0),
 #endif /* CONFIG_BT_ISO_UNICAST */
 #if defined(CONFIG_BT_ISO_BROADCASTER)
-	SHELL_CMD_ARG(create-big, NULL, "Create a BIG as a broadcaster [enc <broadcast code>]",
+	SHELL_CMD_ARG(create - big, NULL, "Create a BIG as a broadcaster [enc <broadcast code>]",
 		      cmd_big_create, 1, 2),
 	SHELL_CMD_ARG(broadcast, NULL, "Broadcast on ISO channels", cmd_broadcast, 1, 1),
 	SHELL_CMD_ARG(tx_sync_read_bis, NULL, "Read BIS TX sync info", cmd_tx_sync_read_bis, 1, 0),
 #endif /* CONFIG_BT_ISO_BROADCASTER */
 #if defined(CONFIG_BT_ISO_SYNC_RECEIVER)
-	SHELL_CMD_ARG(sync-big, NULL,
+	SHELL_CMD_ARG(sync - big, NULL,
 		      "Synchronize to a BIG as a receiver <BIS bitfield> [mse] "
 		      "[timeout] [enc <broadcast code>]",
 		      cmd_big_sync, 2, 4),
 #endif /* CONFIG_BT_ISO_SYNC_RECEIVER */
 #if defined(CONFIG_BT_ISO_BROADCAST)
-	SHELL_CMD_ARG(term-big, NULL, "Terminate a BIG", cmd_big_term, 1, 0),
+	SHELL_CMD_ARG(term - big, NULL, "Terminate a BIG", cmd_big_term, 1, 0),
 #endif /* CONFIG_BT_ISO_BROADCAST */
-	SHELL_SUBCMD_SET_END
-);
+	SHELL_SUBCMD_SET_END);
 
 static int cmd_iso(const struct shell *sh, size_t argc, char **argv)
 {
@@ -989,5 +972,4 @@ static int cmd_iso(const struct shell *sh, size_t argc, char **argv)
 	return -EINVAL;
 }
 
-SHELL_CMD_ARG_REGISTER(iso, &iso_cmds, "Bluetooth ISO shell commands",
-		       cmd_iso, 1, 1);
+SHELL_CMD_ARG_REGISTER(iso, &iso_cmds, "Bluetooth ISO shell commands", cmd_iso, 1, 1);
diff --git a/subsys/bluetooth/host/shell/l2cap.c b/subsys/bluetooth/host/shell/l2cap.c
index 48c568c11a0..3ef6e7403cd 100644
--- a/subsys/bluetooth/host/shell/l2cap.c
+++ b/subsys/bluetooth/host/shell/l2cap.c
@@ -32,12 +32,12 @@
 #include "host/shell/bt.h"
 #include "host/shell/bt_shell_private.h"
 
-#define CREDITS			10
-#define DATA_MTU		(23 * CREDITS)
+#define CREDITS  10
+#define DATA_MTU (23 * CREDITS)
 
-#define L2CAP_POLICY_NONE		0x00
-#define L2CAP_POLICY_ALLOWLIST		0x01
-#define L2CAP_POLICY_16BYTE_KEY		0x02
+#define L2CAP_POLICY_NONE       0x00
+#define L2CAP_POLICY_ALLOWLIST  0x01
+#define L2CAP_POLICY_16BYTE_KEY 0x02
 
 NET_BUF_POOL_FIXED_DEFINE(data_tx_pool, 1, BT_L2CAP_SDU_BUF_SIZE(DATA_MTU),
 			  CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);
@@ -53,9 +53,8 @@ struct l2ch {
 	struct k_work_delayable recv_work;
 	struct bt_l2cap_le_chan ch;
 };
-#define L2CH_CHAN(_chan) CONTAINER_OF(_chan, struct l2ch, ch.chan)
-#define L2CH_WORK(_work) CONTAINER_OF(k_work_delayable_from_work(_work), \
-				      struct l2ch, recv_work)
+#define L2CH_CHAN(_chan)  CONTAINER_OF(_chan, struct l2ch, ch.chan)
+#define L2CH_WORK(_work)  CONTAINER_OF(k_work_delayable_from_work(_work), struct l2ch, recv_work)
 #define L2CAP_CHAN(_chan) _chan->ch.chan
 
 static bool metrics;
@@ -103,8 +102,7 @@ static int l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 		return l2cap_recv_metrics(chan, buf);
 	}
 
-	bt_shell_print("Incoming data channel %p len %u",
-		       chan, buf->len);
+	bt_shell_print("Incoming data channel %p len %u", chan, buf->len);
 
 	if (buf->len) {
 		bt_shell_hexdump(buf->data, buf->len);
@@ -113,8 +111,7 @@ static int l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 	if (l2cap_recv_delay_ms > 0) {
 		/* Submit work only if queue is empty */
 		if (k_fifo_is_empty(&l2cap_recv_fifo)) {
-			bt_shell_print("Delaying response in %u ms...",
-				       l2cap_recv_delay_ms);
+			bt_shell_print("Delaying response in %u ms...", l2cap_recv_delay_ms);
 		}
 
 		k_fifo_put(&l2cap_recv_fifo, buf);
@@ -161,17 +158,17 @@ static struct net_buf *l2cap_alloc_buf(struct bt_l2cap_chan *chan)
 }
 
 static const struct bt_l2cap_chan_ops l2cap_ops = {
-	.alloc_buf	= l2cap_alloc_buf,
-	.recv		= l2cap_recv,
-	.sent		= l2cap_sent,
-	.status		= l2cap_status,
-	.connected	= l2cap_connected,
-	.disconnected	= l2cap_disconnected,
+	.alloc_buf = l2cap_alloc_buf,
+	.recv = l2cap_recv,
+	.sent = l2cap_sent,
+	.status = l2cap_status,
+	.connected = l2cap_connected,
+	.disconnected = l2cap_disconnected,
 };
 
 static struct l2ch l2ch_chan = {
-	.ch.chan.ops	= &l2cap_ops,
-	.ch.rx.mtu	= DATA_MTU,
+	.ch.chan.ops = &l2cap_ops,
+	.ch.rx.mtu = DATA_MTU,
 };
 
 static void l2cap_allowlist_remove(struct bt_conn *conn, uint8_t reason)
@@ -236,7 +233,7 @@ static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_server *server,
 }
 
 static struct bt_l2cap_server server = {
-	.accept		= l2cap_accept,
+	.accept = l2cap_accept,
 };
 
 static int cmd_register(const struct shell *sh, size_t argc, char *argv[])
@@ -271,8 +268,8 @@ static int cmd_register(const struct shell *sh, size_t argc, char *argv[])
 		server.psm = 0U;
 		return -ENOEXEC;
 	} else {
-		shell_print(sh, "L2CAP psm %u sec_level %u registered",
-			    server.psm, server.sec_level);
+		shell_print(sh, "L2CAP psm %u sec_level %u registered", server.psm,
+			    server.sec_level);
 	}
 
 	return 0;
@@ -281,7 +278,7 @@ static int cmd_register(const struct shell *sh, size_t argc, char *argv[])
 #if defined(CONFIG_BT_L2CAP_ECRED)
 static int cmd_ecred_reconfigure(const struct shell *sh, size_t argc, char *argv[])
 {
-	struct bt_l2cap_chan *l2cap_ecred_chans[] = { &l2ch_chan.ch.chan, NULL };
+	struct bt_l2cap_chan *l2cap_ecred_chans[] = {&l2ch_chan.ch.chan, NULL};
 	uint16_t mtu;
 	int err = 0;
 
@@ -314,7 +311,7 @@ static int cmd_ecred_reconfigure(const struct shell *sh, size_t argc, char *argv
 
 static int cmd_ecred_connect(const struct shell *sh, size_t argc, char *argv[])
 {
-	struct bt_l2cap_chan *l2cap_ecred_chans[] = { &l2ch_chan.ch.chan, NULL };
+	struct bt_l2cap_chan *l2cap_ecred_chans[] = {&l2ch_chan.ch.chan, NULL};
 	uint16_t psm;
 	int err = 0;
 
@@ -410,7 +407,7 @@ static int cmd_disconnect(const struct shell *sh, size_t argc, char *argv[])
 
 static int cmd_send(const struct shell *sh, size_t argc, char *argv[])
 {
-	static uint8_t buf_data[DATA_MTU] = { [0 ... (DATA_MTU - 1)] = 0xff };
+	static uint8_t buf_data[DATA_MTU] = {[0 ...(DATA_MTU - 1)] = 0xff};
 	int ret, len = DATA_MTU, count = 1;
 	struct net_buf *buf;
 
@@ -460,8 +457,7 @@ static int cmd_recv(const struct shell *sh, size_t argc, char *argv[])
 	if (argc > 1) {
 		l2cap_recv_delay_ms = strtoul(argv[1], NULL, 10);
 	} else {
-		shell_print(sh, "l2cap receive delay: %u ms",
-			    l2cap_recv_delay_ms);
+		shell_print(sh, "l2cap receive delay: %u ms", l2cap_recv_delay_ms);
 	}
 
 	return 0;
@@ -526,29 +522,27 @@ static int cmd_allowlist_remove(const struct shell *sh, size_t argc, char *argv[
 #define HELP_NONE "[none]"
 
 SHELL_STATIC_SUBCMD_SET_CREATE(allowlist_cmds,
-	SHELL_CMD_ARG(add, NULL, HELP_NONE, cmd_allowlist_add, 1, 0),
-	SHELL_CMD_ARG(remove, NULL, HELP_NONE, cmd_allowlist_remove, 1, 0),
-	SHELL_SUBCMD_SET_END
-);
+			       SHELL_CMD_ARG(add, NULL, HELP_NONE, cmd_allowlist_add, 1, 0),
+			       SHELL_CMD_ARG(remove, NULL, HELP_NONE, cmd_allowlist_remove, 1, 0),
+			       SHELL_SUBCMD_SET_END);
 
-SHELL_STATIC_SUBCMD_SET_CREATE(l2cap_cmds,
-	SHELL_CMD_ARG(connect, NULL, "<psm> [sec_level]", cmd_connect, 2, 1),
+SHELL_STATIC_SUBCMD_SET_CREATE(
+	l2cap_cmds, SHELL_CMD_ARG(connect, NULL, "<psm> [sec_level]", cmd_connect, 2, 1),
 	SHELL_CMD_ARG(disconnect, NULL, HELP_NONE, cmd_disconnect, 1, 0),
 	SHELL_CMD_ARG(metrics, NULL, "<value on, off>", cmd_metrics, 2, 0),
 	SHELL_CMD_ARG(recv, NULL, "[delay (in milliseconds)", cmd_recv, 1, 1),
-	SHELL_CMD_ARG(register, NULL, "<psm> [sec_level] "
-		      "[policy: allowlist, 16byte_key]", cmd_register, 2, 2),
-	SHELL_CMD_ARG(send, NULL, "[number of packets] [length of packet(s)]",
-		      cmd_send, 1, 2),
+	SHELL_CMD_ARG(register, NULL,
+		      "<psm> [sec_level] "
+		      "[policy: allowlist, 16byte_key]",
+		      cmd_register, 2, 2),
+	SHELL_CMD_ARG(send, NULL, "[number of packets] [length of packet(s)]", cmd_send, 1, 2),
 	SHELL_CMD_ARG(allowlist, &allowlist_cmds, HELP_NONE, NULL, 1, 0),
 #if defined(CONFIG_BT_L2CAP_ECRED)
-	SHELL_CMD_ARG(ecred-connect, NULL, "<psm (hex)> [sec_level (dec)]",
-		cmd_ecred_connect, 2, 1),
-	SHELL_CMD_ARG(ecred-reconfigure, NULL, "<mtu (dec)>",
-		cmd_ecred_reconfigure, 1, 1),
+	SHELL_CMD_ARG(ecred - connect, NULL, "<psm (hex)> [sec_level (dec)]", cmd_ecred_connect, 2,
+		      1),
+	SHELL_CMD_ARG(ecred - reconfigure, NULL, "<mtu (dec)>", cmd_ecred_reconfigure, 1, 1),
 #endif /* CONFIG_BT_L2CAP_ECRED */
-	SHELL_SUBCMD_SET_END
-);
+	SHELL_SUBCMD_SET_END);
 
 static int cmd_l2cap(const struct shell *sh, size_t argc, char **argv)
 {
@@ -563,5 +557,4 @@ static int cmd_l2cap(const struct shell *sh, size_t argc, char **argv)
 	return -ENOEXEC;
 }
 
-SHELL_CMD_ARG_REGISTER(l2cap, &l2cap_cmds, "Bluetooth L2CAP shell commands",
-		       cmd_l2cap, 1, 1);
+SHELL_CMD_ARG_REGISTER(l2cap, &l2cap_cmds, "Bluetooth L2CAP shell commands", cmd_l2cap, 1, 1);
diff --git a/subsys/bluetooth/host/smp.c b/subsys/bluetooth/host/smp.c
index cce63f7d1a2..8fb0e600050 100644
--- a/subsys/bluetooth/host/smp.c
+++ b/subsys/bluetooth/host/smp.c
@@ -27,7 +27,6 @@
 #include <zephyr/sys/check.h>
 #include <zephyr/sys/util.h>
 
-
 #include "common/bt_str.h"
 
 #include "crypto/bt_crypto.h"
@@ -63,8 +62,7 @@ LOG_MODULE_REGISTER(bt_smp);
 #define LINK_DIST 0
 #endif
 
-#define RECV_KEYS (BT_SMP_DIST_ENC_KEY | BT_SMP_DIST_ID_KEY | SIGN_DIST |\
-		   LINK_DIST)
+#define RECV_KEYS (BT_SMP_DIST_ENC_KEY | BT_SMP_DIST_ID_KEY | SIGN_DIST | LINK_DIST)
 #define SEND_KEYS (BT_SMP_DIST_ENC_KEY | ID_DIST | SIGN_DIST | LINK_DIST)
 
 #define RECV_KEYS_SC (RECV_KEYS & ~(BT_SMP_DIST_ENC_KEY))
@@ -73,7 +71,7 @@ LOG_MODULE_REGISTER(bt_smp);
 #define BR_RECV_KEYS_SC (RECV_KEYS & ~(LINK_DIST))
 #define BR_SEND_KEYS_SC (SEND_KEYS & ~(LINK_DIST))
 
-#define BT_SMP_AUTH_MASK	0x07
+#define BT_SMP_AUTH_MASK 0x07
 
 #if defined(CONFIG_BT_BONDABLE)
 #define BT_SMP_AUTH_BONDING_FLAGS BT_SMP_AUTH_BONDING
@@ -83,17 +81,16 @@ LOG_MODULE_REGISTER(bt_smp);
 
 #if defined(CONFIG_BT_CLASSIC)
 
-#define BT_SMP_AUTH_MASK_SC	0x2f
+#define BT_SMP_AUTH_MASK_SC 0x2f
 #if defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)
 #define BT_SMP_AUTH_DEFAULT (BT_SMP_AUTH_BONDING_FLAGS | BT_SMP_AUTH_CT2)
 #else
-#define BT_SMP_AUTH_DEFAULT (BT_SMP_AUTH_BONDING_FLAGS | BT_SMP_AUTH_CT2 |\
-			     BT_SMP_AUTH_SC)
+#define BT_SMP_AUTH_DEFAULT (BT_SMP_AUTH_BONDING_FLAGS | BT_SMP_AUTH_CT2 | BT_SMP_AUTH_SC)
 #endif /* CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY */
 
 #else
 
-#define BT_SMP_AUTH_MASK_SC	0x0f
+#define BT_SMP_AUTH_MASK_SC 0x0f
 #if defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)
 #define BT_SMP_AUTH_DEFAULT (BT_SMP_AUTH_BONDING_FLAGS)
 #else
@@ -103,37 +100,37 @@ LOG_MODULE_REGISTER(bt_smp);
 #endif /* CONFIG_BT_CLASSIC */
 
 enum pairing_method {
-	JUST_WORKS,		/* JustWorks pairing */
-	PASSKEY_INPUT,		/* Passkey Entry input */
-	PASSKEY_DISPLAY,	/* Passkey Entry display */
-	PASSKEY_CONFIRM,	/* Passkey confirm */
-	PASSKEY_ROLE,		/* Passkey Entry depends on role */
-	LE_SC_OOB,		/* LESC Out of Band */
-	LEGACY_OOB,		/* Legacy Out of Band */
+	JUST_WORKS,      /* JustWorks pairing */
+	PASSKEY_INPUT,   /* Passkey Entry input */
+	PASSKEY_DISPLAY, /* Passkey Entry display */
+	PASSKEY_CONFIRM, /* Passkey confirm */
+	PASSKEY_ROLE,    /* Passkey Entry depends on role */
+	LE_SC_OOB,       /* LESC Out of Band */
+	LEGACY_OOB,      /* Legacy Out of Band */
 };
 
 enum {
-	SMP_FLAG_CFM_DELAYED,	/* if confirm should be send when TK is valid */
-	SMP_FLAG_ENC_PENDING,	/* if waiting for an encryption change event */
-	SMP_FLAG_KEYS_DISTR,	/* if keys distribution phase is in progress */
-	SMP_FLAG_PAIRING,	/* if pairing is in progress */
-	SMP_FLAG_TIMEOUT,	/* if SMP timeout occurred */
-	SMP_FLAG_SC,		/* if LE Secure Connections is used */
-	SMP_FLAG_PKEY_SEND,	/* if should send Public Key when available */
-	SMP_FLAG_DHKEY_PENDING,	/* if waiting for local DHKey */
+	SMP_FLAG_CFM_DELAYED,   /* if confirm should be send when TK is valid */
+	SMP_FLAG_ENC_PENDING,   /* if waiting for an encryption change event */
+	SMP_FLAG_KEYS_DISTR,    /* if keys distribution phase is in progress */
+	SMP_FLAG_PAIRING,       /* if pairing is in progress */
+	SMP_FLAG_TIMEOUT,       /* if SMP timeout occurred */
+	SMP_FLAG_SC,            /* if LE Secure Connections is used */
+	SMP_FLAG_PKEY_SEND,     /* if should send Public Key when available */
+	SMP_FLAG_DHKEY_PENDING, /* if waiting for local DHKey */
 	SMP_FLAG_DHKEY_GEN,     /* if generating DHKey */
-	SMP_FLAG_DHKEY_SEND,	/* if should generate and send DHKey Check */
-	SMP_FLAG_USER,		/* if waiting for user input */
+	SMP_FLAG_DHKEY_SEND,    /* if should generate and send DHKey Check */
+	SMP_FLAG_USER,          /* if waiting for user input */
 	SMP_FLAG_DISPLAY,       /* if display_passkey() callback was called */
-	SMP_FLAG_OOB_PENDING,	/* if waiting for OOB data */
-	SMP_FLAG_BOND,		/* if bonding */
-	SMP_FLAG_SC_DEBUG_KEY,	/* if Secure Connection are using debug key */
-	SMP_FLAG_SEC_REQ,	/* if Security Request was sent/received */
-	SMP_FLAG_DHCHECK_WAIT,	/* if waiting for remote DHCheck (as periph) */
-	SMP_FLAG_DERIVE_LK,	/* if Link Key should be derived */
-	SMP_FLAG_BR_CONNECTED,	/* if BR/EDR channel is connected */
-	SMP_FLAG_BR_PAIR,	/* if should start BR/EDR pairing */
-	SMP_FLAG_CT2,		/* if should use H7 for keys derivation */
+	SMP_FLAG_OOB_PENDING,   /* if waiting for OOB data */
+	SMP_FLAG_BOND,          /* if bonding */
+	SMP_FLAG_SC_DEBUG_KEY,  /* if Secure Connection are using debug key */
+	SMP_FLAG_SEC_REQ,       /* if Security Request was sent/received */
+	SMP_FLAG_DHCHECK_WAIT,  /* if waiting for remote DHCheck (as periph) */
+	SMP_FLAG_DERIVE_LK,     /* if Link Key should be derived */
+	SMP_FLAG_BR_CONNECTED,  /* if BR/EDR channel is connected */
+	SMP_FLAG_BR_PAIR,       /* if should start BR/EDR pairing */
+	SMP_FLAG_CT2,           /* if should use H7 for keys derivation */
 
 	/* Total number of flags - must be at the end */
 	SMP_NUM_FLAGS,
@@ -148,102 +145,97 @@ struct bt_smp {
 	ATOMIC_DEFINE(flags, SMP_NUM_FLAGS);
 
 	/* Type of method used for pairing */
-	uint8_t				method;
+	uint8_t method;
 
 	/* Pairing Request PDU */
-	uint8_t				preq[7];
+	uint8_t preq[7];
 
 	/* Pairing Response PDU */
-	uint8_t				prsp[7];
+	uint8_t prsp[7];
 
 	/* Pairing Confirm PDU */
-	uint8_t				pcnf[16];
+	uint8_t pcnf[16];
 
 	/* Local random number */
-	uint8_t				prnd[16];
+	uint8_t prnd[16];
 
 	/* Remote random number */
-	uint8_t				rrnd[16];
+	uint8_t rrnd[16];
 
 	/* Temporary key */
-	uint8_t				tk[16];
+	uint8_t tk[16];
 
 	/* Remote Public Key for LE SC */
-	uint8_t				pkey[BT_PUB_KEY_LEN];
+	uint8_t pkey[BT_PUB_KEY_LEN];
 
 	/* DHKey */
-	uint8_t				dhkey[BT_DH_KEY_LEN];
+	uint8_t dhkey[BT_DH_KEY_LEN];
 
 	/* Remote DHKey check */
-	uint8_t				e[16];
+	uint8_t e[16];
 
 	/* MacKey */
-	uint8_t				mackey[16];
+	uint8_t mackey[16];
 
 	/* LE SC passkey */
-	uint32_t				passkey;
+	uint32_t passkey;
 
 	/* LE SC passkey round */
-	uint8_t				passkey_round;
+	uint8_t passkey_round;
 
 	/* LE SC local OOB data */
-	const struct bt_le_oob_sc_data	*oobd_local;
+	const struct bt_le_oob_sc_data *oobd_local;
 
 	/* LE SC remote OOB data */
-	const struct bt_le_oob_sc_data	*oobd_remote;
+	const struct bt_le_oob_sc_data *oobd_remote;
 
 	/* Local key distribution */
-	uint8_t				local_dist;
+	uint8_t local_dist;
 
 	/* Remote key distribution */
-	uint8_t				remote_dist;
+	uint8_t remote_dist;
 
 	/* The channel this context is associated with.
 	 * This marks the beginning of the part of the structure that will not
 	 * be memset to zero in init.
 	 */
-	struct bt_l2cap_le_chan		chan;
+	struct bt_l2cap_le_chan chan;
 
 	/* Delayed work for timeout handling */
-	struct k_work_delayable		work;
+	struct k_work_delayable work;
 
 	/* Used Bluetooth authentication callbacks. */
-	atomic_ptr_t			auth_cb;
+	atomic_ptr_t auth_cb;
 
 	/* Bondable flag */
-	atomic_t			bondable;
+	atomic_t bondable;
 };
 
 static unsigned int fixed_passkey = BT_PASSKEY_INVALID;
 
-#define DISPLAY_FIXED(smp) (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) && \
-			    fixed_passkey != BT_PASSKEY_INVALID && \
-			    (smp)->method == PASSKEY_DISPLAY)
+#define DISPLAY_FIXED(smp)                                                                         \
+	(IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) && fixed_passkey != BT_PASSKEY_INVALID &&             \
+	 (smp)->method == PASSKEY_DISPLAY)
 
 #if !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
 /* based on table 2.8 Core Spec 2.3.5.1 Vol. 3 Part H */
 static const uint8_t gen_method_legacy[5 /* remote */][5 /* local */] = {
-	{ JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS, PASSKEY_INPUT },
-	{ JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS, PASSKEY_INPUT },
-	{ PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS,
-	  PASSKEY_DISPLAY },
-	{ JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS },
-	{ PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS,
-	  PASSKEY_ROLE },
+	{JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS, PASSKEY_INPUT},
+	{JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS, PASSKEY_INPUT},
+	{PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS, PASSKEY_DISPLAY},
+	{JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS},
+	{PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS, PASSKEY_ROLE},
 };
 #endif /* CONFIG_BT_SMP_SC_PAIR_ONLY */
 
 #if !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)
 /* based on table 2.8 Core Spec 2.3.5.1 Vol. 3 Part H */
 static const uint8_t gen_method_sc[5 /* remote */][5 /* local */] = {
-	{ JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS, PASSKEY_INPUT },
-	{ JUST_WORKS, PASSKEY_CONFIRM, PASSKEY_INPUT, JUST_WORKS,
-	  PASSKEY_CONFIRM },
-	{ PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS,
-	  PASSKEY_DISPLAY },
-	{ JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS },
-	{ PASSKEY_DISPLAY, PASSKEY_CONFIRM, PASSKEY_INPUT, JUST_WORKS,
-	  PASSKEY_CONFIRM },
+	{JUST_WORKS, JUST_WORKS, PASSKEY_INPUT, JUST_WORKS, PASSKEY_INPUT},
+	{JUST_WORKS, PASSKEY_CONFIRM, PASSKEY_INPUT, JUST_WORKS, PASSKEY_CONFIRM},
+	{PASSKEY_DISPLAY, PASSKEY_DISPLAY, PASSKEY_INPUT, JUST_WORKS, PASSKEY_DISPLAY},
+	{JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS, JUST_WORKS},
+	{PASSKEY_DISPLAY, PASSKEY_CONFIRM, PASSKEY_INPUT, JUST_WORKS, PASSKEY_CONFIRM},
 };
 #endif /* !CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY */
 
@@ -257,22 +249,22 @@ struct bt_smp_br {
 	ATOMIC_DEFINE(flags, SMP_NUM_FLAGS);
 
 	/* Local key distribution */
-	uint8_t			local_dist;
+	uint8_t local_dist;
 
 	/* Remote key distribution */
-	uint8_t			remote_dist;
+	uint8_t remote_dist;
 
 	/* Encryption Key Size used for connection */
-	uint8_t 			enc_key_size;
+	uint8_t enc_key_size;
 
 	/* The channel this context is associated with.
 	 * This marks the beginning of the part of the structure that will not
 	 * be memset to zero in init.
 	 */
-	struct bt_l2cap_br_chan	chan;
+	struct bt_l2cap_br_chan chan;
 
 	/* Delayed work for timeout handling */
-	struct k_work_delayable	work;
+	struct k_work_delayable work;
 };
 
 static struct bt_smp_br bt_smp_br_pool[CONFIG_BT_MAX_CONN];
@@ -289,12 +281,12 @@ static K_SEM_DEFINE(sc_local_pkey_ready, 0, 1);
 /* Pointer to internal data is used to mark that callbacks of given SMP channel are not initialized.
  * Value of NULL represents no authentication capabilities and cannot be used for that purpose.
  */
-#define BT_SMP_AUTH_CB_UNINITIALIZED	((atomic_ptr_val_t)bt_smp_pool)
+#define BT_SMP_AUTH_CB_UNINITIALIZED ((atomic_ptr_val_t)bt_smp_pool)
 
 /* Value used to mark that per-connection bondable flag is not initialized.
  * Value false/true represent if flag is cleared or set and cannot be used for that purpose.
  */
-#define BT_SMP_BONDABLE_UNINITIALIZED	((atomic_val_t)-1)
+#define BT_SMP_BONDABLE_UNINITIALIZED ((atomic_val_t) - 1)
 
 static bool le_sc_supported(void)
 {
@@ -341,14 +333,12 @@ static uint8_t get_io_capa(struct bt_smp *smp)
 	}
 
 	/* DisplayYesNo is useful only for LE SC */
-	if (sc_supported && smp_auth_cb->passkey_display &&
-	    smp_auth_cb->passkey_confirm) {
+	if (sc_supported && smp_auth_cb->passkey_display && smp_auth_cb->passkey_confirm) {
 		return BT_SMP_IO_DISPLAY_YESNO;
 	}
 
 	if (smp_auth_cb->passkey_entry) {
-		if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) &&
-		    fixed_passkey != BT_PASSKEY_INVALID) {
+		if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) && fixed_passkey != BT_PASSKEY_INVALID) {
 			return BT_SMP_IO_KEYBOARD_DISPLAY;
 		} else {
 			return BT_SMP_IO_KEYBOARD_ONLY;
@@ -360,8 +350,7 @@ static uint8_t get_io_capa(struct bt_smp *smp)
 	}
 
 no_callbacks:
-	if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) &&
-	    fixed_passkey != BT_PASSKEY_INVALID) {
+	if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) && fixed_passkey != BT_PASSKEY_INVALID) {
 		return BT_SMP_IO_DISPLAY_ONLY;
 	} else {
 		return BT_SMP_IO_NO_INPUT_OUTPUT;
@@ -379,17 +368,13 @@ static bool smp_keys_check(struct bt_conn *conn)
 	}
 
 	if (!conn->le.keys) {
-		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256,
-						     conn->id, &conn->le.dst);
+		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id, &conn->le.dst);
 		if (!conn->le.keys) {
-			conn->le.keys = bt_keys_find(BT_KEYS_LTK,
-						     conn->id,
-						     &conn->le.dst);
+			conn->le.keys = bt_keys_find(BT_KEYS_LTK, conn->id, &conn->le.dst);
 		}
 	}
 
-	if (!conn->le.keys ||
-	    !(conn->le.keys->keys & (BT_KEYS_LTK | BT_KEYS_LTK_P256))) {
+	if (!conn->le.keys || !(conn->le.keys->keys & (BT_KEYS_LTK | BT_KEYS_LTK_P256))) {
 		return false;
 	}
 
@@ -477,9 +462,9 @@ static enum bt_security_err security_err_get(uint8_t smp_err)
 #if defined(CONFIG_BT_SECURITY_ERR_TO_STR)
 const char *bt_security_err_to_str(enum bt_security_err err)
 {
-	#define SEC_ERR(err) [err] = #err
+#define SEC_ERR(err) [err] = #err
 
-	const char * const mapping_table[] = {
+	const char *const mapping_table[] = {
 		SEC_ERR(BT_SECURITY_ERR_SUCCESS),
 		SEC_ERR(BT_SECURITY_ERR_AUTH_FAIL),
 		SEC_ERR(BT_SECURITY_ERR_PIN_OR_KEY_MISSING),
@@ -498,7 +483,7 @@ const char *bt_security_err_to_str(enum bt_security_err err)
 		return "(unknown)";
 	}
 
-	#undef SEC_ERR
+#undef SEC_ERR
 }
 #endif /* CONFIG_BT_SECURITY_ERR_TO_STR */
 
@@ -530,9 +515,9 @@ static uint8_t smp_err_get(enum bt_security_err auth_err)
 #if defined(CONFIG_BT_SMP_ERR_TO_STR)
 const char *bt_smp_err_to_str(uint8_t smp_err)
 {
-	#define SMP_ERR(err) [err] = #err
+#define SMP_ERR(err) [err] = #err
 
-	const char * const mapping_table[] = {
+	const char *const mapping_table[] = {
 		SMP_ERR(BT_SMP_ERR_SUCCESS),
 		SMP_ERR(BT_SMP_ERR_PASSKEY_ENTRY_FAILED),
 		SMP_ERR(BT_SMP_ERR_OOB_NOT_AVAIL),
@@ -557,7 +542,7 @@ const char *bt_smp_err_to_str(uint8_t smp_err)
 		return "(unknown)";
 	}
 
-	#undef SMP_ERR
+#undef SMP_ERR
 }
 #endif /* CONFIG_BT_SMP_ERR_TO_STR */
 
@@ -613,18 +598,15 @@ static uint8_t get_encryption_key_size(struct bt_smp *smp)
 static bool update_keys_check(struct bt_smp *smp, struct bt_keys *keys)
 {
 	if (IS_ENABLED(CONFIG_BT_SMP_DISABLE_LEGACY_JW_PASSKEY) &&
-	    !atomic_test_bit(smp->flags, SMP_FLAG_SC) &&
-	    smp->method != LEGACY_OOB) {
+	    !atomic_test_bit(smp->flags, SMP_FLAG_SC) && smp->method != LEGACY_OOB) {
 		return false;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) &&
-	    smp->method != LEGACY_OOB) {
+	if (IS_ENABLED(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) && smp->method != LEGACY_OOB) {
 		return false;
 	}
 
-	if (!keys ||
-	    !(keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
+	if (!keys || !(keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
 		return true;
 	}
 
@@ -632,19 +614,16 @@ static bool update_keys_check(struct bt_smp *smp, struct bt_keys *keys)
 		return false;
 	}
 
-	if ((keys->keys & BT_KEYS_LTK_P256) &&
-	    !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
+	if ((keys->keys & BT_KEYS_LTK_P256) && !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
 		return false;
 	}
 
-	if ((keys->flags & BT_KEYS_AUTHENTICATED) &&
-	     smp->method == JUST_WORKS) {
+	if ((keys->flags & BT_KEYS_AUTHENTICATED) && smp->method == JUST_WORKS) {
 		return false;
 	}
 
 	if (!IS_ENABLED(CONFIG_BT_SMP_ALLOW_UNAUTH_OVERWRITE) &&
-	    (!(keys->flags & BT_KEYS_AUTHENTICATED)
-	     && smp->method == JUST_WORKS)) {
+	    (!(keys->flags & BT_KEYS_AUTHENTICATED) && smp->method == JUST_WORKS)) {
 		if (!IS_ENABLED(CONFIG_BT_ID_ALLOW_UNAUTH_OVERWRITE) ||
 		    (keys->id == smp->chan.chan.conn->id)) {
 			return false;
@@ -663,8 +642,7 @@ static bool update_debug_keys_check(struct bt_smp *smp)
 		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
 	}
 
-	if (!conn->le.keys ||
-	    !(conn->le.keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
+	if (!conn->le.keys || !(conn->le.keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
 		return true;
 	}
 
@@ -676,8 +654,7 @@ static bool update_debug_keys_check(struct bt_smp *smp)
 }
 #endif /* CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY */
 
-#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_SIGNING) || \
-	!defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
+#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_SIGNING) || !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
 /* For TX callbacks */
 static void smp_pairing_complete(struct bt_smp *smp, uint8_t status);
 #if defined(CONFIG_BT_CLASSIC)
@@ -746,7 +723,7 @@ static void smp_sign_info_sent(struct bt_conn *conn, void *user_data, int err)
 static void sc_derive_link_key(struct bt_smp *smp)
 {
 	/* constants as specified in Core Spec Vol.3 Part H 2.4.2.4 */
-	static const uint8_t lebr[4] = { 0x72, 0x62, 0x65, 0x6c };
+	static const uint8_t lebr[4] = {0x72, 0x62, 0x65, 0x6c};
 	struct bt_conn *conn = smp->chan.chan.conn;
 	struct bt_keys_link_key *link_key;
 	uint8_t ilk[16];
@@ -766,10 +743,8 @@ static void sc_derive_link_key(struct bt_smp *smp)
 
 	if (atomic_test_bit(smp->flags, SMP_FLAG_CT2)) {
 		/* constants as specified in Core Spec Vol.3 Part H 2.4.2.4 */
-		static const uint8_t salt[16] = { 0x31, 0x70, 0x6d, 0x74,
-					       0x00, 0x00, 0x00, 0x00,
-					       0x00, 0x00, 0x00, 0x00,
-					       0x00, 0x00, 0x00, 0x00 };
+		static const uint8_t salt[16] = {0x31, 0x70, 0x6d, 0x74, 0x00, 0x00, 0x00, 0x00,
+						 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
 		if (bt_crypto_h7(salt, conn->le.keys->ltk.val, ilk)) {
 			bt_keys_link_key_clear(link_key);
@@ -777,7 +752,7 @@ static void sc_derive_link_key(struct bt_smp *smp)
 		}
 	} else {
 		/* constants as specified in Core Spec Vol.3 Part H 2.4.2.4 */
-		static const uint8_t tmp1[4] = { 0x31, 0x70, 0x6d, 0x74 };
+		static const uint8_t tmp1[4] = {0x31, 0x70, 0x6d, 0x74};
 
 		if (bt_crypto_h6(conn->le.keys->ltk.val, tmp1, ilk)) {
 			bt_keys_link_key_clear(link_key);
@@ -838,8 +813,7 @@ static void smp_pairing_br_complete(struct bt_smp_br *smp, uint8_t status)
 			bt_keys_clear(keys);
 		}
 
-		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
-						  next, node) {
+		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 			if (listener->pairing_failed) {
 				listener->pairing_failed(smp->chan.chan.conn,
 							 security_err_get(status));
@@ -853,11 +827,9 @@ static void smp_pairing_br_complete(struct bt_smp_br *smp, uint8_t status)
 			bt_keys_store(keys);
 		}
 
-		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
-						  next, node) {
+		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 			if (listener->pairing_complete) {
-				listener->pairing_complete(smp->chan.chan.conn,
-							   bond_flag);
+				listener->pairing_complete(smp->chan.chan.conn, bond_flag);
 			}
 		}
 	}
@@ -876,8 +848,7 @@ static void smp_br_timeout(struct k_work *work)
 	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
 }
 
-static void smp_br_send(struct bt_smp_br *smp, struct net_buf *buf,
-			bt_conn_tx_cb_t cb)
+static void smp_br_send(struct bt_smp_br *smp, struct net_buf *buf, bt_conn_tx_cb_t cb)
 {
 	int err = bt_l2cap_br_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_BR_SMP, buf, cb, NULL);
 
@@ -939,7 +910,7 @@ static void smp_br_init(struct bt_smp_br *smp)
 static void smp_br_derive_ltk(struct bt_smp_br *smp)
 {
 	/* constants as specified in Core Spec Vol.3 Part H 2.4.2.5 */
-	static const uint8_t brle[4] = { 0x65, 0x6c, 0x72, 0x62 };
+	static const uint8_t brle[4] = {0x65, 0x6c, 0x72, 0x62};
 	struct bt_conn *conn = smp->chan.chan.conn;
 	struct bt_keys_link_key *link_key = conn->br.link_key;
 	struct bt_keys *keys;
@@ -971,10 +942,8 @@ static void smp_br_derive_ltk(struct bt_smp_br *smp)
 
 	if (atomic_test_bit(smp->flags, SMP_FLAG_CT2)) {
 		/* constants as specified in Core Spec Vol.3 Part H 2.4.2.5 */
-		static const uint8_t salt[16] = { 0x32, 0x70, 0x6d, 0x74,
-					       0x00, 0x00, 0x00, 0x00,
-					       0x00, 0x00, 0x00, 0x00,
-					       0x00, 0x00, 0x00, 0x00 };
+		static const uint8_t salt[16] = {0x32, 0x70, 0x6d, 0x74, 0x00, 0x00, 0x00, 0x00,
+						 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
 		if (bt_crypto_h7(salt, link_key->val, ilk)) {
 			bt_keys_link_key_clear(link_key);
@@ -982,7 +951,7 @@ static void smp_br_derive_ltk(struct bt_smp_br *smp)
 		}
 	} else {
 		/* constants as specified in Core Spec Vol.3 Part H 2.4.2.5 */
-		static const uint8_t tmp2[4] = { 0x32, 0x70, 0x6d, 0x74 };
+		static const uint8_t tmp2[4] = {0x32, 0x70, 0x6d, 0x74};
 
 		if (bt_crypto_h6(link_key->val, tmp2, ilk)) {
 			bt_keys_clear(keys);
@@ -1008,8 +977,7 @@ static void smp_br_derive_ltk(struct bt_smp_br *smp)
 	LOG_DBG("LTK derived from LinkKey");
 }
 
-static struct net_buf *smp_br_create_pdu(struct bt_smp_br *smp, uint8_t op,
-					 size_t len)
+static struct net_buf *smp_br_create_pdu(struct bt_smp_br *smp, uint8_t op, size_t len)
 {
 	struct bt_smp_hdr *hdr;
 	struct net_buf *buf;
@@ -1067,8 +1035,7 @@ static void smp_br_distribute_keys(struct bt_smp_br *smp)
 
 		smp->local_dist &= ~BT_SMP_DIST_ID_KEY;
 
-		buf = smp_br_create_pdu(smp, BT_SMP_CMD_IDENT_INFO,
-					sizeof(*id_info));
+		buf = smp_br_create_pdu(smp, BT_SMP_CMD_IDENT_INFO, sizeof(*id_info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Ident Info buffer");
 			return;
@@ -1079,8 +1046,7 @@ static void smp_br_distribute_keys(struct bt_smp_br *smp)
 
 		smp_br_send(smp, buf, NULL);
 
-		buf = smp_br_create_pdu(smp, BT_SMP_CMD_IDENT_ADDR_INFO,
-				     sizeof(*id_addr_info));
+		buf = smp_br_create_pdu(smp, BT_SMP_CMD_IDENT_ADDR_INFO, sizeof(*id_addr_info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Ident Addr Info buffer");
 			return;
@@ -1100,8 +1066,7 @@ static void smp_br_distribute_keys(struct bt_smp_br *smp)
 
 		smp->local_dist &= ~BT_SMP_DIST_SIGN;
 
-		buf = smp_br_create_pdu(smp, BT_SMP_CMD_SIGNING_INFO,
-					sizeof(*info));
+		buf = smp_br_create_pdu(smp, BT_SMP_CMD_SIGNING_INFO, sizeof(*info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Signing Info buffer");
 			return;
@@ -1131,8 +1096,7 @@ static bool smp_br_pairing_allowed(struct bt_smp_br *smp)
 		return true;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP_FORCE_BREDR) &&
-	    smp->chan.chan.conn->encrypt == 0x01) {
+	if (IS_ENABLED(CONFIG_BT_SMP_FORCE_BREDR) && smp->chan.chan.conn->encrypt == 0x01) {
 		LOG_WRN("Allowing BR/EDR SMP with P-192 key");
 		return true;
 	}
@@ -1150,8 +1114,8 @@ static uint8_t smp_br_pairing_req(struct bt_smp_br *smp, struct net_buf *buf)
 
 	LOG_DBG("req: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		req->io_capability, req->oob_flag, req->auth_req,
-		req->max_key_size, req->init_key_dist, req->resp_key_dist);
+		req->io_capability, req->oob_flag, req->auth_req, req->max_key_size,
+		req->init_key_dist, req->resp_key_dist);
 
 	/*
 	 * If a Pairing Request is received over the BR/EDR transport when
@@ -1202,22 +1166,20 @@ static uint8_t smp_br_pairing_req(struct bt_smp_br *smp, struct net_buf *buf)
 
 	LOG_DBG("rsp: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		rsp->io_capability, rsp->oob_flag, rsp->auth_req,
-		rsp->max_key_size, rsp->init_key_dist, rsp->resp_key_dist);
+		rsp->io_capability, rsp->oob_flag, rsp->auth_req, rsp->max_key_size,
+		rsp->init_key_dist, rsp->resp_key_dist);
 
 	smp_br_send(smp, rsp_buf, NULL);
 
 	atomic_set_bit(smp->flags, SMP_FLAG_PAIRING);
 
 	/* If CT2 bit is set both side, set CT2 flag */
-	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
-	    (req->auth_req & BT_SMP_AUTH_CT2)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_CT2) && (req->auth_req & BT_SMP_AUTH_CT2)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
 	}
 
 	/* derive LTK if requested and clear distribution bits */
-	if ((smp->local_dist & BT_SMP_DIST_ENC_KEY) &&
-	    (smp->remote_dist & BT_SMP_DIST_ENC_KEY)) {
+	if ((smp->local_dist & BT_SMP_DIST_ENC_KEY) && (smp->remote_dist & BT_SMP_DIST_ENC_KEY)) {
 		smp_br_derive_ltk(smp);
 	}
 	smp->local_dist &= ~BT_SMP_DIST_ENC_KEY;
@@ -1248,8 +1210,8 @@ static uint8_t smp_br_pairing_rsp(struct bt_smp_br *smp, struct net_buf *buf)
 
 	LOG_DBG("rsp: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		rsp->io_capability, rsp->oob_flag, rsp->auth_req,
-		rsp->max_key_size, rsp->init_key_dist, rsp->resp_key_dist);
+		rsp->io_capability, rsp->oob_flag, rsp->auth_req, rsp->max_key_size,
+		rsp->init_key_dist, rsp->resp_key_dist);
 
 	max_key_size = bt_conn_enc_key_size(conn);
 	if (!max_key_size) {
@@ -1284,8 +1246,7 @@ static uint8_t smp_br_pairing_rsp(struct bt_smp_br *smp, struct net_buf *buf)
 	}
 
 	/* derive LTK if requested and clear distribution bits */
-	if ((smp->local_dist & BT_SMP_DIST_ENC_KEY) &&
-	    (smp->remote_dist & BT_SMP_DIST_ENC_KEY)) {
+	if ((smp->local_dist & BT_SMP_DIST_ENC_KEY) && (smp->remote_dist & BT_SMP_DIST_ENC_KEY)) {
 		smp_br_derive_ltk(smp);
 	}
 	smp->local_dist &= ~BT_SMP_DIST_ENC_KEY;
@@ -1350,8 +1311,7 @@ static uint8_t smp_br_ident_info(struct bt_smp_br *smp, struct net_buf *buf)
 	return 0;
 }
 
-static uint8_t smp_br_ident_addr_info(struct bt_smp_br *smp,
-				      struct net_buf *buf)
+static uint8_t smp_br_ident_addr_info(struct bt_smp_br *smp, struct net_buf *buf)
 {
 	struct bt_conn *conn = smp->chan.chan.conn;
 	struct bt_smp_ident_addr_info *req = (void *)buf->data;
@@ -1436,20 +1396,20 @@ static uint8_t smp_br_signing_info(struct bt_smp_br *smp, struct net_buf *buf)
 #endif /* CONFIG_BT_SIGNING */
 
 static const struct {
-	uint8_t  (*func)(struct bt_smp_br *smp, struct net_buf *buf);
-	uint8_t  expect_len;
+	uint8_t (*func)(struct bt_smp_br *smp, struct net_buf *buf);
+	uint8_t expect_len;
 } br_handlers[] = {
-	{ }, /* No op-code defined for 0x00 */
-	{ smp_br_pairing_req,      sizeof(struct bt_smp_pairing) },
-	{ smp_br_pairing_rsp,      sizeof(struct bt_smp_pairing) },
-	{ }, /* pairing confirm not used over BR/EDR */
-	{ }, /* pairing random not used over BR/EDR */
-	{ smp_br_pairing_failed,   sizeof(struct bt_smp_pairing_fail) },
-	{ }, /* encrypt info not used over BR/EDR */
-	{ }, /* central ident not used over BR/EDR */
-	{ smp_br_ident_info,       sizeof(struct bt_smp_ident_info) },
-	{ smp_br_ident_addr_info,  sizeof(struct bt_smp_ident_addr_info) },
-	{ smp_br_signing_info,     sizeof(struct bt_smp_signing_info) },
+	{}, /* No op-code defined for 0x00 */
+	{smp_br_pairing_req, sizeof(struct bt_smp_pairing)},
+	{smp_br_pairing_rsp, sizeof(struct bt_smp_pairing)},
+	{}, /* pairing confirm not used over BR/EDR */
+	{}, /* pairing random not used over BR/EDR */
+	{smp_br_pairing_failed, sizeof(struct bt_smp_pairing_fail)},
+	{}, /* encrypt info not used over BR/EDR */
+	{}, /* central ident not used over BR/EDR */
+	{smp_br_ident_info, sizeof(struct bt_smp_ident_info)},
+	{smp_br_ident_addr_info, sizeof(struct bt_smp_ident_addr_info)},
+	{smp_br_signing_info, sizeof(struct bt_smp_signing_info)},
 	/* security request not used over BR/EDR */
 	/* public key not used over BR/EDR */
 	/* DHKey check not used over BR/EDR */
@@ -1475,8 +1435,7 @@ static int smp_br_error(struct bt_smp_br *smp, uint8_t reason)
 	 * SMP timer is not restarted for PairingFailed so don't use
 	 * smp_br_send
 	 */
-	if (bt_l2cap_br_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_BR_SMP, buf,
-				NULL, NULL)) {
+	if (bt_l2cap_br_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_BR_SMP, buf, NULL, NULL)) {
 		net_buf_unref(buf);
 	}
 
@@ -1507,8 +1466,7 @@ static int bt_smp_br_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
 		return 0;
 	}
 
-	if (hdr->code >= ARRAY_SIZE(br_handlers) ||
-	    !br_handlers[hdr->code].func) {
+	if (hdr->code >= ARRAY_SIZE(br_handlers) || !br_handlers[hdr->code].func) {
 		LOG_WRN("Unhandled SMP code 0x%02x", hdr->code);
 		smp_br_error(smp, BT_SMP_ERR_CMD_NOTSUPP);
 		return 0;
@@ -1695,8 +1653,7 @@ static void smp_reset(struct bt_smp *smp)
 	smp->method = JUST_WORKS;
 	atomic_set(smp->allowed_cmds, 0);
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SECURITY_REQUEST);
 		return;
 	}
@@ -1766,8 +1723,7 @@ static void smp_pairing_complete(struct bt_smp *smp, uint8_t status)
 			bt_keys_store(conn->le.keys);
 		}
 
-		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
-						  next, node) {
+		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 			if (listener->pairing_complete) {
 				listener->pairing_complete(conn, bond_flag);
 			}
@@ -1779,17 +1735,14 @@ static void smp_pairing_complete(struct bt_smp *smp, uint8_t status)
 		 * keys already existed before the pairing procedure or the
 		 * pairing failed during key distribution.
 		 */
-		if (conn->le.keys &&
-		    (!conn->le.keys->enc_size ||
-		     atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR))) {
+		if (conn->le.keys && (!conn->le.keys->enc_size ||
+				      atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR))) {
 			bt_keys_clear(conn->le.keys);
 			conn->le.keys = NULL;
 		}
 
 		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
-			bt_conn_security_changed(conn,
-						 hci_err_get(security_err),
-						 security_err);
+			bt_conn_security_changed(conn, hci_err_get(security_err), security_err);
 		}
 
 		/* Check SMP_FLAG_PAIRING as bt_conn_security_changed may
@@ -1798,9 +1751,7 @@ static void smp_pairing_complete(struct bt_smp *smp, uint8_t status)
 		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
 			struct bt_conn_auth_info_cb *listener, *next;
 
-			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
-							  listener, next,
-							  node) {
+			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener, next, node) {
 				if (listener->pairing_failed) {
 					listener->pairing_failed(conn, security_err);
 				}
@@ -1830,8 +1781,7 @@ static void smp_timeout(struct k_work *work)
 	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
 }
 
-static void smp_send(struct bt_smp *smp, struct net_buf *buf,
-		     bt_conn_tx_cb_t cb, void *user_data)
+static void smp_send(struct bt_smp *smp, struct net_buf *buf, bt_conn_tx_cb_t cb, void *user_data)
 {
 	__ASSERT_NO_MSG(user_data == NULL);
 
@@ -1916,9 +1866,8 @@ static uint8_t smp_send_pairing_random(struct bt_smp *smp)
 }
 
 #if !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
-static int smp_c1(const uint8_t k[16], const uint8_t r[16],
-		  const uint8_t preq[7], const uint8_t pres[7],
-		  const bt_addr_le_t *ia, const bt_addr_le_t *ra,
+static int smp_c1(const uint8_t k[16], const uint8_t r[16], const uint8_t preq[7],
+		  const uint8_t pres[7], const bt_addr_le_t *ia, const bt_addr_le_t *ra,
 		  uint8_t enc_data[16])
 {
 	uint8_t p1[16], p2[16];
@@ -2038,8 +1987,7 @@ static void legacy_distribute_keys(struct bt_smp *smp)
 			return;
 		}
 
-		buf = smp_create_pdu(smp, BT_SMP_CMD_ENCRYPT_INFO,
-				     sizeof(*info));
+		buf = smp_create_pdu(smp, BT_SMP_CMD_ENCRYPT_INFO, sizeof(*info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Encrypt Info buffer");
 			return;
@@ -2056,8 +2004,7 @@ static void legacy_distribute_keys(struct bt_smp *smp)
 
 		smp_send(smp, buf, NULL, NULL);
 
-		buf = smp_create_pdu(smp, BT_SMP_CMD_CENTRAL_IDENT,
-				     sizeof(*ident));
+		buf = smp_create_pdu(smp, BT_SMP_CMD_CENTRAL_IDENT, sizeof(*ident));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Central Ident buffer");
 			return;
@@ -2072,12 +2019,9 @@ static void legacy_distribute_keys(struct bt_smp *smp)
 		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 			bt_keys_add_type(keys, BT_KEYS_PERIPH_LTK);
 
-			memcpy(keys->periph_ltk.val, rand.key,
-			       sizeof(keys->periph_ltk.val));
-			memcpy(keys->periph_ltk.rand, rand.rand,
-			       sizeof(keys->periph_ltk.rand));
-			memcpy(keys->periph_ltk.ediv, rand.ediv,
-			       sizeof(keys->periph_ltk.ediv));
+			memcpy(keys->periph_ltk.val, rand.key, sizeof(keys->periph_ltk.val));
+			memcpy(keys->periph_ltk.rand, rand.rand, sizeof(keys->periph_ltk.rand));
+			memcpy(keys->periph_ltk.ediv, rand.ediv, sizeof(keys->periph_ltk.ediv));
 		}
 	}
 }
@@ -2106,8 +2050,7 @@ static uint8_t bt_smp_distribute_keys(struct bt_smp *smp)
 		struct bt_smp_ident_addr_info *id_addr_info;
 		struct net_buf *buf;
 
-		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_INFO,
-				     sizeof(*id_info));
+		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_INFO, sizeof(*id_info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Ident Info buffer");
 			return BT_SMP_ERR_UNSPECIFIED;
@@ -2118,8 +2061,7 @@ static uint8_t bt_smp_distribute_keys(struct bt_smp *smp)
 
 		smp_send(smp, buf, NULL, NULL);
 
-		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_ADDR_INFO,
-				     sizeof(*id_addr_info));
+		buf = smp_create_pdu(smp, BT_SMP_CMD_IDENT_ADDR_INFO, sizeof(*id_addr_info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Ident Addr Info buffer");
 			return BT_SMP_ERR_UNSPECIFIED;
@@ -2137,8 +2079,7 @@ static uint8_t bt_smp_distribute_keys(struct bt_smp *smp)
 		struct bt_smp_signing_info *info;
 		struct net_buf *buf;
 
-		buf = smp_create_pdu(smp, BT_SMP_CMD_SIGNING_INFO,
-				     sizeof(*info));
+		buf = smp_create_pdu(smp, BT_SMP_CMD_SIGNING_INFO, sizeof(*info));
 		if (!buf) {
 			LOG_ERR("Unable to allocate Signing Info buffer");
 			return BT_SMP_ERR_UNSPECIFIED;
@@ -2190,14 +2131,12 @@ static uint8_t smp_pairing_accept_query(struct bt_smp *smp, struct bt_smp_pairin
 	struct bt_conn *conn = smp->chan.chan.conn;
 
 	if (smp_auth_cb && smp_auth_cb->pairing_accept) {
-		const struct bt_conn_pairing_feat feat = {
-			.io_capability = pairing->io_capability,
-			.oob_data_flag = pairing->oob_flag,
-			.auth_req = pairing->auth_req,
-			.max_enc_key_size = pairing->max_key_size,
-			.init_key_dist = pairing->init_key_dist,
-			.resp_key_dist = pairing->resp_key_dist
-		};
+		const struct bt_conn_pairing_feat feat = {.io_capability = pairing->io_capability,
+							  .oob_data_flag = pairing->oob_flag,
+							  .auth_req = pairing->auth_req,
+							  .max_enc_key_size = pairing->max_key_size,
+							  .init_key_dist = pairing->init_key_dist,
+							  .resp_key_dist = pairing->resp_key_dist};
 
 		return smp_err_get(smp_auth_cb->pairing_accept(conn, &feat));
 	}
@@ -2206,8 +2145,7 @@ static uint8_t smp_pairing_accept_query(struct bt_smp *smp, struct bt_smp_pairin
 }
 
 #if !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
-static int smp_s1(const uint8_t k[16], const uint8_t r1[16],
-		  const uint8_t r2[16], uint8_t out[16])
+static int smp_s1(const uint8_t k[16], const uint8_t r1[16], const uint8_t r2[16], uint8_t out[16])
 {
 	/* The most significant 64-bits of r1 are discarded to generate
 	 * r1' and the most significant 64-bits of r2 are discarded to
@@ -2273,10 +2211,9 @@ static uint8_t legacy_request_tk(struct bt_smp *smp)
 	 * Fail if we have keys that are stronger than keys that will be
 	 * distributed in new pairing. This is to avoid replacing authenticated
 	 * keys with unauthenticated ones.
-	  */
+	 */
 	keys = bt_keys_find_addr(conn->id, &conn->le.dst);
-	if (keys && (keys->flags & BT_KEYS_AUTHENTICATED) &&
-	    smp->method == JUST_WORKS) {
+	if (keys && (keys->flags & BT_KEYS_AUTHENTICATED) && smp->method == JUST_WORKS) {
 		LOG_ERR("JustWorks failed, authenticated keys present");
 		return BT_SMP_ERR_UNSPECIFIED;
 	}
@@ -2296,10 +2233,9 @@ static uint8_t legacy_request_tk(struct bt_smp *smp)
 
 		break;
 	case PASSKEY_DISPLAY:
-		if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) &&
-		    fixed_passkey != BT_PASSKEY_INVALID) {
+		if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) && fixed_passkey != BT_PASSKEY_INVALID) {
 			passkey = fixed_passkey;
-		} else  {
+		} else {
 			if (bt_rand(&passkey, sizeof(passkey))) {
 				return BT_SMP_ERR_UNSPECIFIED;
 			}
@@ -2346,8 +2282,8 @@ static uint8_t legacy_send_pairing_confirm(struct bt_smp *smp)
 
 	req = net_buf_add(buf, sizeof(*req));
 
-	if (smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp,
-		   &conn->le.init_addr, &conn->le.resp_addr, req->val)) {
+	if (smp_c1(smp->tk, smp->prnd, smp->preq, smp->prsp, &conn->le.init_addr,
+		   &conn->le.resp_addr, req->val)) {
 		net_buf_unref(buf);
 		return BT_SMP_ERR_UNSPECIFIED;
 	}
@@ -2374,8 +2310,8 @@ static uint8_t legacy_pairing_req(struct bt_smp *smp)
 
 	/* ask for consent if pairing is not due to sending SecReq*/
 	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
-	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
-	    smp_auth_cb && smp_auth_cb->pairing_confirm) {
+	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) && smp_auth_cb &&
+	    smp_auth_cb->pairing_confirm) {
 		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 		smp_auth_cb->pairing_confirm(smp->chan.chan.conn);
 		return 0;
@@ -2396,8 +2332,8 @@ static uint8_t legacy_pairing_random(struct bt_smp *smp)
 	LOG_DBG("");
 
 	/* calculate confirmation */
-	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp,
-		     &conn->le.init_addr, &conn->le.resp_addr, tmp);
+	err = smp_c1(smp->tk, smp->rrnd, smp->preq, smp->prsp, &conn->le.init_addr,
+		     &conn->le.resp_addr, tmp);
 	if (err) {
 		return BT_SMP_ERR_UNSPECIFIED;
 	}
@@ -2409,8 +2345,7 @@ static uint8_t legacy_pairing_random(struct bt_smp *smp)
 		return BT_SMP_ERR_CONFIRM_FAILED;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL) {
 		uint8_t ediv[2], rand[8];
 
 		/* No need to store central STK */
@@ -2432,14 +2367,11 @@ static uint8_t legacy_pairing_random(struct bt_smp *smp)
 
 		if (IS_ENABLED(CONFIG_BT_SMP_USB_HCI_CTLR_WORKAROUND)) {
 			if (smp->remote_dist & BT_SMP_DIST_ENC_KEY) {
-				atomic_set_bit(smp->allowed_cmds,
-					       BT_SMP_CMD_ENCRYPT_INFO);
+				atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_ENCRYPT_INFO);
 			} else if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
-				atomic_set_bit(smp->allowed_cmds,
-					       BT_SMP_CMD_IDENT_INFO);
+				atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
 			} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
-				atomic_set_bit(smp->allowed_cmds,
-					       BT_SMP_CMD_SIGNING_INFO);
+				atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 			}
 		}
 
@@ -2468,16 +2400,14 @@ static uint8_t legacy_pairing_confirm(struct bt_smp *smp)
 {
 	LOG_DBG("");
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 		return legacy_send_pairing_confirm(smp);
 	}
 
 	if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
 		if (!atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_CMD_PAIRING_RANDOM);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 			return legacy_send_pairing_confirm(smp);
 		}
 
@@ -2499,8 +2429,7 @@ static void legacy_user_tk_entry(struct bt_smp *smp)
 		return;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 		return;
 	}
@@ -2570,8 +2499,8 @@ static uint8_t smp_central_ident(struct bt_smp *smp, struct net_buf *buf)
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL && !smp->remote_dist) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL &&
+	    !smp->remote_dist) {
 		err = bt_smp_distribute_keys(smp);
 		if (err) {
 			return err;
@@ -2601,8 +2530,8 @@ static uint8_t legacy_pairing_rsp(struct bt_smp *smp)
 
 	/* ask for consent if this is due to received SecReq */
 	if ((DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
-	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
-	    smp_auth_cb && smp_auth_cb->pairing_confirm) {
+	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) && smp_auth_cb &&
+	    smp_auth_cb->pairing_confirm) {
 		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 		smp_auth_cb->pairing_confirm(smp->chan.chan.conn);
 		return 0;
@@ -2686,7 +2615,7 @@ static uint8_t get_auth(struct bt_smp *smp, uint8_t auth)
 
 	if ((get_io_capa(smp) == BT_SMP_IO_NO_INPUT_OUTPUT) ||
 	    (!IS_ENABLED(CONFIG_BT_SMP_ENFORCE_MITM) &&
-	    (conn->required_sec_level < BT_SECURITY_L3))) {
+	     (conn->required_sec_level < BT_SECURITY_L3))) {
 		auth &= ~(BT_SMP_AUTH_MITM);
 	} else {
 		auth |= BT_SMP_AUTH_MITM;
@@ -2760,7 +2689,8 @@ static bool sec_level_reachable(struct bt_smp *smp)
 		       (smp_auth_cb && smp_auth_cb->oob_data_request);
 	case BT_SECURITY_L4:
 		return (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
-		       (smp_auth_cb && smp_auth_cb->oob_data_request)) && sc_supported;
+			(smp_auth_cb && smp_auth_cb->oob_data_request)) &&
+		       sc_supported;
 	default:
 		return false;
 	}
@@ -2793,8 +2723,7 @@ bool bt_smp_request_ltk(struct bt_conn *conn, uint64_t rand, uint16_t ediv, uint
 	 * Both legacy STK and LE SC LTK have rand and ediv equal to zero.
 	 * If pairing is in progress use the TK for encryption.
 	 */
-	if (ediv == 0U && rand == 0U &&
-	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
+	if (ediv == 0U && rand == 0U && atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
 	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
 		enc_size = get_encryption_key_size(smp);
 
@@ -2804,8 +2733,7 @@ bool bt_smp_request_ltk(struct bt_conn *conn, uint64_t rand, uint16_t ediv, uint
 		 */
 		memcpy(ltk, smp->tk, enc_size);
 		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
-			(void)memset(ltk + enc_size, 0,
-				     BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
+			(void)memset(ltk + enc_size, 0, BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
 		}
 
 		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
@@ -2813,22 +2741,18 @@ bool bt_smp_request_ltk(struct bt_conn *conn, uint64_t rand, uint16_t ediv, uint
 	}
 
 	if (!conn->le.keys) {
-		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
-					     &conn->le.dst);
+		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id, &conn->le.dst);
 		if (!conn->le.keys) {
-			conn->le.keys = bt_keys_find(BT_KEYS_PERIPH_LTK,
-						     conn->id, &conn->le.dst);
+			conn->le.keys = bt_keys_find(BT_KEYS_PERIPH_LTK, conn->id, &conn->le.dst);
 		}
 	}
 
-	if (ediv == 0U && rand == 0U &&
-	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
+	if (ediv == 0U && rand == 0U && conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
 		enc_size = conn->le.keys->enc_size;
 
 		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
 		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
-			(void)memset(ltk + enc_size, 0,
-				     BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
+			(void)memset(ltk + enc_size, 0, BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
 		}
 
 		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
@@ -2843,8 +2767,7 @@ bool bt_smp_request_ltk(struct bt_conn *conn, uint64_t rand, uint16_t ediv, uint
 
 		memcpy(ltk, conn->le.keys->periph_ltk.val, enc_size);
 		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
-			(void)memset(ltk + enc_size, 0,
-				     BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
+			(void)memset(ltk + enc_size, 0, BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
 		}
 
 		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
@@ -2908,8 +2831,7 @@ static int smp_send_security_req(struct bt_conn *conn)
 		return -ENOBUFS;
 	}
 
-	req_buf = smp_create_pdu(smp, BT_SMP_CMD_SECURITY_REQUEST,
-				 sizeof(*req));
+	req_buf = smp_create_pdu(smp, BT_SMP_CMD_SECURITY_REQUEST, sizeof(*req));
 	if (!req_buf) {
 		return -ENOBUFS;
 	}
@@ -2941,8 +2863,8 @@ static uint8_t smp_pairing_req(struct bt_smp *smp, struct net_buf *buf)
 
 	LOG_DBG("req: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		req->io_capability, req->oob_flag, req->auth_req,
-		req->max_key_size, req->init_key_dist, req->resp_key_dist);
+		req->io_capability, req->oob_flag, req->auth_req, req->max_key_size,
+		req->init_key_dist, req->resp_key_dist);
 
 	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
 	    (req->max_key_size < BT_SMP_MIN_ENC_KEY_SIZE)) {
@@ -2982,8 +2904,7 @@ static uint8_t smp_pairing_req(struct bt_smp *smp, struct net_buf *buf)
 	rsp->init_key_dist = (req->init_key_dist & RECV_KEYS);
 	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
 
-	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
-	    (req->auth_req & BT_SMP_AUTH_SC)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_SC) && (req->auth_req & BT_SMP_AUTH_SC)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_SC);
 
 		rsp->init_key_dist &= RECV_KEYS_SC;
@@ -2991,20 +2912,16 @@ static uint8_t smp_pairing_req(struct bt_smp *smp, struct net_buf *buf)
 	}
 
 	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
-		rsp->oob_flag = sc_oobd_present ? BT_SMP_OOB_PRESENT :
-				BT_SMP_OOB_NOT_PRESENT;
+		rsp->oob_flag = sc_oobd_present ? BT_SMP_OOB_PRESENT : BT_SMP_OOB_NOT_PRESENT;
 	} else {
-		rsp->oob_flag = legacy_oobd_present ? BT_SMP_OOB_PRESENT :
-				BT_SMP_OOB_NOT_PRESENT;
+		rsp->oob_flag = legacy_oobd_present ? BT_SMP_OOB_PRESENT : BT_SMP_OOB_NOT_PRESENT;
 	}
 
-	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
-	    (req->auth_req & BT_SMP_AUTH_CT2)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_CT2) && (req->auth_req & BT_SMP_AUTH_CT2)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
 	}
 
-	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
-	    (req->auth_req & BT_SMP_AUTH_BONDING)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) && (req->auth_req & BT_SMP_AUTH_BONDING)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
 	} else if (IS_ENABLED(CONFIG_BT_BONDING_REQUIRED)) {
 		/* Reject pairing req if not both intend to bond */
@@ -3055,8 +2972,8 @@ static uint8_t smp_pairing_req(struct bt_smp *smp, struct net_buf *buf)
 
 	if (!IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) &&
 	    (DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
-	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
-	    smp_auth_cb && smp_auth_cb->pairing_confirm) {
+	    !atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) && smp_auth_cb &&
+	    smp_auth_cb->pairing_confirm) {
 		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 		smp_auth_cb->pairing_confirm(conn);
 		return 0;
@@ -3066,8 +2983,8 @@ static uint8_t smp_pairing_req(struct bt_smp *smp, struct net_buf *buf)
 
 	LOG_DBG("rsp: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		rsp->io_capability, rsp->oob_flag, rsp->auth_req,
-		rsp->max_key_size, rsp->init_key_dist, rsp->resp_key_dist);
+		rsp->io_capability, rsp->oob_flag, rsp->auth_req, rsp->max_key_size,
+		rsp->init_key_dist, rsp->resp_key_dist);
 
 	return send_pairing_rsp(smp);
 }
@@ -3168,8 +3085,8 @@ static int smp_send_pairing_req(struct bt_conn *conn)
 	 * set OOB flag if any OOB data is present and assume to peer device
 	 * provides OOB data that will match it's pairing type.
 	 */
-	req->oob_flag = (legacy_oobd_present || sc_oobd_present) ?
-				BT_SMP_OOB_PRESENT : BT_SMP_OOB_NOT_PRESENT;
+	req->oob_flag = (legacy_oobd_present || sc_oobd_present) ? BT_SMP_OOB_PRESENT
+								 : BT_SMP_OOB_NOT_PRESENT;
 
 	req->max_key_size = BT_SMP_MAX_ENC_KEY_SIZE;
 
@@ -3190,8 +3107,8 @@ static int smp_send_pairing_req(struct bt_conn *conn)
 
 	LOG_DBG("req: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		req->io_capability, req->oob_flag, req->auth_req,
-		req->max_key_size, req->init_key_dist, req->resp_key_dist);
+		req->io_capability, req->oob_flag, req->auth_req, req->max_key_size,
+		req->init_key_dist, req->resp_key_dist);
 
 	smp_send(smp, req_buf, NULL, NULL);
 
@@ -3211,8 +3128,8 @@ static uint8_t smp_pairing_rsp(struct bt_smp *smp, struct net_buf *buf)
 
 	LOG_DBG("rsp: io_capability 0x%02X, oob_flag 0x%02X, auth_req 0x%02X, "
 		"max_key_size 0x%02X, init_key_dist 0x%02X, resp_key_dist 0x%02X",
-		rsp->io_capability, rsp->oob_flag, rsp->auth_req,
-		rsp->max_key_size, rsp->init_key_dist, rsp->resp_key_dist);
+		rsp->io_capability, rsp->oob_flag, rsp->auth_req, rsp->max_key_size,
+		rsp->init_key_dist, rsp->resp_key_dist);
 
 	if ((rsp->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
 	    (rsp->max_key_size < BT_SMP_MIN_ENC_KEY_SIZE)) {
@@ -3226,18 +3143,15 @@ static uint8_t smp_pairing_rsp(struct bt_smp *smp, struct net_buf *buf)
 	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
 	memcpy(smp->prsp + 1, rsp, sizeof(*rsp));
 
-	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
-	    (req->auth_req & BT_SMP_AUTH_SC)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_SC) && (req->auth_req & BT_SMP_AUTH_SC)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_SC);
 	}
 
-	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
-	    (req->auth_req & BT_SMP_AUTH_CT2)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_CT2) && (req->auth_req & BT_SMP_AUTH_CT2)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
 	}
 
-	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
-	    (req->auth_req & BT_SMP_AUTH_BONDING)) {
+	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) && (req->auth_req & BT_SMP_AUTH_BONDING)) {
 		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
 	} else if (IS_ENABLED(CONFIG_BT_BONDING_REQUIRED)) {
 		/* Reject pairing req if not both intend to bond */
@@ -3298,8 +3212,8 @@ static uint8_t smp_pairing_rsp(struct bt_smp *smp, struct net_buf *buf)
 
 	if (!IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) &&
 	    (DISPLAY_FIXED(smp) || smp->method == JUST_WORKS) &&
-	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) &&
-	    smp_auth_cb && smp_auth_cb->pairing_confirm) {
+	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ) && smp_auth_cb &&
+	    smp_auth_cb->pairing_confirm) {
 		atomic_set_bit(smp->flags, SMP_FLAG_USER);
 		smp_auth_cb->pairing_confirm(conn);
 		return 0;
@@ -3332,8 +3246,7 @@ static uint8_t smp_pairing_confirm(struct bt_smp *smp, struct net_buf *buf)
 
 	memcpy(smp->pcnf, req->val, sizeof(smp->pcnf));
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 		return smp_send_pairing_random(smp);
 	}
@@ -3552,7 +3465,7 @@ static uint8_t smp_dhkey_ready(struct bt_smp *smp, const uint8_t *dhkey)
 #endif /* CONFIG_BT_CENTRAL */
 
 #if defined(CONFIG_BT_PERIPHERAL)
-		return  compute_and_check_and_send_periph_dhcheck(smp);
+		return compute_and_check_and_send_periph_dhcheck(smp);
 #endif /* CONFIG_BT_PERIPHERAL */
 	}
 
@@ -3654,31 +3567,27 @@ static bool le_sc_oob_data_rsp_check(struct bt_smp *smp)
 	return ((rsp->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
 }
 
-__maybe_unused static void le_sc_oob_config_set(struct bt_smp *smp,
-						struct bt_conn_oob_info *info)
+__maybe_unused static void le_sc_oob_config_set(struct bt_smp *smp, struct bt_conn_oob_info *info)
 {
 	bool req_oob_present = le_sc_oob_data_req_check(smp);
 	bool rsp_oob_present = le_sc_oob_data_rsp_check(smp);
 	int oob_config = BT_CONN_OOB_NO_DATA;
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
-		oob_config = req_oob_present ? BT_CONN_OOB_REMOTE_ONLY :
-					       BT_CONN_OOB_NO_DATA;
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+		oob_config = req_oob_present ? BT_CONN_OOB_REMOTE_ONLY : BT_CONN_OOB_NO_DATA;
 
 		if (rsp_oob_present) {
-			oob_config = (oob_config == BT_CONN_OOB_REMOTE_ONLY) ?
-				     BT_CONN_OOB_BOTH_PEERS :
-				     BT_CONN_OOB_LOCAL_ONLY;
+			oob_config = (oob_config == BT_CONN_OOB_REMOTE_ONLY)
+					     ? BT_CONN_OOB_BOTH_PEERS
+					     : BT_CONN_OOB_LOCAL_ONLY;
 		}
 	} else if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
-		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
-					       BT_CONN_OOB_NO_DATA;
+		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY : BT_CONN_OOB_NO_DATA;
 
 		if (rsp_oob_present) {
-			oob_config = (oob_config == BT_CONN_OOB_LOCAL_ONLY) ?
-				     BT_CONN_OOB_BOTH_PEERS :
-				     BT_CONN_OOB_REMOTE_ONLY;
+			oob_config = (oob_config == BT_CONN_OOB_LOCAL_ONLY)
+					     ? BT_CONN_OOB_BOTH_PEERS
+					     : BT_CONN_OOB_REMOTE_ONLY;
 		}
 	}
 
@@ -3736,8 +3645,7 @@ static uint8_t smp_pairing_random(struct bt_smp *smp, struct net_buf *buf)
 				return BT_SMP_ERR_UNSPECIFIED;
 			}
 
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_CMD_PAIRING_CONFIRM);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 			return smp_send_pairing_confirm(smp);
 		default:
 			LOG_ERR("Unknown pairing method (%u)", smp->method);
@@ -3773,8 +3681,7 @@ static uint8_t smp_pairing_random(struct bt_smp *smp, struct net_buf *buf)
 			return err;
 		}
 
-		atomic_set_bit(smp->allowed_cmds,
-			       BT_SMP_CMD_PAIRING_CONFIRM);
+		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 		err = smp_send_pairing_random(smp);
 		if (err) {
 			return err;
@@ -3994,8 +3901,7 @@ static uint8_t smp_ident_addr_info(struct bt_smp *smp, struct net_buf *buf)
 					.id_addr = &req->addr,
 				};
 
-				bt_conn_foreach(BT_CONN_TYPE_LE,
-						convert_to_id_on_match,
+				bt_conn_foreach(BT_CONN_TYPE_LE, convert_to_id_on_match,
 						&addr_match);
 				bt_addr_le_copy(&keys->addr, &req->addr);
 
@@ -4013,8 +3919,8 @@ static uint8_t smp_ident_addr_info(struct bt_smp *smp, struct net_buf *buf)
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL && !smp->remote_dist) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL &&
+	    !smp->remote_dist) {
 		err = bt_smp_distribute_keys(smp);
 		if (err) {
 			return err;
@@ -4041,21 +3947,19 @@ static uint8_t smp_signing_info(struct bt_smp *smp, struct net_buf *buf)
 		struct bt_smp_signing_info *req = (void *)buf->data;
 		struct bt_keys *keys;
 
-		keys = bt_keys_get_type(BT_KEYS_REMOTE_CSRK, conn->id,
-					&conn->le.dst);
+		keys = bt_keys_get_type(BT_KEYS_REMOTE_CSRK, conn->id, &conn->le.dst);
 		if (!keys) {
 			LOG_ERR("Unable to get keys for %s", bt_addr_le_str(&conn->le.dst));
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
 
-		memcpy(keys->remote_csrk.val, req->csrk,
-		       sizeof(keys->remote_csrk.val));
+		memcpy(keys->remote_csrk.val, req->csrk, sizeof(keys->remote_csrk.val));
 	}
 
 	smp->remote_dist &= ~BT_SMP_DIST_SIGN;
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL && !smp->remote_dist) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL &&
+	    !smp->remote_dist) {
 		err = bt_smp_distribute_keys(smp);
 		if (err) {
 			return err;
@@ -4108,8 +4012,7 @@ static uint8_t smp_security_request(struct bt_smp *smp, struct net_buf *buf)
 		auth = req->auth_req & BT_SMP_AUTH_MASK;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) &&
-	    !(auth & BT_SMP_AUTH_SC)) {
+	if (IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) && !(auth & BT_SMP_AUTH_SC)) {
 		return BT_SMP_ERR_AUTH_REQUIREMENTS;
 	}
 
@@ -4126,11 +4029,9 @@ static uint8_t smp_security_request(struct bt_smp *smp, struct net_buf *buf)
 			goto pair;
 		}
 	} else {
-		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
-					     &conn->le.dst);
+		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id, &conn->le.dst);
 		if (!conn->le.keys) {
-			conn->le.keys = bt_keys_find(BT_KEYS_LTK, conn->id,
-						     &conn->le.dst);
+			conn->le.keys = bt_keys_find(BT_KEYS_LTK, conn->id, &conn->le.dst);
 		}
 	}
 
@@ -4139,8 +4040,7 @@ static uint8_t smp_security_request(struct bt_smp *smp, struct net_buf *buf)
 	}
 
 	/* if MITM required key must be authenticated */
-	if ((auth & BT_SMP_AUTH_MITM) &&
-	    !(conn->le.keys->flags & BT_KEYS_AUTHENTICATED)) {
+	if ((auth & BT_SMP_AUTH_MITM) && !(conn->le.keys->flags & BT_KEYS_AUTHENTICATED)) {
 		if (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT) {
 			LOG_INF("New auth requirements: 0x%x, repairing", auth);
 			goto pair;
@@ -4151,16 +4051,13 @@ static uint8_t smp_security_request(struct bt_smp *smp, struct net_buf *buf)
 	}
 
 	/* if LE SC required and no p256 key present repair */
-	if ((auth & BT_SMP_AUTH_SC) &&
-	    !(conn->le.keys->keys & BT_KEYS_LTK_P256)) {
+	if ((auth & BT_SMP_AUTH_SC) && !(conn->le.keys->keys & BT_KEYS_LTK_P256)) {
 		LOG_INF("New auth requirements: 0x%x, repairing", auth);
 		goto pair;
 	}
 
-	if (bt_conn_le_start_encryption(conn, conn->le.keys->ltk.rand,
-					conn->le.keys->ltk.ediv,
-					conn->le.keys->ltk.val,
-					conn->le.keys->enc_size) < 0) {
+	if (bt_conn_le_start_encryption(conn, conn->le.keys->ltk.rand, conn->le.keys->ltk.ediv,
+					conn->le.keys->ltk.val, conn->le.keys->enc_size) < 0) {
 		LOG_ERR("Failed to start encryption");
 		return BT_SMP_ERR_UNSPECIFIED;
 	}
@@ -4203,8 +4100,7 @@ __maybe_unused static uint8_t display_passkey(struct bt_smp *smp)
 	struct bt_conn *conn = smp->chan.chan.conn;
 	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
 
-	if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) &&
-	    fixed_passkey != BT_PASSKEY_INVALID) {
+	if (IS_ENABLED(CONFIG_BT_FIXED_PASSKEY) && fixed_passkey != BT_PASSKEY_INVALID) {
 		smp->passkey = fixed_passkey;
 	} else {
 		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
@@ -4316,8 +4212,7 @@ static uint8_t smp_public_key(struct bt_smp *smp, struct net_buf *buf)
 		return BT_SMP_ERR_INVALID_PARAMS;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
 		    memcmp(smp->pkey, sc_public_key, BT_PUB_KEY_COORD_LEN) == 0) {
 			/* Deny public key with identitcal X coordinate unless
@@ -4330,8 +4225,7 @@ static uint8_t smp_public_key(struct bt_smp *smp, struct net_buf *buf)
 		switch (smp->method) {
 		case PASSKEY_CONFIRM:
 		case JUST_WORKS:
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_CMD_PAIRING_CONFIRM);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 			break;
 		case PASSKEY_DISPLAY:
 			err = display_passkey(smp);
@@ -4339,11 +4233,9 @@ static uint8_t smp_public_key(struct bt_smp *smp, struct net_buf *buf)
 				return err;
 			}
 
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_CMD_PAIRING_CONFIRM);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_KEYPRESS_NOTIFICATION);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 
 			err = smp_send_pairing_confirm(smp);
 			if (err) {
@@ -4354,8 +4246,7 @@ static uint8_t smp_public_key(struct bt_smp *smp, struct net_buf *buf)
 			atomic_set_bit(smp->flags, SMP_FLAG_USER);
 			smp_auth_cb->passkey_entry(smp->chan.chan.conn);
 
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_KEYPRESS_NOTIFICATION);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 
 			break;
 		case LE_SC_OOB:
@@ -4375,8 +4266,7 @@ static uint8_t smp_public_key(struct bt_smp *smp, struct net_buf *buf)
 				smp->oobd_local = NULL;
 				smp->oobd_remote = NULL;
 
-				atomic_set_bit(smp->flags,
-					       SMP_FLAG_OOB_PENDING);
+				atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
 				smp_auth_cb->oob_data_request(smp->chan.chan.conn, &info);
 			} else {
 				return BT_SMP_ERR_OOB_NOT_AVAIL;
@@ -4412,8 +4302,7 @@ static uint8_t smp_dhkey_check(struct bt_smp *smp, struct net_buf *buf)
 
 	LOG_DBG("");
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		uint8_t e[16], r[16], enc_size;
 		uint8_t ediv[2], rand[8];
 
@@ -4453,8 +4342,8 @@ static uint8_t smp_dhkey_check(struct bt_smp *smp, struct net_buf *buf)
 		/* Rand and EDiv are 0 */
 		(void)memset(ediv, 0, sizeof(ediv));
 		(void)memset(rand, 0, sizeof(rand));
-		if (bt_conn_le_start_encryption(smp->chan.chan.conn, rand, ediv,
-						smp->tk, enc_size) < 0) {
+		if (bt_conn_le_start_encryption(smp->chan.chan.conn, rand, ediv, smp->tk,
+						enc_size) < 0) {
 			LOG_ERR("Failed to start encryption");
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
@@ -4463,11 +4352,9 @@ static uint8_t smp_dhkey_check(struct bt_smp *smp, struct net_buf *buf)
 
 		if (IS_ENABLED(CONFIG_BT_SMP_USB_HCI_CTLR_WORKAROUND)) {
 			if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
-				atomic_set_bit(smp->allowed_cmds,
-					       BT_SMP_CMD_IDENT_INFO);
+				atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
 			} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
-				atomic_set_bit(smp->allowed_cmds,
-					       BT_SMP_CMD_SIGNING_INFO);
+				atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
 			}
 		}
 
@@ -4514,8 +4401,7 @@ static uint8_t smp_keypress_notif(struct bt_smp *smp, struct net_buf *buf)
 	 */
 	atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
 
-	if (!IN_RANGE(type,
-		      BT_CONN_AUTH_KEYPRESS_ENTRY_STARTED,
+	if (!IN_RANGE(type, BT_CONN_AUTH_KEYPRESS_ENTRY_STARTED,
 		      BT_CONN_AUTH_KEYPRESS_ENTRY_COMPLETED)) {
 		LOG_WRN("Received unknown keypress event type %u. Discarding.", type);
 		return BT_SMP_ERR_INVALID_PARAMS;
@@ -4545,24 +4431,24 @@ static uint8_t smp_keypress_notif(struct bt_smp *smp, struct net_buf *buf)
 #endif
 
 static const struct {
-	uint8_t  (*func)(struct bt_smp *smp, struct net_buf *buf);
-	uint8_t  expect_len;
+	uint8_t (*func)(struct bt_smp *smp, struct net_buf *buf);
+	uint8_t expect_len;
 } handlers[] = {
-	{ }, /* No op-code defined for 0x00 */
-	{ smp_pairing_req,         sizeof(struct bt_smp_pairing) },
-	{ smp_pairing_rsp,         sizeof(struct bt_smp_pairing) },
-	{ smp_pairing_confirm,     sizeof(struct bt_smp_pairing_confirm) },
-	{ smp_pairing_random,      sizeof(struct bt_smp_pairing_random) },
-	{ smp_pairing_failed,      sizeof(struct bt_smp_pairing_fail) },
-	{ smp_encrypt_info,        sizeof(struct bt_smp_encrypt_info) },
-	{ smp_central_ident,       sizeof(struct bt_smp_central_ident) },
-	{ smp_ident_info,          sizeof(struct bt_smp_ident_info) },
-	{ smp_ident_addr_info,     sizeof(struct bt_smp_ident_addr_info) },
-	{ smp_signing_info,        sizeof(struct bt_smp_signing_info) },
-	{ smp_security_request,    sizeof(struct bt_smp_security_request) },
-	{ smp_public_key,          sizeof(struct bt_smp_public_key) },
-	{ smp_dhkey_check,         sizeof(struct bt_smp_dhkey_check) },
-	{ smp_keypress_notif,      sizeof(struct bt_smp_keypress_notif) },
+	{}, /* No op-code defined for 0x00 */
+	{smp_pairing_req, sizeof(struct bt_smp_pairing)},
+	{smp_pairing_rsp, sizeof(struct bt_smp_pairing)},
+	{smp_pairing_confirm, sizeof(struct bt_smp_pairing_confirm)},
+	{smp_pairing_random, sizeof(struct bt_smp_pairing_random)},
+	{smp_pairing_failed, sizeof(struct bt_smp_pairing_fail)},
+	{smp_encrypt_info, sizeof(struct bt_smp_encrypt_info)},
+	{smp_central_ident, sizeof(struct bt_smp_central_ident)},
+	{smp_ident_info, sizeof(struct bt_smp_ident_info)},
+	{smp_ident_addr_info, sizeof(struct bt_smp_ident_addr_info)},
+	{smp_signing_info, sizeof(struct bt_smp_signing_info)},
+	{smp_security_request, sizeof(struct bt_smp_security_request)},
+	{smp_public_key, sizeof(struct bt_smp_public_key)},
+	{smp_dhkey_check, sizeof(struct bt_smp_dhkey_check)},
+	{smp_keypress_notif, sizeof(struct bt_smp_keypress_notif)},
 };
 
 static bool is_in_pairing_procedure(struct bt_smp *smp)
@@ -4663,8 +4549,7 @@ static void bt_smp_pkey_ready(const uint8_t *pkey)
 				smp_error(smp, err);
 			}
 
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_CMD_PUBLIC_KEY);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
 			continue;
 		}
 
@@ -4716,8 +4601,8 @@ static void bt_smp_disconnected(struct bt_l2cap_chan *chan)
 		 * If debug keys were used for pairing remove them.
 		 * No keys indicate no bonding so free keys storage.
 		 */
-		if (!keys->keys || (!IS_ENABLED(CONFIG_BT_STORE_DEBUG_KEYS) &&
-		    (keys->flags & BT_KEYS_DEBUG))) {
+		if (!keys->keys ||
+		    (!IS_ENABLED(CONFIG_BT_STORE_DEBUG_KEYS) && (keys->flags & BT_KEYS_DEBUG))) {
 			bt_keys_clear(keys);
 		}
 	}
@@ -4725,8 +4610,7 @@ static void bt_smp_disconnected(struct bt_l2cap_chan *chan)
 	(void)memset(smp, 0, sizeof(*smp));
 }
 
-static void bt_smp_encrypt_change(struct bt_l2cap_chan *chan,
-				  uint8_t hci_status)
+static void bt_smp_encrypt_change(struct bt_l2cap_chan *chan, uint8_t hci_status)
 {
 	struct bt_smp *smp = CONTAINER_OF(chan, struct bt_smp, chan.chan);
 	struct bt_conn *conn = chan->conn;
@@ -4744,8 +4628,7 @@ static void bt_smp_encrypt_change(struct bt_l2cap_chan *chan,
 
 	if (hci_status) {
 		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
-			uint8_t smp_err = smp_err_get(
-				bt_security_err_get(hci_status));
+			uint8_t smp_err = smp_err_get(bt_security_err_get(hci_status));
 
 			/* Fail as if it happened during key distribution */
 			atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
@@ -4813,10 +4696,8 @@ static void bt_smp_encrypt_change(struct bt_l2cap_chan *chan,
 	 * `smp_id_add_replace` not here, but later. If neither we nor the peer
 	 * are using privacy, there is no need for an entry in the RL.
 	 */
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    IS_ENABLED(CONFIG_BT_PRIVACY) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL &&
-	    !(smp->remote_dist & BT_SMP_DIST_ID_KEY)) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && IS_ENABLED(CONFIG_BT_PRIVACY) &&
+	    conn->role == BT_HCI_ROLE_CENTRAL && !(smp->remote_dist & BT_SMP_DIST_ID_KEY)) {
 		uint8_t smp_err;
 
 		smp_err = smp_id_add_replace(smp, conn->le.keys);
@@ -4828,8 +4709,8 @@ static void bt_smp_encrypt_change(struct bt_l2cap_chan *chan,
 	atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
 
 	/* Peripheral distributes it's keys first */
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_HCI_ROLE_CENTRAL && smp->remote_dist) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_HCI_ROLE_CENTRAL &&
+	    smp->remote_dist) {
 		return;
 	}
 
@@ -4914,8 +4795,7 @@ int bt_smp_sign_verify(struct bt_conn *conn, struct net_buf *buf)
 	LOG_DBG("Sign data len %zu key %s count %u", buf->len - sizeof(sig),
 		bt_hex(keys->remote_csrk.val, 16), keys->remote_csrk.cnt);
 
-	err = smp_sign_buf(keys->remote_csrk.val, buf->data,
-			   buf->len - sizeof(sig));
+	err = smp_sign_buf(keys->remote_csrk.val, buf->data, buf->len - sizeof(sig));
 	if (err) {
 		LOG_ERR("Unable to create signature for %s", bt_addr_le_str(&conn->le.dst));
 		return -EIO;
@@ -4996,7 +4876,7 @@ static int smp_d1(const uint8_t *key, uint16_t d, uint16_t r, uint8_t res[16])
 
 int bt_smp_irk_get(uint8_t *ir, uint8_t *irk)
 {
-	uint8_t invalid_ir[16] = { 0 };
+	uint8_t invalid_ir[16] = {0};
 
 	if (!memcmp(ir, invalid_ir, 16)) {
 		return -EINVAL;
@@ -5010,24 +4890,18 @@ int bt_smp_irk_get(uint8_t *ir, uint8_t *irk)
  * https://tools.ietf.org/html/rfc4493
  * Same mentioned in the Bluetooth Spec.
  */
-static const uint8_t key[] = {
-	0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
-	0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
-};
+static const uint8_t key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
+			      0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
 
-static const uint8_t M[] = {
-	0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
-	0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-	0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
-	0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-	0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
-	0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-	0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
-	0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
-};
+static const uint8_t M[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e,
+			    0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03,
+			    0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51, 0x30,
+			    0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19,
+			    0x1a, 0x0a, 0x52, 0xef, 0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b,
+			    0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};
 
-static int aes_test(const char *prefix, const uint8_t *in_key, const uint8_t *m,
-		    uint16_t len, const uint8_t *mac)
+static int aes_test(const char *prefix, const uint8_t *in_key, const uint8_t *m, uint16_t len,
+		    const uint8_t *mac)
 {
 	uint8_t out[16];
 
@@ -5046,22 +4920,14 @@ static int aes_test(const char *prefix, const uint8_t *in_key, const uint8_t *m,
 
 static int smp_aes_cmac_test(void)
 {
-	uint8_t mac1[] = {
-		0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28,
-		0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46
-	};
-	uint8_t mac2[] = {
-		0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44,
-		0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c
-	};
-	uint8_t mac3[] = {
-		0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30,
-		0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27
-	};
-	uint8_t mac4[] = {
-		0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
-		0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe
-	};
+	uint8_t mac1[] = {0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28,
+			  0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46};
+	uint8_t mac2[] = {0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44,
+			  0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c};
+	uint8_t mac3[] = {0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30,
+			  0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27};
+	uint8_t mac4[] = {0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
+			  0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe};
 	int err;
 
 	err = aes_test("Test aes-cmac0", key, M, 0, mac1);
@@ -5087,8 +4953,8 @@ static int smp_aes_cmac_test(void)
 	return 0;
 }
 
-static int sign_test(const char *prefix, const uint8_t *sign_key, const uint8_t *m,
-		     uint16_t len, const uint8_t *sig)
+static int sign_test(const char *prefix, const uint8_t *sign_key, const uint8_t *m, uint16_t len,
+		     const uint8_t *sig)
 {
 	uint8_t msg[len + sizeof(uint32_t) + 8];
 	uint8_t orig[len + sizeof(uint32_t) + 8];
@@ -5130,22 +4996,14 @@ static int sign_test(const char *prefix, const uint8_t *sign_key, const uint8_t
 
 static int smp_sign_test(void)
 {
-	const uint8_t sig1[] = {
-		0x00, 0x00, 0x00, 0x00, 0xb3, 0xa8, 0x59, 0x41,
-		0x27, 0xeb, 0xc2, 0xc0
-	};
-	const uint8_t sig2[] = {
-		0x00, 0x00, 0x00, 0x00, 0x27, 0x39, 0x74, 0xf4,
-		0x39, 0x2a, 0x23, 0x2a
-	};
-	const uint8_t sig3[] = {
-		0x00, 0x00, 0x00, 0x00, 0xb7, 0xca, 0x94, 0xab,
-		0x87, 0xc7, 0x82, 0x18
-	};
-	const uint8_t sig4[] = {
-		0x00, 0x00, 0x00, 0x00, 0x44, 0xe1, 0xe6, 0xce,
-		0x1d, 0xf5, 0x13, 0x68
-	};
+	const uint8_t sig1[] = {0x00, 0x00, 0x00, 0x00, 0xb3, 0xa8,
+				0x59, 0x41, 0x27, 0xeb, 0xc2, 0xc0};
+	const uint8_t sig2[] = {0x00, 0x00, 0x00, 0x00, 0x27, 0x39,
+				0x74, 0xf4, 0x39, 0x2a, 0x23, 0x2a};
+	const uint8_t sig3[] = {0x00, 0x00, 0x00, 0x00, 0xb7, 0xca,
+				0x94, 0xab, 0x87, 0xc7, 0x82, 0x18};
+	const uint8_t sig4[] = {0x00, 0x00, 0x00, 0x00, 0x44, 0xe1,
+				0xe6, 0xce, 0x1d, 0xf5, 0x13, 0x68};
 	uint8_t key_s[16];
 	int err;
 
@@ -5177,19 +5035,17 @@ static int smp_sign_test(void)
 
 static int smp_f4_test(void)
 {
-	uint8_t u[32] = { 0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,
-			  0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,
-			  0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,
-			  0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20 };
-	uint8_t v[32] = { 0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b,
-			  0xfb, 0x7c, 0x9d, 0xf1, 0xc2, 0x9a, 0xcb, 0x59,
-			  0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc, 0x0a, 0x90,
-			  0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55 };
-	uint8_t x[16] = { 0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
-			  0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };
+	uint8_t u[32] = {0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc, 0xdb, 0xfd, 0xf4,
+			 0xac, 0x11, 0x91, 0xf4, 0xef, 0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83,
+			 0x2c, 0x5e, 0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20};
+	uint8_t v[32] = {0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b, 0xfb, 0x7c, 0x9d,
+			 0xf1, 0xc2, 0x9a, 0xcb, 0x59, 0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc,
+			 0x0a, 0x90, 0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55};
+	uint8_t x[16] = {0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
+			 0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5};
 	uint8_t z = 0x00;
-	uint8_t exp[16] = { 0x2d, 0x87, 0x74, 0xa9, 0xbe, 0xa1, 0xed, 0xf1,
-			    0x1c, 0xbd, 0xa9, 0x07, 0xf1, 0x16, 0xc9, 0xf2 };
+	uint8_t exp[16] = {0x2d, 0x87, 0x74, 0xa9, 0xbe, 0xa1, 0xed, 0xf1,
+			   0x1c, 0xbd, 0xa9, 0x07, 0xf1, 0x16, 0xc9, 0xf2};
 	uint8_t res[16];
 	int err;
 
@@ -5207,24 +5063,19 @@ static int smp_f4_test(void)
 
 static int smp_f5_test(void)
 {
-	uint8_t w[32] = { 0x98, 0xa6, 0xbf, 0x73, 0xf3, 0x34, 0x8d, 0x86,
-			  0xf1, 0x66, 0xf8, 0xb4, 0x13, 0x6b, 0x79, 0x99,
-			  0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,
-			  0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec };
-	uint8_t n1[16] = { 0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
-			   0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };
-	uint8_t n2[16] = { 0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,
-			   0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };
-	bt_addr_le_t a1 = { .type = 0x00,
-			    .a.val = { 0xce, 0xbf, 0x37, 0x37, 0x12, 0x56 } };
-	bt_addr_le_t a2 = { .type = 0x00,
-			    .a.val = {0xc1, 0xcf, 0x2d, 0x70, 0x13, 0xa7 } };
-	uint8_t exp_ltk[16] = { 0x38, 0x0a, 0x75, 0x94, 0xb5, 0x22, 0x05,
-				0x98, 0x23, 0xcd, 0xd7, 0x69, 0x11, 0x79,
-				0x86, 0x69 };
-	uint8_t exp_mackey[16] = { 0x20, 0x6e, 0x63, 0xce, 0x20, 0x6a, 0x3f,
-				   0xfd, 0x02, 0x4a, 0x08, 0xa1, 0x76, 0xf1,
-				   0x65, 0x29 };
+	uint8_t w[32] = {0x98, 0xa6, 0xbf, 0x73, 0xf3, 0x34, 0x8d, 0x86, 0xf1, 0x66, 0xf8,
+			 0xb4, 0x13, 0x6b, 0x79, 0x99, 0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10,
+			 0x10, 0x34, 0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec};
+	uint8_t n1[16] = {0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
+			  0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5};
+	uint8_t n2[16] = {0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,
+			  0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6};
+	bt_addr_le_t a1 = {.type = 0x00, .a.val = {0xce, 0xbf, 0x37, 0x37, 0x12, 0x56}};
+	bt_addr_le_t a2 = {.type = 0x00, .a.val = {0xc1, 0xcf, 0x2d, 0x70, 0x13, 0xa7}};
+	uint8_t exp_ltk[16] = {0x38, 0x0a, 0x75, 0x94, 0xb5, 0x22, 0x05, 0x98,
+			       0x23, 0xcd, 0xd7, 0x69, 0x11, 0x79, 0x86, 0x69};
+	uint8_t exp_mackey[16] = {0x20, 0x6e, 0x63, 0xce, 0x20, 0x6a, 0x3f, 0xfd,
+				  0x02, 0x4a, 0x08, 0xa1, 0x76, 0xf1, 0x65, 0x29};
 	uint8_t mackey[16], ltk[16];
 	int err;
 
@@ -5242,21 +5093,19 @@ static int smp_f5_test(void)
 
 static int smp_f6_test(void)
 {
-	uint8_t w[16] = { 0x20, 0x6e, 0x63, 0xce, 0x20, 0x6a, 0x3f, 0xfd,
-			  0x02, 0x4a, 0x08, 0xa1, 0x76, 0xf1, 0x65, 0x29 };
-	uint8_t n1[16] = { 0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
-			   0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };
-	uint8_t n2[16] = { 0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,
-			   0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };
-	uint8_t r[16] = { 0xc8, 0x0f, 0x2d, 0x0c, 0xd2, 0x42, 0xda, 0x08,
-			  0x54, 0xbb, 0x53, 0xb4, 0x3b, 0x34, 0xa3, 0x12 };
-	uint8_t io_cap[3] = { 0x02, 0x01, 0x01 };
-	bt_addr_le_t a1 = { .type = 0x00,
-			    .a.val = { 0xce, 0xbf, 0x37, 0x37, 0x12, 0x56 } };
-	bt_addr_le_t a2 = { .type = 0x00,
-			    .a.val = {0xc1, 0xcf, 0x2d, 0x70, 0x13, 0xa7 } };
-	uint8_t exp[16] = { 0x61, 0x8f, 0x95, 0xda, 0x09, 0x0b, 0x6c, 0xd2,
-			    0xc5, 0xe8, 0xd0, 0x9c, 0x98, 0x73, 0xc4, 0xe3 };
+	uint8_t w[16] = {0x20, 0x6e, 0x63, 0xce, 0x20, 0x6a, 0x3f, 0xfd,
+			 0x02, 0x4a, 0x08, 0xa1, 0x76, 0xf1, 0x65, 0x29};
+	uint8_t n1[16] = {0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
+			  0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5};
+	uint8_t n2[16] = {0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,
+			  0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6};
+	uint8_t r[16] = {0xc8, 0x0f, 0x2d, 0x0c, 0xd2, 0x42, 0xda, 0x08,
+			 0x54, 0xbb, 0x53, 0xb4, 0x3b, 0x34, 0xa3, 0x12};
+	uint8_t io_cap[3] = {0x02, 0x01, 0x01};
+	bt_addr_le_t a1 = {.type = 0x00, .a.val = {0xce, 0xbf, 0x37, 0x37, 0x12, 0x56}};
+	bt_addr_le_t a2 = {.type = 0x00, .a.val = {0xc1, 0xcf, 0x2d, 0x70, 0x13, 0xa7}};
+	uint8_t exp[16] = {0x61, 0x8f, 0x95, 0xda, 0x09, 0x0b, 0x6c, 0xd2,
+			   0xc5, 0xe8, 0xd0, 0x9c, 0x98, 0x73, 0xc4, 0xe3};
 	uint8_t res[16];
 	int err;
 
@@ -5274,18 +5123,16 @@ static int smp_f6_test(void)
 
 static int smp_g2_test(void)
 {
-	uint8_t u[32] = { 0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc,
-			  0xdb, 0xfd, 0xf4, 0xac, 0x11, 0x91, 0xf4, 0xef,
-			  0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83, 0x2c, 0x5e,
-			  0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20 };
-	uint8_t v[32] = { 0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b,
-			  0xfb, 0x7c, 0x9d, 0xf1, 0xc2, 0x9a, 0xcb, 0x59,
-			  0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc, 0x0a, 0x90,
-			  0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55 };
-	uint8_t x[16] = { 0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
-			  0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5 };
-	uint8_t y[16] = { 0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,
-			  0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6 };
+	uint8_t u[32] = {0xe6, 0x9d, 0x35, 0x0e, 0x48, 0x01, 0x03, 0xcc, 0xdb, 0xfd, 0xf4,
+			 0xac, 0x11, 0x91, 0xf4, 0xef, 0xb9, 0xa5, 0xf9, 0xe9, 0xa7, 0x83,
+			 0x2c, 0x5e, 0x2c, 0xbe, 0x97, 0xf2, 0xd2, 0x03, 0xb0, 0x20};
+	uint8_t v[32] = {0xfd, 0xc5, 0x7f, 0xf4, 0x49, 0xdd, 0x4f, 0x6b, 0xfb, 0x7c, 0x9d,
+			 0xf1, 0xc2, 0x9a, 0xcb, 0x59, 0x2a, 0xe7, 0xd4, 0xee, 0xfb, 0xfc,
+			 0x0a, 0x90, 0x9a, 0xbb, 0xf6, 0x32, 0x3d, 0x8b, 0x18, 0x55};
+	uint8_t x[16] = {0xab, 0xae, 0x2b, 0x71, 0xec, 0xb2, 0xff, 0xff,
+			 0x3e, 0x73, 0x77, 0xd1, 0x54, 0x84, 0xcb, 0xd5};
+	uint8_t y[16] = {0xcf, 0xc4, 0x3d, 0xff, 0xf7, 0x83, 0x65, 0x21,
+			 0x6e, 0x5f, 0xa7, 0x25, 0xcc, 0xe7, 0xe8, 0xa6};
 	uint32_t exp_val = 0x2f9ed5ba % 1000000;
 	uint32_t val;
 	int err;
@@ -5305,11 +5152,11 @@ static int smp_g2_test(void)
 #if defined(CONFIG_BT_CLASSIC)
 static int smp_h6_test(void)
 {
-	uint8_t w[16] = { 0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,
-			  0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec };
-	uint8_t key_id[4] = { 0x72, 0x62, 0x65, 0x6c };
-	uint8_t exp_res[16] = { 0x99, 0x63, 0xb1, 0x80, 0xe2, 0xa9, 0xd3, 0xe8,
-				0x1c, 0xc9, 0x6d, 0xe7, 0x02, 0xe1, 0x9a, 0x2d};
+	uint8_t w[16] = {0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,
+			 0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec};
+	uint8_t key_id[4] = {0x72, 0x62, 0x65, 0x6c};
+	uint8_t exp_res[16] = {0x99, 0x63, 0xb1, 0x80, 0xe2, 0xa9, 0xd3, 0xe8,
+			       0x1c, 0xc9, 0x6d, 0xe7, 0x02, 0xe1, 0x9a, 0x2d};
 	uint8_t res[16];
 	int err;
 
@@ -5327,12 +5174,12 @@ static int smp_h6_test(void)
 
 static int smp_h7_test(void)
 {
-	uint8_t salt[16] = { 0x31, 0x70, 0x6d, 0x74, 0x00, 0x00, 0x00, 0x00,
-			     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-	uint8_t w[16] = { 0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,
-			  0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec };
-	uint8_t exp_res[16] = { 0x11, 0x70, 0xa5, 0x75, 0x2a, 0x8c, 0x99, 0xd2,
-				0xec, 0xc0, 0xa3, 0xc6, 0x97, 0x35, 0x17, 0xfb};
+	uint8_t salt[16] = {0x31, 0x70, 0x6d, 0x74, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	uint8_t w[16] = {0x9b, 0x7d, 0x39, 0x0a, 0xa6, 0x10, 0x10, 0x34,
+			 0x05, 0xad, 0xc8, 0x57, 0xa3, 0x34, 0x02, 0xec};
+	uint8_t exp_res[16] = {0x11, 0x70, 0xa5, 0x75, 0x2a, 0x8c, 0x99, 0xd2,
+			       0xec, 0xc0, 0xa3, 0xc6, 0x97, 0x35, 0x17, 0xfb};
 	uint8_t res[16];
 	int err;
 
@@ -5516,15 +5363,13 @@ int bt_smp_auth_keypress_notify(struct bt_conn *conn, enum bt_conn_auth_keypress
 		return -EINVAL;
 	}
 
-	CHECKIF(!IN_RANGE(type,
-			  BT_CONN_AUTH_KEYPRESS_ENTRY_STARTED,
+	CHECKIF(!IN_RANGE(type, BT_CONN_AUTH_KEYPRESS_ENTRY_STARTED,
 			  BT_CONN_AUTH_KEYPRESS_ENTRY_COMPLETED)) {
 		LOG_ERR("Refusing to send unknown event type %u", type);
 		return -EINVAL;
 	}
 
-	if (smp->method != PASSKEY_INPUT ||
-	    !atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
+	if (smp->method != PASSKEY_INPUT || !atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
 		LOG_ERR("Refusing to send keypress: Not waiting for passkey input.");
 		return -EINVAL;
 	}
@@ -5556,8 +5401,7 @@ int bt_smp_auth_passkey_entry(struct bt_conn *conn, unsigned int passkey)
 
 	smp->passkey = sys_cpu_to_le32(passkey);
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 		err = smp_send_pairing_confirm(smp);
 		if (err) {
@@ -5567,8 +5411,7 @@ int bt_smp_auth_passkey_entry(struct bt_conn *conn, unsigned int passkey)
 		return 0;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
-	    atomic_test_bit(smp->flags, SMP_FLAG_CFM_DELAYED)) {
+	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && atomic_test_bit(smp->flags, SMP_FLAG_CFM_DELAYED)) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 		err = smp_send_pairing_confirm(smp);
 		if (err) {
@@ -5652,7 +5495,7 @@ int bt_smp_le_oob_set_tk(struct bt_conn *conn, const uint8_t *tk)
 		LOG_INF("Legacy OOB data 0x%s", bt_hex(oob, 16));
 	}
 
-	memcpy(smp->tk, tk, 16*sizeof(uint8_t));
+	memcpy(smp->tk, tk, 16 * sizeof(uint8_t));
 
 	legacy_user_tk_entry(smp);
 
@@ -5689,8 +5532,7 @@ int bt_smp_le_oob_generate_sc_data(struct bt_le_oob_sc_data *le_sc_oob)
 		}
 	}
 
-	err = bt_crypto_f4(sc_public_key, sc_public_key, le_sc_oob->r, 0,
-		     le_sc_oob->c);
+	err = bt_crypto_f4(sc_public_key, sc_public_key, le_sc_oob->r, 0, le_sc_oob->c);
 	if (err) {
 		return err;
 	}
@@ -5705,8 +5547,7 @@ static bool le_sc_oob_data_check(struct bt_smp *smp, bool oobd_local_present,
 	bool req_oob_present = le_sc_oob_data_req_check(smp);
 	bool rsp_oob_present = le_sc_oob_data_rsp_check(smp);
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		if ((req_oob_present != oobd_remote_present) &&
 		    (rsp_oob_present != oobd_local_present)) {
 			return false;
@@ -5740,8 +5581,7 @@ static int le_sc_oob_pairing_continue(struct bt_smp *smp)
 		}
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
 	} else if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
 		atomic_set_bit(smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
@@ -5751,8 +5591,7 @@ static int le_sc_oob_pairing_continue(struct bt_smp *smp)
 	return smp_send_pairing_random(smp);
 }
 
-int bt_smp_le_oob_set_sc_data(struct bt_conn *conn,
-			      const struct bt_le_oob_sc_data *oobd_local,
+int bt_smp_le_oob_set_sc_data(struct bt_conn *conn, const struct bt_le_oob_sc_data *oobd_local,
 			      const struct bt_le_oob_sc_data *oobd_remote)
 {
 	struct bt_smp *smp;
@@ -5762,8 +5601,7 @@ int bt_smp_le_oob_set_sc_data(struct bt_conn *conn,
 		return -EINVAL;
 	}
 
-	if (!le_sc_oob_data_check(smp, (oobd_local != NULL),
-				  (oobd_remote != NULL))) {
+	if (!le_sc_oob_data_check(smp, (oobd_local != NULL), (oobd_remote != NULL))) {
 		return -EINVAL;
 	}
 
@@ -5777,8 +5615,7 @@ int bt_smp_le_oob_set_sc_data(struct bt_conn *conn,
 	return le_sc_oob_pairing_continue(smp);
 }
 
-int bt_smp_le_oob_get_sc_data(struct bt_conn *conn,
-			      const struct bt_le_oob_sc_data **oobd_local,
+int bt_smp_le_oob_get_sc_data(struct bt_conn *conn, const struct bt_le_oob_sc_data **oobd_local,
 			      const struct bt_le_oob_sc_data **oobd_remote)
 {
 	struct bt_smp *smp;
@@ -5850,11 +5687,9 @@ int bt_smp_auth_pairing_confirm(struct bt_conn *conn)
 		return -EINVAL;
 	}
 
-	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
-	    conn->role == BT_CONN_ROLE_CENTRAL) {
+	if (IS_ENABLED(CONFIG_BT_CENTRAL) && conn->role == BT_CONN_ROLE_CENTRAL) {
 		if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
-			atomic_set_bit(smp->allowed_cmds,
-				       BT_SMP_CMD_PAIRING_CONFIRM);
+			atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 			return legacy_send_pairing_confirm(smp);
 		}
 
@@ -5869,8 +5704,7 @@ int bt_smp_auth_pairing_confirm(struct bt_conn *conn)
 
 #if defined(CONFIG_BT_PERIPHERAL)
 	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
-		atomic_set_bit(smp->allowed_cmds,
-			       BT_SMP_CMD_PAIRING_CONFIRM);
+		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
 		return send_pairing_rsp(smp);
 	}
 
@@ -5911,8 +5745,7 @@ int bt_smp_start_security(struct bt_conn *conn)
 {
 	switch (conn->role) {
 #if defined(CONFIG_BT_CENTRAL)
-	case BT_HCI_ROLE_CENTRAL:
-	{
+	case BT_HCI_ROLE_CENTRAL: {
 		int err;
 		struct bt_smp *smp;
 
@@ -5936,10 +5769,8 @@ int bt_smp_start_security(struct bt_conn *conn)
 		}
 
 		/* LE SC LTK and legacy central LTK are stored in same place */
-		err = bt_conn_le_start_encryption(conn,
-						  conn->le.keys->ltk.rand,
-						  conn->le.keys->ltk.ediv,
-						  conn->le.keys->ltk.val,
+		err = bt_conn_le_start_encryption(conn, conn->le.keys->ltk.rand,
+						  conn->le.keys->ltk.ediv, conn->le.keys->ltk.val,
 						  conn->le.keys->enc_size);
 		if (err) {
 			return err;
@@ -6027,12 +5858,9 @@ void bt_smp_update_keys(struct bt_conn *conn)
 
 		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 			bt_keys_add_type(conn->le.keys, BT_KEYS_LTK_P256);
-			memcpy(conn->le.keys->ltk.val, smp->tk,
-			       sizeof(conn->le.keys->ltk.val));
-			(void)memset(conn->le.keys->ltk.rand, 0,
-				     sizeof(conn->le.keys->ltk.rand));
-			(void)memset(conn->le.keys->ltk.ediv, 0,
-				     sizeof(conn->le.keys->ltk.ediv));
+			memcpy(conn->le.keys->ltk.val, smp->tk, sizeof(conn->le.keys->ltk.val));
+			(void)memset(conn->le.keys->ltk.rand, 0, sizeof(conn->le.keys->ltk.rand));
+			(void)memset(conn->le.keys->ltk.ediv, 0, sizeof(conn->le.keys->ltk.ediv));
 		} else if (IS_ENABLED(CONFIG_BT_LOG_SNIFFER_INFO)) {
 			uint8_t ltk[16];
 
@@ -6077,14 +5905,13 @@ static int bt_smp_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
 
 BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);
 #if defined(CONFIG_BT_CLASSIC)
-BT_L2CAP_BR_CHANNEL_DEFINE(smp_br_fixed_chan, BT_L2CAP_CID_BR_SMP,
-			bt_smp_br_accept);
+BT_L2CAP_BR_CHANNEL_DEFINE(smp_br_fixed_chan, BT_L2CAP_CID_BR_SMP, bt_smp_br_accept);
 #endif /* CONFIG_BT_CLASSIC */
 
 int bt_smp_init(void)
 {
 	static struct bt_pub_key_cb pub_key_cb = {
-		.func           = bt_smp_pkey_ready,
+		.func = bt_smp_pkey_ready,
 	};
 
 	sc_supported = le_sc_supported();
diff --git a/subsys/bluetooth/host/smp.h b/subsys/bluetooth/host/smp.h
index 51969aaadfb..2f39a65c864 100644
--- a/subsys/bluetooth/host/smp.h
+++ b/subsys/bluetooth/host/smp.h
@@ -10,131 +10,130 @@
  */
 
 struct bt_smp_hdr {
-	uint8_t  code;
+	uint8_t code;
 } __packed;
 
-#define BT_SMP_ERR_SUCCESS                      0x00
-#define BT_SMP_ERR_PASSKEY_ENTRY_FAILED		0x01
-#define BT_SMP_ERR_OOB_NOT_AVAIL		0x02
-#define BT_SMP_ERR_AUTH_REQUIREMENTS		0x03
-#define BT_SMP_ERR_CONFIRM_FAILED		0x04
-#define BT_SMP_ERR_PAIRING_NOTSUPP		0x05
-#define BT_SMP_ERR_ENC_KEY_SIZE			0x06
-#define BT_SMP_ERR_CMD_NOTSUPP			0x07
-#define BT_SMP_ERR_UNSPECIFIED			0x08
-#define BT_SMP_ERR_REPEATED_ATTEMPTS		0x09
-#define BT_SMP_ERR_INVALID_PARAMS		0x0a
-#define BT_SMP_ERR_DHKEY_CHECK_FAILED		0x0b
-#define BT_SMP_ERR_NUMERIC_COMP_FAILED		0x0c
-#define BT_SMP_ERR_BREDR_PAIRING_IN_PROGRESS	0x0d
-#define BT_SMP_ERR_CROSS_TRANSP_NOT_ALLOWED	0x0e
-#define BT_SMP_ERR_KEY_REJECTED			0x0f
-
-#define BT_SMP_IO_DISPLAY_ONLY			0x00
-#define BT_SMP_IO_DISPLAY_YESNO			0x01
-#define BT_SMP_IO_KEYBOARD_ONLY			0x02
-#define BT_SMP_IO_NO_INPUT_OUTPUT		0x03
-#define BT_SMP_IO_KEYBOARD_DISPLAY		0x04
-
-#define BT_SMP_OOB_DATA_MASK			0x01
-#define BT_SMP_OOB_NOT_PRESENT			0x00
-#define BT_SMP_OOB_PRESENT			0x01
-
-#define BT_SMP_MIN_ENC_KEY_SIZE			CONFIG_BT_SMP_MIN_ENC_KEY_SIZE
-#define BT_SMP_MAX_ENC_KEY_SIZE			16
-
-#define BT_SMP_DIST_ENC_KEY			0x01
-#define BT_SMP_DIST_ID_KEY			0x02
-#define BT_SMP_DIST_SIGN			0x04
-#define BT_SMP_DIST_LINK_KEY			0x08
-
-#define BT_SMP_DIST_MASK			0x0f
-
-#define BT_SMP_AUTH_NONE			0x00
-#define BT_SMP_AUTH_BONDING			0x01
-#define BT_SMP_AUTH_MITM			0x04
-#define BT_SMP_AUTH_SC				0x08
-#define BT_SMP_AUTH_KEYPRESS			0x10
-#define BT_SMP_AUTH_CT2				0x20
-
-#define BT_SMP_CMD_PAIRING_REQ			0x01
-#define BT_SMP_CMD_PAIRING_RSP			0x02
+#define BT_SMP_ERR_SUCCESS                   0x00
+#define BT_SMP_ERR_PASSKEY_ENTRY_FAILED      0x01
+#define BT_SMP_ERR_OOB_NOT_AVAIL             0x02
+#define BT_SMP_ERR_AUTH_REQUIREMENTS         0x03
+#define BT_SMP_ERR_CONFIRM_FAILED            0x04
+#define BT_SMP_ERR_PAIRING_NOTSUPP           0x05
+#define BT_SMP_ERR_ENC_KEY_SIZE              0x06
+#define BT_SMP_ERR_CMD_NOTSUPP               0x07
+#define BT_SMP_ERR_UNSPECIFIED               0x08
+#define BT_SMP_ERR_REPEATED_ATTEMPTS         0x09
+#define BT_SMP_ERR_INVALID_PARAMS            0x0a
+#define BT_SMP_ERR_DHKEY_CHECK_FAILED        0x0b
+#define BT_SMP_ERR_NUMERIC_COMP_FAILED       0x0c
+#define BT_SMP_ERR_BREDR_PAIRING_IN_PROGRESS 0x0d
+#define BT_SMP_ERR_CROSS_TRANSP_NOT_ALLOWED  0x0e
+#define BT_SMP_ERR_KEY_REJECTED              0x0f
+
+#define BT_SMP_IO_DISPLAY_ONLY     0x00
+#define BT_SMP_IO_DISPLAY_YESNO    0x01
+#define BT_SMP_IO_KEYBOARD_ONLY    0x02
+#define BT_SMP_IO_NO_INPUT_OUTPUT  0x03
+#define BT_SMP_IO_KEYBOARD_DISPLAY 0x04
+
+#define BT_SMP_OOB_DATA_MASK   0x01
+#define BT_SMP_OOB_NOT_PRESENT 0x00
+#define BT_SMP_OOB_PRESENT     0x01
+
+#define BT_SMP_MIN_ENC_KEY_SIZE CONFIG_BT_SMP_MIN_ENC_KEY_SIZE
+#define BT_SMP_MAX_ENC_KEY_SIZE 16
+
+#define BT_SMP_DIST_ENC_KEY  0x01
+#define BT_SMP_DIST_ID_KEY   0x02
+#define BT_SMP_DIST_SIGN     0x04
+#define BT_SMP_DIST_LINK_KEY 0x08
+
+#define BT_SMP_DIST_MASK 0x0f
+
+#define BT_SMP_AUTH_NONE     0x00
+#define BT_SMP_AUTH_BONDING  0x01
+#define BT_SMP_AUTH_MITM     0x04
+#define BT_SMP_AUTH_SC       0x08
+#define BT_SMP_AUTH_KEYPRESS 0x10
+#define BT_SMP_AUTH_CT2      0x20
+
+#define BT_SMP_CMD_PAIRING_REQ 0x01
+#define BT_SMP_CMD_PAIRING_RSP 0x02
 struct bt_smp_pairing {
-	uint8_t  io_capability;
-	uint8_t  oob_flag;
-	uint8_t  auth_req;
-	uint8_t  max_key_size;
-	uint8_t  init_key_dist;
-	uint8_t  resp_key_dist;
+	uint8_t io_capability;
+	uint8_t oob_flag;
+	uint8_t auth_req;
+	uint8_t max_key_size;
+	uint8_t init_key_dist;
+	uint8_t resp_key_dist;
 } __packed;
 
-#define BT_SMP_CMD_PAIRING_CONFIRM		0x03
+#define BT_SMP_CMD_PAIRING_CONFIRM 0x03
 struct bt_smp_pairing_confirm {
-	uint8_t  val[16];
+	uint8_t val[16];
 } __packed;
 
-#define BT_SMP_CMD_PAIRING_RANDOM		0x04
+#define BT_SMP_CMD_PAIRING_RANDOM 0x04
 struct bt_smp_pairing_random {
-	uint8_t  val[16];
+	uint8_t val[16];
 } __packed;
 
-#define BT_SMP_CMD_PAIRING_FAIL			0x05
+#define BT_SMP_CMD_PAIRING_FAIL 0x05
 struct bt_smp_pairing_fail {
-	uint8_t  reason;
+	uint8_t reason;
 } __packed;
 
-#define BT_SMP_CMD_ENCRYPT_INFO			0x06
+#define BT_SMP_CMD_ENCRYPT_INFO 0x06
 struct bt_smp_encrypt_info {
-	uint8_t  ltk[16];
+	uint8_t ltk[16];
 } __packed;
 
-#define BT_SMP_CMD_CENTRAL_IDENT		0x07
+#define BT_SMP_CMD_CENTRAL_IDENT 0x07
 struct bt_smp_central_ident {
 	uint8_t ediv[2];
 	uint8_t rand[8];
 } __packed;
 
-#define BT_SMP_CMD_IDENT_INFO			0x08
+#define BT_SMP_CMD_IDENT_INFO 0x08
 struct bt_smp_ident_info {
-	uint8_t  irk[16];
+	uint8_t irk[16];
 } __packed;
 
-#define BT_SMP_CMD_IDENT_ADDR_INFO		0x09
+#define BT_SMP_CMD_IDENT_ADDR_INFO 0x09
 struct bt_smp_ident_addr_info {
 	bt_addr_le_t addr;
 } __packed;
 
-#define BT_SMP_CMD_SIGNING_INFO			0x0a
+#define BT_SMP_CMD_SIGNING_INFO 0x0a
 struct bt_smp_signing_info {
 	uint8_t csrk[16];
 } __packed;
 
-#define BT_SMP_CMD_SECURITY_REQUEST		0x0b
+#define BT_SMP_CMD_SECURITY_REQUEST 0x0b
 struct bt_smp_security_request {
-	uint8_t  auth_req;
+	uint8_t auth_req;
 } __packed;
 
-#define BT_SMP_CMD_PUBLIC_KEY			0x0c
+#define BT_SMP_CMD_PUBLIC_KEY 0x0c
 struct bt_smp_public_key {
 	uint8_t x[32];
 	uint8_t y[32];
 } __packed;
 
-#define BT_SMP_DHKEY_CHECK			0x0d
+#define BT_SMP_DHKEY_CHECK 0x0d
 struct bt_smp_dhkey_check {
 	uint8_t e[16];
 } __packed;
 
-#define BT_SMP_KEYPRESS_NOTIFICATION		0x0e
+#define BT_SMP_KEYPRESS_NOTIFICATION 0x0e
 struct bt_smp_keypress_notif {
 	uint8_t type;
 } __packed;
 
-#define BT_SMP_NUM_CMDS                         0x0f
+#define BT_SMP_NUM_CMDS 0x0f
 
 int bt_smp_start_security(struct bt_conn *conn);
-bool bt_smp_request_ltk(struct bt_conn *conn, uint64_t rand, uint16_t ediv,
-			uint8_t *ltk);
+bool bt_smp_request_ltk(struct bt_conn *conn, uint64_t rand, uint16_t ediv, uint8_t *ltk);
 
 void bt_smp_update_keys(struct bt_conn *conn);
 
@@ -143,8 +142,7 @@ int bt_smp_br_send_pairing_req(struct bt_conn *conn);
 int bt_smp_init(void);
 
 int bt_smp_auth_cb_overlay(struct bt_conn *conn, const struct bt_conn_auth_cb *cb);
-int bt_smp_auth_keypress_notify(struct bt_conn *conn,
-				enum bt_conn_auth_keypress type);
+int bt_smp_auth_keypress_notify(struct bt_conn *conn, enum bt_conn_auth_keypress type);
 int bt_smp_auth_passkey_entry(struct bt_conn *conn, unsigned int passkey);
 int bt_smp_auth_passkey_confirm(struct bt_conn *conn);
 int bt_smp_auth_pairing_confirm(struct bt_conn *conn);
@@ -152,11 +150,9 @@ int bt_smp_auth_cancel(struct bt_conn *conn);
 
 int bt_smp_le_oob_set_tk(struct bt_conn *conn, const uint8_t *tk);
 int bt_smp_le_oob_generate_sc_data(struct bt_le_oob_sc_data *le_sc_oob);
-int bt_smp_le_oob_set_sc_data(struct bt_conn *conn,
-			      const struct bt_le_oob_sc_data *oobd_local,
+int bt_smp_le_oob_set_sc_data(struct bt_conn *conn, const struct bt_le_oob_sc_data *oobd_local,
 			      const struct bt_le_oob_sc_data *oobd_remote);
-int bt_smp_le_oob_get_sc_data(struct bt_conn *conn,
-			      const struct bt_le_oob_sc_data **oobd_local,
+int bt_smp_le_oob_get_sc_data(struct bt_conn *conn, const struct bt_le_oob_sc_data **oobd_local,
 			      const struct bt_le_oob_sc_data **oobd_remote);
 
 /** brief Verify signed message
diff --git a/subsys/bluetooth/host/uuid.c b/subsys/bluetooth/host/uuid.c
index 56aaaad462b..3c9846fd31a 100644
--- a/subsys/bluetooth/host/uuid.c
+++ b/subsys/bluetooth/host/uuid.c
@@ -23,23 +23,19 @@
  *  big endian 0x2800    : [28 00] -> swapping required
  */
 static const struct bt_uuid_128 uuid128_base = {
-	.uuid = { BT_UUID_TYPE_128 },
-	.val = { BT_UUID_128_ENCODE(
-		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
-};
+	.uuid = {BT_UUID_TYPE_128},
+	.val = {BT_UUID_128_ENCODE(0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB)}};
 
 static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
 {
 	switch (src->type) {
 	case BT_UUID_TYPE_16:
 		*dst = uuid128_base;
-		sys_put_le16(BT_UUID_16(src)->val,
-			     &dst->val[UUID_16_BASE_OFFSET]);
+		sys_put_le16(BT_UUID_16(src)->val, &dst->val[UUID_16_BASE_OFFSET]);
 		return;
 	case BT_UUID_TYPE_32:
 		*dst = uuid128_base;
-		sys_put_le32(BT_UUID_32(src)->val,
-			     &dst->val[UUID_16_BASE_OFFSET]);
+		sys_put_le32(BT_UUID_32(src)->val, &dst->val[UUID_16_BASE_OFFSET]);
 		return;
 	case BT_UUID_TYPE_128:
 		memcpy(dst, src, sizeof(*dst));
@@ -118,9 +114,8 @@ void bt_uuid_to_str(const struct bt_uuid *uuid, char *str, size_t len)
 		memcpy(&tmp4, &BT_UUID_128(uuid)->val[10], sizeof(tmp4));
 		memcpy(&tmp5, &BT_UUID_128(uuid)->val[12], sizeof(tmp5));
 
-		snprintk(str, len, "%08x-%04x-%04x-%04x-%08x%04x",
-			 sys_le32_to_cpu(tmp5), sys_le16_to_cpu(tmp4),
-			 sys_le16_to_cpu(tmp3), sys_le16_to_cpu(tmp2),
+		snprintk(str, len, "%08x-%04x-%04x-%04x-%08x%04x", sys_le32_to_cpu(tmp5),
+			 sys_le16_to_cpu(tmp4), sys_le16_to_cpu(tmp3), sys_le16_to_cpu(tmp2),
 			 sys_le32_to_cpu(tmp1), sys_le16_to_cpu(tmp0));
 		break;
 	default:
